# 주절주절..

# 찾아봐야 할 목록들

1. 펌웨어, 바이오스, 반도체, 시스템 호출

# 운영 체제

1. 사용자 <=> 응용 프로그램 <=> 운영 체제 <=> 하드웨어

1. 운영 체제 또는 오퍼레이팅 시스템(Operating System, OS)은 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공하는 시스템 소프트웨어다.

2. 최근에는 가상화 기술의 발전에 힘입어 실제 하드웨어가 아닌 하이퍼바이저(가상 머신) 위에서 실행되기도 한다. 

3. 또한 입출력과 메모리 할당과 같은 하드웨어 기능의 경우 운영 체제는 응용 프로그램과 컴퓨터 하드웨어 사이의 중재 역할을 한다.

4. 운영 체제는 실행되는 응용 프로그램들이 메모리와 CPU, 입출력 장치 등의 자원을 사용할 수 있도록 만들어 준다.

5. 더불어, 이들을 추상화하여 파일 시스템 등의 서비스를 제공한다.

6. 또한 멀티태스킹을 지원하는 경우, 여러 개의 응용 프로그램을 실행하고 있는 동안, 운영 체제는 이러한 모든 프로세스들을 스케줄링하여 마치 그들이 동시에 수행되는 것처럼 보이는 효과를 낸다.

7. 운영 체제는 응용 프로그램과 하드웨어 사이의 인터페이스 역할을 한다.

8. 운영 체제는 응용 프로그램 개발을 단순하게 하는 서비스의 집합이다.

9. 프로그램을 실행하면 운영 체제가 프로세스를 만든다.

10. 커널은 메모리와 다른 자원을 할당하여 프로세스를 만들며, 이로써 멀티태스킹 환경에서 프로세스에 대한 우선 순위를 확립하고, 메모리에 프로그램 코드를 적재하며 프로그램을 실행한다.

11. 그 뒤 프로그램은 사용자 및 장치와 상호작용한 다음 원하는 명령을 수행하게 된다.

12. 운영체제는 프로세스들을 생성하거나 삭제하고, 중단시키거나 재개시킨다.

13. 프로세스 간의 동기화와 통신, 교착상태 처리에 관한 메커니즘을 제공한다.

# 커널

1. 응용 프로그램 <=> 커널 <=> CPU, Memory, Devices

1. 컴퓨터 과학에서 커널(kernel)은 컴퓨터의 운영 체제의 핵심이 되는 컴퓨터 프로그램의 하나로, 시스템의 모든 것을 완전히 통제한다.

2. 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공한다.

3. 펌웨어와 장치 드라이버의 도움을 받아 커널은 모든 컴퓨터 하드웨어 장치에 대한 가장 기초 수준의 제어권을 제공한다.

4. 커널은 램을 통해 프로그램을 위한 메모리 접근을 관리하며 어느 프로그램이 어느 하드웨어 자원에 접근할지를 결정하며 CPU의 동작 상태를 늘 최적으로 설정 및 초기화하고

5. 디스크, 테이프, 플래시 메모리와 같은 매체의 파일 시스템을 갖춘 장시간 비휘발성 기억 장치를 위한 데이터를 정리한다.

6. 운영 체제 내에서의 커널의 영역과 그 구성에 따라 모놀리틱 커널(monolithic kernel), 마이크로 커널(microkernel) 등으로 구분된다.

7. 커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.

8. 한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다. 특히 프로세스에 처리기를 할당하는 것을 스케쥴링이라 한다.

9. 같은 종류의 부품에 대해 다양한 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 문제를 매우 복잡하게 만들 수 있다.

10. 일반적으로 커널은 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 인터페이스를 하드웨어 제공하기 위해 몇 가지 하드웨어 추상화(같은 종류의 장비에 대한 공통 명령어의 집합)들로 구현된다.

11. 이 하드웨어 추상화는 프로그래머가 여러 장비에서 작동하는 프로그램을 개발하는 것을 돕는다.

12. 하드웨어 추상화 계층(HAL)은 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의지한다.

13. 하드웨어 추상화 계층은 컴퓨터의 물리적인 하드웨어와 컴퓨터에서 실행되는 소프트웨어 사이의 추상화 계층이다.

# 컴퓨터 하드웨어

1. 컴퓨터 하드웨어는 케이스, 중앙 처리 장치(CPU), 모니터, 자판, 컴퓨터 기억장치, 그래픽 카드, 사운드 카드, 메인보드와 같은 컴퓨터의 물리적 부품을 의미한다.

2. 입력, 연산, 제어, 기억, 출력 등 다섯 가지 기능을 구현하며 이를 위해 컴퓨터는 여러 가지 부품들로 구성되어 있다.

3. 이와 반대가 되는 용어는 소프트웨어이며 이는 특정 작업을 수행하기 위해 하드웨어에 의해 저장되고 실행되는 명령어를 의미한다.

# 컴퓨터 소프트웨어

1. 컴퓨터 소프트웨어는 저장장치에 저장된 특정한 목적의 하나 또는 다수의 컴퓨터 프로그램을 뜻한다.

2. 프로그램 소프트웨어는 컴퓨터 하드웨어에 직접 명령어를 주거나 다른 소프트웨어에 입력을 제공함으로써, 그것을 수행하도록 구현된 기능을 수행한다.

# 펌웨어

1. 펌웨어(firmware)는 컴퓨팅과 공학 분야에서 특정 하드웨어 장치에 포함된 소프트웨어로, 소프트웨어를 읽어 실행하거나, 수정하는 것도 가능한 장치를 뜻한다.

2. 하드웨어의 제어와 구동을 담당하는 일종의 운영체제다.

3. 펌웨어는 ROM이나 PROM에 저장되며, 하드웨어보다는 교환하기가 쉽지만, 소프트웨어보다는 어렵다.

4. EX) PC에서 흔히 볼 수 있는 바이오스, 냉장고, 전기밥솥

5. 현대의 시스템에 들어가는 대부분의 장치들은 저들만의 소프트웨어를 실행하는 특수 목적의 컴퓨터들이다.

6. 이 장치들 가운데 일부는 장치 안에 있는 ROM 안에 소프트웨어(펌웨어)를 저장한다.

7. 그러나, 여러 해에 걸쳐 제조업체들은 호스트 시스템에서 펌웨어를 불러내는 것이 값이 싸면서도 유연성이 있다는 사실을 알아 냈다.

8. 그 결과, 현재의 많은 하드웨어는 호스트 컴퓨터가 필요한 펌웨어가 채워질 때까지 어떠한 방법으로도 기능을 할 수 없다.

9. 이러한 펌웨어 로드는 장치 드라이버에서 구현된다.

10. 많은 장치들의 펌웨어는 추가 하드웨어를 설치하지 않고, 보통 판매업체가 제공하는 소프트웨어를 통해 업데이트 할 수 있다.

# 장치 드라이버

1. 장치 드라이버/제어기 또는 디바이스 드라이버는 특정 하드웨어나 장치를 제어하기 위한 커널의 일부분으로 동작하는 프로그램이다.

2. 컴퓨터를 구성하는 다양한 입출력 장치마다 각각 장치드라이버가 프로그램 되어 커널에 통합되어 실행된다.

3. 높은 수준의 컴퓨터 프로그램들이 컴퓨터 하드웨어 장치와 상호 작용하기 위해 만들어진 하나의 컴퓨터 프로그램이다.

4. 장치 드라이버는 커널의 일부분이기는 하나 커널과 통합되는 것은 처음부터 해당 드라이버 프로그램 코드 소스가 커널 전체 소스에 포함되어 컴파일되는 경우도 있고,

5. 그리고 별도로 컴파일된 파일의 형태로 존재하고 부팅 시 또는 필요 시 해당 파일이 로드되어 커널과 통합되기도 한다.

6. 드라이버는 흔히 컴퓨터 버스, 또는 하드웨어와 이어진 통신 하위 시스템을 통해 장치와 통신한다.

7. 요청하는 프로그램이 드라이버의 명령어를 호출하면, 드라이버는 장치에 명령어를 전달한다.

8. 장치가 드라이버에게 데이터를 되돌려주면, 드라이버는 원래 요청한 프로그램의 명령어로 데이터를 다시 전달한다.

9. 프로그램 <=> 드라이버 <=> 장치

10. 드라이버는 하드웨어에 의존하며 특정한 운영 체제를 따른다.

11. 이러한 드라이버는 비동기 시간에 의존하는 하드웨어 인터페이스에 필요한 인터럽트를 다룰 수 있다.

12. 장치 드라이버는 흔히 장치 칩의 레지스터에 접근하여 하드웨어를 제어하며 하드웨어와 주변 기기를 사용하는 프로그램의 중간 다리 역할을 한다.

13. 커널은 부팅 시에 시작되어 컴퓨터 종료시 커널이 끝난다.

14. 장치 드라이버는 하드웨어와 밀접하게 연관되고 해당 장치를 제어하는 프로그램이다.

15. 커널 공간에서 이루어지는 작업으로는 입출력, 네트워크 등의 하드웨어 제어, 메모리와 같은 컴퓨터의 리소스 관리, 응용 프로그램의 실행 제어 등이 있다.

16. 커널과는 달리 응용 프로그램은 사용자 요청에 의해 저장장치로부터 메모리에 로드되어 실행한다.

17. 응용 프로그램이 하드웨어를 직접 제어할 수는 없기 때문에, 커널의 장치 드라이버를 사용하기 위해 시스템 호출 방법으로 커널에 접근하여 자료를 처리한다.

18. 전자 제품에서 각각의 주변 기기들을 제어하기 위해 설계된 펌웨어 또한 장치 드라이버로 분류된다.
 
# 컴퓨터 버스

1. 컴퓨터 버스는 컴퓨터 안의 부품들 간에, 또는 컴퓨터 간에 데이터와 정보를 전송하는 통로(통신 시스템)이다.

2. 이러한 표현에는 관련된 모든 하드웨어 부품들(선, 광 파이버 등) 및 통신 프로토콜을 포함한 소프트웨어를 아우른다.

3. 병렬 전기적 버스와 동일한 논리적 기능을 제공하는 물리적인 배치에 사용된다.

4. 현대의 컴퓨터 버스들은 병렬 및 비트 시리얼 연결을 둘 다 지원하며, 이들 모두 멀티드롭(전기적 병렬) 또는 데이지 체인 토폴로지로 선을 구성하거나 USB처럼 스위치 허브에 의해 연결할 수도 있다.

5. 입출력 장치와 연결된 통로는 입출력 버스(I/O Bus), 메모리와 다른 장치를 이루어지는 통로는 메모리 버스(Memory Bus)라고 한다.

# 시스템 호출

1. 시스템 호출 또는 시스템 콜(System Call)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스다.

2. 보통 C나 C++같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.

3. 운영 체제의 구성상, 커널과 응용 프로그램은 CPU의 권한 수준(privilege levels)이나 하드웨어 접근 능력이 다르다.

4. 커널은 CPU 시스템의 RAM/FLASH 등에 물리주소가 일치하는 링커구조를 가지고 특정 메모리 위치에서 동작한다.

5. 이때 커널의 기계어 코드에서 사용하는 모든 주소는 물리 주소로 고정되어 컴파일되고 로드되어 실행된다.

6. 따라서 커널은 부팅과정에서 전체 메모리 리소스 중에 일정하게 점유하여 동작하고 인터럽트 등 모든 하드웨어 접근이 가능하다.

7. 그러나 응용 프로그램은 커널이 제공하는 자원을 사용하므로 메모리에서 상황에 따라 다른 위치를 점유하고 실행된다.

8. 응용 프로그램은 사용자 요청에 따라 실행되는 프로그램이므로 물리 주소를 확정할 수 없다.

9. 따라서 응용 프로그램이 작성되면 메모리 위치가 처음부터 로드된다고 생각하고 개발도구에 링크된다.

10. 보통 MMU을 통해 논리 주소를 물리 주소로 변환한다 

11. 그리고 응용 프로그램은 CPU의 권한 수준이 사용자 공간(user space)에서 동작하며 특정한 기계어 명령 실행이 불가능하다.

12. 이와 같은 상황에서 응용 프로그램이 파일 시스템을 사용하는 등 기타 여러 상황에서 커널에 의존해야만 한다.

13. 응용 프로그램에서 커널의 서비스를 이용하는 방법이 시스템 호출이다.

14. 커널의 인터럽트 처리 등의 과정을 프로그램하려면 어셈블리어와 C와의 혼용구조로 구성된다.

15. 시스템 호출의 세 가지 기능

```

1. 사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다.

2. 시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다.

3. 커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다.

```

16. 시스템 호출의 유형 

```

1. 프로세스 제어 (Process Control)

2. 파일 조작 (File Manipulation)

3. 장치 관리 (Device Management)

4. 정보 유지 (Information mainenance)

5. 통신 (Communication)

```

# 링커

# 메모리 관리 장치

1. 메모리 관리 장치(Memory Management Unit, MMU)는 CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품이다.

2. 가상 메모리 주소를 실제 메모리 주소로 변환하며, 메모리 보호, 캐시 관리, 버스 중재 등의 역할을 담당하며 간단한 8비트 아키텍처에서는 뱅크 스위칭을 담당하기도 한다.

3. 최신 아키텍처에서 MMU는 가상 주소 공간을 2^N 비트 크기의 페이지들로 나눈다.

4. 그 가운데 일부 페이지는 실제 메모리 주소의 한 프레임에 대응되는데, 대부분의 경우 가상 주소 공간은 실제 주소 공간보다 크기 때문에 모든 페이지가 실제 메모리에 대응 되는 것은 아니다.

5. CPU가 가상 메모리 주소를 MMU에 넘겨주면 MMU는 그 주소를 받아 뒤쪽의 N 비트는 바꾸지 않고 앞쪽의 나머지 비트를 그에 해당하는 실제 메모리 주소로 바꾼다.

6. 이때 가상 메모리 주소와 실제 메모리 주소 사이의 변환을 위해 MMU는 변환 참조 버퍼(Translation Lookaside Buffer, TLB)라는 고속의 보조기억장치를 참조한다.

7. 이 보조기억장치에 원하는 변환 정보가 없을 때는 더 느린 방법으로 페이지 변환 정보를 얻어오는데, 이 페이지 변환 정보가 담겨 있는 자료구조를 페이지 테이블(Page Table)이라 한다.

8. 페이지 테이블의 동작은 아키텍처와 운영체제에 따라 서로 다르다.

9. TLB나 PTE는 또한 그 메모리 주소가 캐시되었는지, 페이지가 쓰여졌는지 (Page Dirty), 프로세스에게 메모리에 접근할 권한이 있는지 등의 정보를 저장하기도 한다.

10. TLB나 페이지 테이블이 실제 메모리 주소를 가져오지 못하는 경우가 있는데, 이를 페이지 실패(Page Fault)라 한다.

11. 대부분의 경우 페이지 실패는 가상 주소 공간의 페이지가 실제 메모리에 없기 때문에 발생한다.

12. 이 경우 운영체제가 그 처리를 담당하는데, 비어 있는 메모리 공간에 페이지를 할당하거나, 비어 있는 메모리 공간이 없을 경우 실제 메모리의 한 페이지를 빼내 하드 디스크에 저장하고 (이를 페이징이라 한다) 그 자리에 요구 받은 페이지를 할당한다.

13. ![image](https://user-images.githubusercontent.com/78199659/138395165-0e4f7231-a277-48b7-b194-af4411a0b6a1.png)


# 메모리 관리

1. 메모리 관리는 컴퓨터 메모리를 관리하는 행위이다.

2. 가장 단순한 형태의 메모리 관리 방법은 프로그램의 요청이 있을 때, 메모리의 일부를 해당 프로그램에 할당하고, 

3. 더 이상 필요하지 않을 때 나중에 다시 사용할 수 있도록 할당을 해제하는 것이다.

4. 이는 하나 이상의 프로세스가 언제든 실행되는 고급 컴퓨터 시스템에 필수적이다.

5. 가상 메모리 시스템은 프로세스가 사용하는 메모리 주소를 실제 물리 주소와 구분한다.

6. 이로써 프로세스를 구분하고 디스크 스왑 처리를 사용하여 효과적으로 사용할 수 있는 램의 양을 늘릴 수 있게 된다.

7. 가상 메모리 관리자의 품질은 전반적인 시스템 성능에 큰 영향을 미친다.

8. 쓰레기 수집은 프로그램을 위한 컴퓨터 메모리 리소스를 자동으로 할당하고 할당을 해제한다.

9. 프로그래밍 언어 수준에서 일반적으로 추가되어 있는 것이며, 수동 메모리 관리와 대조된다.

10. 운영 체제의 메모리 관리에 대한 주된 목표

```

1. 여러 프로세스가 동시에 실행될 수 있도록 메모리 공간을 제한할 것

2. 시스템 사용자들을 위해 만족할 만한 수준의 성능을 제공할 것

3. 각 프로그램의 리소스를 보호할 것

4. 프로세스 사이에 있는 메모리 공간을 공유할 것

5. 프로그래머를 위해 되도록 메모리 공간의 어드레싱을 투명하게 할 것

```

# 가상 메모리

1. 가상 메모리(Virtual Memory) 또는 가상 기억 장치(Virtual Storage)는 메모리 관리 기법의 하나로, 기계에 실제로 이용 가능한 기억 자원을 이상적으로 추상화하여 사용자들에게 매우 큰 (주) 메모리로 보이게 만드는 것을 말한다.

2. 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식이다.

3. 이러한 방식은 멀티태스킹 운영 체제에서 흔히 사용되며, 실제 주기억장치보다 큰 메모리 영역을 제공하는 방법으로도 사용된다.

4. 가상적으로 주어진 주소를 논리 주소(Logical Address) 또는 가상 주소(Virtual Address)라고 하며, 실제 메모리 상에서 유효한 주소를 실 주소(Real Address) 또는 물리 주소(Physical Address)라고 한다.

5. 가상 주소 공간은 메모리 관리 장치(MMU)에 의해서 물리 주소로 변환된다.

6. 이 덕분에 프로그래머는 가상 주소 공간상에서 프로그램을 짜게 되어 프로그램이나 데이터가 주메모리상에 어떻게 존재하는지를 의식할 필요가 없어진다.

1. ![image](https://user-images.githubusercontent.com/78199659/138395185-b01e9389-5c65-49f8-976d-80d290a63783.png)

# 프로세스

1. 프로세스(Process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.

2. 종종 스케줄링의 대상이 되는 작업(Task)이라는 용어와 거의 같은 의미로 쓰인다.

3. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다.

4. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.

5. 프로그램은 일반적으로 하드 디스크 등에 저장되어 있는 실행코드를 뜻하고, 

6. 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다.

7. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행된다.

8. 커널 내에는 준비 큐, 대기 큐, 실행 큐 등의 자료구조가 있으며 커널은 이것들을 이용하여 프로세스의 상태를 관리한다.

8. 프로세스의 상태

```

1. 생성(create) : 프로세스가 생성되는 중이다.

2. 실행(running) : 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.

3. 준비(ready) : 프로세스가 CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리고 있다. 

일반적으로 준비 상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받는다.

4. 대기(waiting) : 보류(block)라고 부르기도 한다. 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태를 말한다.

5. 종료(terminated) : 프로세스의 실행이 종료되었다.

```

10. 하나의 프로그램이 실행되면 그 프로그램에 대응되는 프로세스가 생성되어 준비 리스트의 끝에 들어간다.

12. 준비 리스트 상의 다른 프로세스들이 CPU를 할당받아 준비 리스트를 떠나면, 그 프로세스는 점차 준비 리스트의 앞으로 나가게 되고 언젠가 CPU를 사용할 수 있게 된다.

9. 프로세스의 상태전이

```

1. 디스 패치(dispatch) : 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것, 즉 준비 상태에서 실행 상태로 바뀌는 것을 디스패치라고 하며 다음과 같이 표시한다.

dispatch (processname) : ready -> running

2. 보류(block) : 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 입출력 동작을 필요로 하는 경우 프로세스는 CPU를 스스로 반납하고 보류 상태로 넘어간다.

block (processname) : running -> blocked

3. 깨움(wakeup) : 입출력 작업 종료 등 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정을 깨움이라고 하며 다음과 같이 표시한다.

wakeup (processname) : blocked -> ready

4. 시간제한(timeout) : 운영 체제는 프로세스가 CPU를 계속 독점해서 사용하지 못하게 하기 위해 clock interrupt를 두어서 프로세스가 일정 시간동안만 (시분할 시스템의 time slice) CPU를 점유할 수 있게 한다.

timeout (processname) : running -> ready

```




# 뱅크 스위칭

1. 뱅크 스위칭(Bank Switching)은 마이크로프로세서의 주소 공간보다 많은 메모리를 활용하기 위해 개발된 기술이다.

2. 주로 8비트 마이크로프로세스에서 사용되었으며, 거의 대부분의 8비트 마이크로프로세서가 16비트 주소 공간이므로 2^16 = 65536 메모리 공간을 갖는다.

3. 이것보다 많은 메모리를 확장하려면 뱅크스위칭을 사용한다.

4. 그러나 주소공간 내에서 액세스가 되어야 하므로 동시에 64kB보다 많은 공간을 식별할 수 없다.

5. 따라서 사용하는 뱅크를 설정하고 해당공간만을 액세스하다가, 뱅크를 바꾸어 다른 공간을 활용한다.

6. 같은 주소 공간의 뱅크를 스위칭하는 방법은 논리회로의 주소 디코더에 의한 설정에 의해 결정된다.

7. 같은 주소공간의 여러개의 뱅크 중에 선택된 뱅크만이 액세스 되도록 하고 선택되지 않은 뱅크는 데이터를 유지만 하도록 동작 한다.

8. 뱅크를 스위칭할 때, 전체를 하나의 단위로만 만들고 주소 공간을 스위칭하면 뱅크를 선택하여 다른 뱅크로 데이터를 복사할 수가 없게 된다.

9. 따라서 전체 주소 공간을 특정 크기로 나누어 놓고 각각의 블럭을 선택하게 함으로써 뱅크간의 데이터 복사가 가능해진다.

10. ![image](https://user-images.githubusercontent.com/78199659/138385989-f220e1db-bf0f-452c-b52b-d0b5dda60a54.png)


# 주소 공간

# 어셈블리어

1. 

# 바이오스

1. 바이오스(Basic Input/Output System, BIOS)는 운영 체제 중 가장 기본적인 소프트웨어이자 컴퓨터의 입출력을 처리하는 펌웨어다.

2. 사용자가 컴퓨터를 켜면 시작되는 프로그램으로 주변 장치(하드웨어)와 컴퓨터 운영 체제(소프트웨어) 사이의 데이터의 흐름을 관리한다.

3. 펌웨어의 한 종류로서 IBM호환 컴퓨터의 경우에 전원이 공급되면 시작되는 부팅 절차에서 하드웨어 초기화를 수행하고, 운영체제나 응용 프로그램에게 런타임 서비스(컴퓨터 프로그램의 실행을 지원하는 서비스)를 제공한다.


# 추상화 계층

1. 컴퓨터 구조에서 컴퓨터 시스템은 일반적으로 다섯 가지 수준으로 구성된다.

1. 운영체제 및 응용 프로그램

2. 커널

3. 어셈블러

4. 펌웨어

5. 하드웨어

# 중앙 처리 장치

1. 중앙 처리 장치 또는 CPU(Central Processing Unit)는 컴퓨터 시스템을 통제하고 프로그램의 연산을 실행하고 처리하는 가장 핵심적인 컴퓨터의 제어 장치, 혹은 그 기능을 내장한 칩을 말한다.

2. 컴퓨터 안의 중앙 처리 장치(CPU)는 외부에서 정보를 입력 받고, 기억하고, 컴퓨터 프로그램의 명령어를 해석하여 연산하고, 외부로 출력하는 역할을 한다.

3. 따라서 중앙 처리 장치(CPU)는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 시스템 전체를 제어하는 장치로, 모든 컴퓨터의 작동과정이 중앙 처리 장치(CPU)의 제어를 받기 때문에 컴퓨터의 두뇌에 해당한다고 할 수 있다.

4. CPU에는 MCU(Micro Control Unit)와 주변 장치가 다 들어있는 단일 칩 시스템(System on Chip, SoC)이 있다.

5. CPU는 기계어로 쓰인 컴퓨터 프로그램의 명령어를 해석하여 실행한다.

6. CPU는 프로그램에 따라 외부에서 정보를 입력받아, 이를 기억하고, 연산하며 결과를 외부로 출력한다.

7. CPU는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 전체의 동작을 제어한다.

8. 기본 구성으로는 CPU에서 처리할 명령어를 저장하는 역할을 하는 프로세서 레지스터와 비교, 판단, 연산을 담당하는 산술논리연산장치(ALU), 명령어의 해석과 올바른 실행을 위하여 CPU를 내부적으로 제어하는 제어부(control unit)와 내부 버스 등이 있다.

9. 각종 전자 부품과 반도체 칩을 하나의 작은 칩에 내장한 전자 부품을 마이크로프로세서라고 한다.

10. 마이크로프로세서는 전기밥통에 쓰이는 낮은 성능의 제품부터 컴퓨터에 쓰이는 높은 성능의 제품까지 매우 다양하다.

11. 마이크로프로세서들 가운데 가장 복잡하고 성능이 높은 제품은 컴퓨터의 연산 장치로 쓰인다. 이것을 중앙 처리 장치라고 한다.

12. 모든 CPU에서 메모리에 저장된 명령어들을 순서대로 불러와서 실행한다는 사실은 물리적형태와는 관계없이 동일하다.

13. 그리고 CPU가 이 동작을 수행하기 위해서는 꺼내고, 해독하고, 실행하는 5단계가 필요하다.

14. 마지막 단계에서 명령어를 실행하고난 이후에는 다시 이 다섯 단계의 명령 주기가 반복되며, 프로그램 카운터의 변화된 위치에서 실행될 명령어를 불러오게 된다.

```

5단계

인출 - 첫 번째 단계인 인출(Fetch)은 프로그램의 메모리에서 명령어를 불러오는 역할을 한다. 프로그램 내부의 명령어의 위치(주소)

해독 - 두 번째 단계인 해독(Decode)은 인출 단계에서 가져온 명령어를 해독하여 명령어 내의 데이터 정보와 연산 정보를 추출한 뒤, 중앙 처리 장치 내의 각 장치에 적절한 제어신호를 보내 연산, 처리에 대한 준비를 하는 단계이다.

실행 - 실행(Execute)은 명령어에서 추출한 두 데이터와 연산 정보를 이용해 실제로 연산을 하는 단계를 말한다. 연산이 끝난 결과는 곧바로 명령어에서 사용될지, 그렇지 않을지에 따라 메모리 단계로 갈지, 라이트 백 단계로 갈지 결정된다.

메모리 - 네 번째 단계인 메모리(Memory)는 연산결과가 다음 명령어에 바로 사용되지 않는다면, 결과를 메모리에 저장하는 것을 말한다.

라이트백 - 연산의 마지막 단계인 라이트백(Write-Back)은 이전 명령어의 연산 결과가 다음 명령어의 입력 데이터로 사용될 경우, 계산 결과를 레지스터에 다시 쓰는 것을 말한다.

```


# 제어장치 

1. 제어장치(Control Unit, CU)는 프로세스의 조작을 지시하는 컴퓨터 중앙 처리 장치(CPU)의 한 부품이다.

2. 입출력 장치 간 통신 및 조율을 제어한다.

3. 명령어들을 읽고 해석하며 데이터 처리를 위한 시퀀스를 결정한다.

# 프로세스 레지스터

1. 프로세스 레지스터(process register) 또는 단순히 레지스터는 컴퓨터의 프로세서(CPU) 내에서 자료를 보관하는 아주 빠른 기억 장소이다.

2. 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용된다.

3. 대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로 저장하는 로드-스토어 설계를 사용하고 있다.

4. 레지스터는 메모리 계층의 최상위에 위치하며, 가장 빠른 속도로 접근 가능한 메모리이다.

5. 최신 프로세서에서 레지스터는 대게 레지스터 파일로 구현되지만, 과거에는 플립플롭, 마그네틱 코어, 박막 필름 메모리 등으로 구현되기도 했다.

6. 프로세서 내부의 레지스터 구성

```

프로그램 계수기(PC) : 다음에 실행할 명령어의 주소를 가지고 있다.

명령어 레지스터(IR) : 현재 수행 중인 명령어를 가지고 있다.

메모리 주소 레지스터(MAR) : 메모리로부터 읽어오거나 메모리에 쓰기 위한 주소를 가지고 있다.

```

# 메모리 계층 구조

1. 메모리 계층 구조(Memory Hierarchy)란 메모리를 필요에 따라 여러가지 종류로 나누어 둠을 의미한다.

2. 이때 필요한 대부분의 경우 CPU가 메모리에 더 빨리 접근하기 위함이다.

3. ![image](https://user-images.githubusercontent.com/78199659/138234076-7a2e26f5-9c96-4656-b57e-36c6eeb077a2.png)

4. 레지스터와 캐시는 CPU 내부에 존재한다. 당연히 CPU는 아주 빠르게 접근할 수 있다.

5. 메모리는 CPU 외부에 존재한다.

6. 레지스터와 캐시보다 더 느리게 접근할 수 밖에 없다.

7. 하드 디스크는 CPU가 직접 접근할 방법조차 없다.

8. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다.

# 램

1. 컴퓨터에서 랜덤 액세스 메모리(Random Access Memory, RAM)는 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치다.

2. 반도체 회로로 구성되어 있으며 휘발성 메모리다.

3. RAM은 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸리는 메모리이기에 '랜덤'이라는 명칭이 주어진다.

4. 반면, 하드 디스크, 플로피 디스크 등의 자기 디스크나 자기 테이프는 저장된 위치에 따라 접근하는 데 걸리는 시간이 다르다.

# 고정 기억 장치 

1. 고정 기억 장치 또는 롬(Read-Only Memory, ROM)은 반도체 기억장치의 하나로 사람의 본능에 비유할 수 있으며, 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있다.

2. 그리고 그 정보들을 기억하기 위해 다른 정보들은 기억하지 않는다.

3. 그러나 램(RAM)은 읽고 쓰기가 가능하다.

4. 대신 전원을 끄면 데이터가 지워진다.

5. 하지만 롬은 전원을 꺼도 데이터가 지워지지 않기 때문에 바이오스(BIOS)나 운영 체제(OS)또는 펌웨어의 저장에 쓰였으나 최근에는 일부분이 읽고 쓰기가 가능한 플래시 메모리 등으로 일부 대체되었다.

# 플래시 메모리

1. 플래시 메모리(flash memory)는 전기적으로 데이터를 지우고 다시 기록할 수 있는(electrically erased and reprogrammed) 비휘발성 컴퓨터 기억 장치를 말한다.

2. EEPROM과 다르게 여러 구역으로 구성된 블록 안에서 지우고 쓸 수 있다.

3. 이제는 플래시 메모리의 가격이 EEPROM 보다 훨씬 싸기 때문에, 비휘발성 고체 상태(solid-state) 저장 매체가 상당량 필요한 곳에서는 가장 많이 사용되는 메모리 종류가 되었다.

4. 대표적인 활용 예로 디지털 음악 재생기(MP3), 디지털 카메라, 휴대 전화를 들 수 있다. 일반적인 데이터를 저장하고 컴퓨터 사이에 데이터를 옮기는 용도로 USB 드라이브를 많이 사용하는데, 이때도 플래시 메모리가 쓰인다.

5. 플래시 메모리는 메모리 칩 안에 정보를 유지시키는 데에 전력이 필요 없는 비휘발성 메모리이다.

6. 게다가 플래시 메모리는 읽기 속도가 빠르며(단, 개인용 컴퓨터에서 메인 메모리로 쓰이는 DRAM만큼 빠르지는 않고, 순차 읽기 속도는 하드디스크가 더 빠를 수 있음) 하드 디스크보다 충격에 강하다.

7. 이러한 특징으로 배터리로 동작하는 장치에서 저장 장치로 많이 사용한다.

# 기억 장치

1. 주기억 장치 - 1차 기억 장치 - 컴퓨터 메모리 - 휘발성 메모리 - 전원 공급이 중단되면 기억된 내용이 지워진다. 

- 디램(Dynamic Random Access Memory, DRAM) - 데이터를 유지하기 위해 일정 시간마다 재생(refresh)해 주어야 하는 램

- 에스램(Static Random Access Memory, SRAM) - 전원이 공급되는 동안 데이터가 유지되는 램. 일정 시간마다 재생해주지 않아도 된다.

2. 보조기억 장치 - 2차 기억 장치 - 비휘발성 메모리(non-volatile memory, NVM) - 전원 공급이 끊어져도 기억된 내용은 지워지지 않는다. (장기간의 영구적 저장 공간) - 롬, 플래시 메모리, 마그네틱 컴퓨터 기억 장치(하드 디스크, 디스켓 드라이브, 마그네틱 테이프), 광디스크 드라이브 등

- 에프램(Ferroelectic Random Access Memory, FRAM) - 디램과 비슷하지만 데이터를 유지하기 때문에 재생해주지 않아도 된다.

- 피램(Phase-change Random Access Memory, PRAM) - 상변태를 하는 물질을 이용하여 저항차이로 데이터를 저장한다. 디램에 비하여 전력 소모가 매우 작은 장점이 있다.

3. 여러 기업들이 휘발성 메모리인 램(RAM)에 비해, 속도나 용량 면에서 뒤떨어지지 않는 신소재의 비휘발성 메모리를 개발하려고 노력하고 있다.
