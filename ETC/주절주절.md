# 주절주절..

# 찾아봐야 할 목록들

1. 반도체, 클라우드 컴퓨팅

# 운영 체제

1. 사용자 <=> 응용 프로그램 <=> 운영 체제 <=> 하드웨어

1. 운영 체제 또는 오퍼레이팅 시스템(Operating System, OS)은 시스템 하드웨어를 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위하여 하드웨어 추상화 플랫폼과 공통 시스템 서비스를 제공하는 시스템 소프트웨어다.

2. 최근에는 가상화 기술의 발전에 힘입어 실제 하드웨어가 아닌 하이퍼바이저(가상 머신) 위에서 실행되기도 한다. 

3. 또한 입출력과 메모리 할당과 같은 하드웨어 기능의 경우 운영 체제는 응용 프로그램과 컴퓨터 하드웨어 사이의 중재 역할을 한다.

4. 운영 체제는 실행되는 응용 프로그램들이 메모리와 CPU, 입출력 장치 등의 자원을 사용할 수 있도록 만들어 준다.

5. 더불어, 이들을 추상화하여 파일 시스템 등의 서비스를 제공한다.

6. 또한 멀티태스킹을 지원하는 경우, 여러 개의 응용 프로그램을 실행하고 있는 동안, 운영 체제는 이러한 모든 프로세스들을 스케줄링하여 마치 그들이 동시에 수행되는 것처럼 보이는 효과를 낸다.

7. 운영 체제는 응용 프로그램과 하드웨어 사이의 인터페이스 역할을 한다.

8. 운영 체제는 응용 프로그램 개발을 단순하게 하는 서비스의 집합이다.

9. 프로그램을 실행하면 운영 체제가 프로세스를 만든다.

10. 커널은 메모리와 다른 자원을 할당하여 프로세스를 만들며, 이로써 멀티태스킹 환경에서 프로세스에 대한 우선 순위를 확립하고, 메모리에 프로그램 코드를 적재하며 프로그램을 실행한다.

11. 그 뒤 프로그램은 사용자 및 장치와 상호작용한 다음 원하는 명령을 수행하게 된다.

12. 운영체제는 프로세스들을 생성하거나 삭제하고, 중단시키거나 재개시킨다.

13. 프로세스 간의 동기화와 통신, 교착상태 처리에 관한 메커니즘을 제공한다.

# 커널

1. 응용 프로그램 <=> 커널 <=> CPU, Memory, Devices

1. 컴퓨터 과학에서 커널(kernel)은 컴퓨터의 운영 체제의 핵심이 되는 컴퓨터 프로그램의 하나로, 시스템의 모든 것을 완전히 통제한다.

2. 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공한다.

3. 펌웨어와 장치 드라이버의 도움을 받아 커널은 모든 컴퓨터 하드웨어 장치에 대한 가장 기초 수준의 제어권을 제공한다.

4. 커널은 램을 통해 프로그램을 위한 메모리 접근을 관리하며 어느 프로그램이 어느 하드웨어 자원에 접근할지를 결정하며 CPU의 동작 상태를 늘 최적으로 설정 및 초기화하고

5. 디스크, 테이프, 플래시 메모리와 같은 매체의 파일 시스템을 갖춘 장시간 비휘발성 기억 장치를 위한 데이터를 정리한다.

6. 운영 체제 내에서의 커널의 영역과 그 구성에 따라 모놀리틱 커널(monolithic kernel), 마이크로 커널(microkernel) 등으로 구분된다.

7. 커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.

8. 한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다. 특히 프로세스에 처리기를 할당하는 것을 스케쥴링이라 한다.

9. 같은 종류의 부품에 대해 다양한 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 문제를 매우 복잡하게 만들 수 있다.

10. 일반적으로 커널은 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 인터페이스를 하드웨어 제공하기 위해 몇 가지 하드웨어 추상화(같은 종류의 장비에 대한 공통 명령어의 집합)들로 구현된다.

11. 이 하드웨어 추상화는 프로그래머가 여러 장비에서 작동하는 프로그램을 개발하는 것을 돕는다.

12. 하드웨어 추상화 계층(HAL)은 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의지한다.

13. 하드웨어 추상화 계층은 컴퓨터의 물리적인 하드웨어와 컴퓨터에서 실행되는 소프트웨어 사이의 추상화 계층이다.


# 중앙 처리 장치

1. 중앙 처리 장치 또는 CPU(Central Processing Unit)는 컴퓨터 시스템을 통제하고 프로그램의 연산을 실행하고 처리하는 가장 핵심적인 컴퓨터의 제어 장치, 혹은 그 기능을 내장한 칩을 말한다.

2. 컴퓨터 안의 중앙 처리 장치(CPU)는 외부에서 정보를 입력 받고, 기억하고, 컴퓨터 프로그램의 명령어를 해석하여 연산하고, 외부로 출력하는 역할을 한다.

3. 따라서 중앙 처리 장치(CPU)는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 시스템 전체를 제어하는 장치로, 모든 컴퓨터의 작동과정이 중앙 처리 장치(CPU)의 제어를 받기 때문에 컴퓨터의 두뇌에 해당한다고 할 수 있다.

4. CPU에는 MCU(Micro Control Unit)와 주변 장치가 다 들어있는 단일 칩 시스템(System on Chip, SoC)이 있다.

5. CPU는 기계어로 쓰인 컴퓨터 프로그램의 명령어를 해석하여 실행한다.

6. CPU는 프로그램에 따라 외부에서 정보를 입력받아, 이를 기억하고, 연산하며 결과를 외부로 출력한다.

7. CPU는 컴퓨터 부품과 정보를 교환하면서 컴퓨터 전체의 동작을 제어한다.

8. 기본 구성으로는 CPU에서 처리할 명령어를 저장하는 역할을 하는 프로세서 레지스터와 비교, 판단, 연산을 담당하는 산술논리연산장치(ALU), 명령어의 해석과 올바른 실행을 위하여 CPU를 내부적으로 제어하는 제어부(control unit)와 내부 버스 등이 있다.

9. 각종 전자 부품과 반도체 칩을 하나의 작은 칩에 내장한 전자 부품을 마이크로프로세서라고 한다.

10. 마이크로프로세서는 전기밥통에 쓰이는 낮은 성능의 제품부터 컴퓨터에 쓰이는 높은 성능의 제품까지 매우 다양하다.

11. 마이크로프로세서들 가운데 가장 복잡하고 성능이 높은 제품은 컴퓨터의 연산 장치로 쓰인다. 이것을 중앙 처리 장치라고 한다.

12. 모든 CPU에서 메모리에 저장된 명령어들을 순서대로 불러와서 실행한다는 사실은 물리적형태와는 관계없이 동일하다.

13. 그리고 CPU가 이 동작을 수행하기 위해서는 꺼내고, 해독하고, 실행하는 5단계가 필요하다.

14. 마지막 단계에서 명령어를 실행하고난 이후에는 다시 이 다섯 단계의 명령 주기가 반복되며, 프로그램 카운터의 변화된 위치에서 실행될 명령어를 불러오게 된다.

```

5단계

인출 - 첫 번째 단계인 인출(Fetch)은 프로그램의 메모리에서 명령어를 불러오는 역할을 한다. 프로그램 내부의 명령어의 위치(주소)

해독 - 두 번째 단계인 해독(Decode)은 인출 단계에서 가져온 명령어를 해독하여 명령어 내의 데이터 정보와 연산 정보를 추출한 뒤, 중앙 처리 장치 내의 각 장치에 적절한 제어신호를 보내 연산, 처리에 대한 준비를 하는 단계이다.

실행 - 실행(Execute)은 명령어에서 추출한 두 데이터와 연산 정보를 이용해 실제로 연산을 하는 단계를 말한다. 연산이 끝난 결과는 곧바로 명령어에서 사용될지, 그렇지 않을지에 따라 메모리 단계로 갈지, 라이트 백 단계로 갈지 결정된다.

메모리 - 네 번째 단계인 메모리(Memory)는 연산결과가 다음 명령어에 바로 사용되지 않는다면, 결과를 메모리에 저장하는 것을 말한다.

라이트백 - 연산의 마지막 단계인 라이트백(Write-Back)은 이전 명령어의 연산 결과가 다음 명령어의 입력 데이터로 사용될 경우, 계산 결과를 레지스터에 다시 쓰는 것을 말한다.

```


# 모놀리식 커널

1. ![image](https://user-images.githubusercontent.com/78199659/139608640-7709c792-877e-469c-ae96-b73059ce0832.png)

2. 운영 체제에서 모놀리식 커널(Monolithic Kernel)은 커널의 구조 및 설계 사상을 가리킨다. 단일형 커널이라고도 한다.

3. 입출력 기능, 네트워크 기능, 장치 지원 등 운영체제의 일반적인 기능을 커널과 동일한 메모리 공간에 적재, 실행하는 기법을 말한다.

4. 대표적인 모놀리식 커널 OS로서는, 고전적인 유닉스 계열 운영 체제들을 들 수 있다.

5. 운영 체제의 구성 요소를 단일의 메모리 공간에서 실행하는 모놀리식 커널에 대해, OS를 구성하는 몇 개의 요소, 기능을 커널 공간으로부터 떼어내어, 외부 모듈화하는 등으로 추가하는 기법을 마이크로 커널이라고 부른다.

6. 모놀리식 커널의 설계 사상 및 개념 그 자체는 예전부터 존재했지만, 모놀리식 커널이라고 하는 용어가 성립된 것은, 마이크로 커널이라는 개념이 등장하면서 그 반대 개념으로 명명되었다.

7. 모놀리식 커널 방식은 보다 근대적인 설계 방법으로 여겨지는 마이크로 커널 방식의 OS에 비해, 운영 체제의 기능 중 거의 모든 것이 단일 메모리 공간에서 행해지고,

8. 동일한 프로세스를 처리할 때 사용되는 문맥 교환이나 프로세스 간 통신 등에 의한 과부하는 상대적으로 적어서, 실질적인 성능 면에서 유리하다는 주장이 있다.

9. 실행 환경이 진보하면서 L4 프로젝트에서 프로세스 간 통신의 튜닝 등을 통한 마이크로 커널 구현 시의 고속화 기법이 진전되고, 또 필요에 따라서 마이크로 커널 구조를 기반으로 하면서 일부 성능이 요구되는 

10. 하부조직만 커널 공간에 추가한다든지, 모놀리식 커널을 기반으로 하면서 유연성이나 신뢰성이 요구되는 부분에 마이크로 커널적인 설계 방법을 도입하는 등 보다 현실적인 하이브리드 커널로 부를 수 있는 설계 방법도 등장하였다.

11. 모놀리식 커널에 여러 기능을 중도에 추가하여 덩치가 커지게 되면 운영 체제의 기능을 동적으로 바꾸거나 갱신하거나 하는 것이(마이크로 커널과 비교했을 경우에) 어렵게 되는 문제가 발생할 가능성이 높다.

# 프로세스 간 통신

1. 프로세스 간 통신(Inter-Process Communication, IPC)이란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.

2. IPC는 마이크로 커널과 나노 커널의 디자인 프로세스에 매우 중요하다.

3. 해당 기능들은 IPC를 통해 서버와 통신함으로써 얻으며 일반적인 모놀리식 커널에 비해 IPC의 수가 극적으로 증가된다.

# 마이크로 커널

1. 마이크로 커널은 컴퓨터 과학에서 운영 체제에 추가되어야 하는 메커니즘을 최소한으로 제공하는 초소형 커널이다.

2. 이러한 미니멀리티 메커니즘에는 낮은 수준의 주소 공간 관리, 스레드 관리, 프로세스 간 통신(IPC)을 포함한다.

3. 하드웨어가 여러 개의 보호 링과 CPU 모드를 제공한다면 마이크로커널은 최고 권한 수준(일반적으로 수퍼바이저 및 커널 모드로 부름)에서 실행되는 유일한 소프트웨어가 된다.

4. 소스 코드 크기 측면에서 마이크로 커널은 일반적으로 10,000 줄 이하의 코드를 지니는 경향이 있다.

5. ![image](https://user-images.githubusercontent.com/78199659/139609634-81dd96ac-f028-466f-b275-5280ee94e3e2.png)

# 나노 커널

1. 나노 커널 또는 피코 커널이라는 용어는 역사적으로 다음을 가리킨다.

```

1. 모든 커널 코드의 양이 매우 작은 커널

2. 운영 체제 밑에 존재하는 가상화 계층(하이퍼바이저)

3. 가장 낮은 수준의 커널 부분을 형성하는 하드웨어 추상화 계층(HAL)

```

# 보호 링

1. ![image](https://user-images.githubusercontent.com/78199659/139609918-31e35cc0-a200-4d1e-bffa-d1df6b2d0c24.png)

1. 컴퓨터 과학에서 계층 보호 도메인(Hierarchical Protection Domains), 즉 보호 링(Protection Rings)은 결함(결함 내성) 및 악성 행동(컴퓨터 보안)으로부터 데이터와 기능을 보호하는 메커니즘이다.

2. 이러한 접근은 능력 기반 보안(Capability-Based Security)의 접근과 완전히 반대이다

3. 수퍼바이저 모드(Supervisor Mode)는 시스템 수준의 소프트웨어에서 실행하는 코드가 변경할 수 있는 하드웨어 중재 플래그이다.

4. 시스템 수준의 작업이나 스레드는 이들이 싈행되는 동안 이 플래그 집합을 가지지만 사용자 공간의 응용 프로그램들은 그렇지 않다.

5. PC 월드에 따른 예는 다음과 같다.

```

1. 리눅스, 윈도우는 수퍼바이저/사용자 모드를 사용하는 운영 체제이다. 

특별한 명령을 수행하기 위해 사용자 모드 코드는 시스템 호출을 수퍼바이저나 커널 공간으로 호출하여야 운영 체제의 신뢰된 코드가 필요한 작업을 수행하여 사용자 공간으로 이를 반환할 수 있다.

2. 도스 및 기타 단순 운영 체제, 수많은 임베디드 장치는 영구적으로 수퍼바이저 모드에서 실행되는데, 이는 드라이버가 사용자 프로그램으로서 직접 작성될 수 있음을 의미한다. ?

```

6. 인텔과 AMD가 출시한 최근의 CPU는 하이퍼바이저가 링 0 하드웨어 접근을 제어할 수 있게 만드는 x86 가상화 명령을 제공한다.

7. 이들이 서로 호환되지는 않지만, 인텔 VT-x, AMD-V 둘 다 새로운 "링-1"을 만들어내는데, 이로써 게스트 운영체제가 링 0 동작을 호스트 운영 체제나 다른 게스트 운영 체제에 영향을 미치지 않고도 네이티브하게 수행할 수 있다.

# 리눅스 커널

1. 리눅스 커널(Linux Kernel)은 오픈 소스 모놀리식 유닉스 계열 컴퓨터 운영 체제 커널이다.

2. 리눅스 계열의 운영 체제는 이 커널에 기반을 두며 개인용 컴퓨터와 서버와 같은 전통적인 컴퓨터 시스템들과 라우터, 무선 액세스 포인트, PBX, 셋톱박스, FTA 리시버, 스마트 TV, PVR, NAS 어플라이언스 등

3. 다양한 임베디드 장치에 보통 리눅스 배포판의 형태로 배치된다.

4. 태블릿 컴퓨터, 스마트폰, 스마트워치를 이용한 안드로이드 운영 체제는 기능 구현을 위해 리눅스 커널이 제공하는 서비스들을 사용한다.

5. 데스크톱 컴퓨터에 채용하는 경우가 낮은 편이지만 리눅스 기반 운영 체제들은 모바일 장치에서부터 메인프레임에 이르기까지 거의 모든 컴퓨팅 부문을 지배하고 있다.

6. 리눅스 커널 API는 사용자 프로그램들이 커널과 통신하는 API로서 매우 안정적이고 유저스페이스 프로그램(GUI를 갖추고 다른 API에 의존하는 일부 프로그램)을 망가트리지 않는다는 것을 뜻한다.

7. 커널 기능의 일부로서 장치 드라이버들은 하드웨어를 제어한다.

8. 즉, 주류 장치 드라이버들은 매우 안정적임을 뜻한다.

9. 그러나 수많은 커널과 운영 체제와 달리 커널과 적재 가능 커널 모듈(LKM) 간의 인터페이스가 매우 안정적으로 설계되었다는 것을 뜻하는 것은 아니다.

10. <a title="Conan at English Wikipedia, CC BY 3.0 &lt;https://creativecommons.org/licenses/by/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Linux_kernel_map.png"><img width="512" alt="Linux kernel map" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Linux_kernel_map.png/512px-Linux_kernel_map.png"></a>

11. 리눅스 커널은 진정한 선점형 멀티태스킹, 가상 메모리, 공유 라이브러리, 디맨드 로딩, 공유 카피 온 라이트 실행 파일, 메모리 관리, 인터넷 프로토콜 스위트, 스레딩을 지원하는 모놀리식 커널이다.

12. 장치 드라이버와 커널 확장 기능은 커널 공간(수많은 CPU 구조에서 링 0)에서 실행되며, 하드웨어에 대한 모든 접근 권한이 있으나 사용자 공간에서의 실행은 일부 예외가 있는데 이를테면 FUSE/CUSE 기반 파일 시스템들, UIO의 일부가 그러하다.

13. 대부분의 사람들이 리눅스와 함께 사용하는 그래픽스 시스템은 커널 내에서 실행되지 않는다.

14. 표준 모놀리식 커널과 달리 장치 드라이버는 쉽게 모듈로 구성되며 시스템이 실행 중인 동안에 적재되거나 적재가 해제된다.

15. 또, 표준 모놀리식 커널과 달리 장치 드라이버들은 특정한 조건에서 선점이 가능하다.

16. 즉, 이 기능은 하드웨어 인터럽트를 정확히 관리하고 대칭형 다중 처리를 더 양호하게 지원하기 위해 추가되었다.

17. 리눅스 커널은 자체적으로 응용 프로그램 이진 인터페이스가 없다.

18. 하드웨어 또한 파일 계층에 통합되어 있다.

20. <a title="Shmuel Csaba Otto Traian, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Linux_kernel_ubiquity.svg"><img width="512" alt="Linux kernel ubiquity" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Linux_kernel_ubiquity.svg/512px-Linux_kernel_ubiquity.svg.png"></a>

19. 장치 드라이버들은 /dev 또는 /sys 디렉터리의 엔트리를 통해 사용자 응용 프로그램들과 통신한다.

20. 프로세스 정보 또한 /proc 디렉터리를 통해 파일 시스템에 매핑된다.

21. ![스크린샷 2021-11-01 오후 2 26 35](https://user-images.githubusercontent.com/78199659/139625610-c1741672-7c62-442a-88e9-cafac9a943bd.png)

# 대칭형 다중 처리

1. <a title="Ferry24.Milan, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:SMP_-_Symmetric_Multiprocessor_System.svg"><img width="512" alt="SMP - Symmetric Multiprocessor System" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/SMP_-_Symmetric_Multiprocessor_System.svg/512px-SMP_-_Symmetric_Multiprocessor_System.svg.png"></a>

2. 대칭형 다중 처리(Symmetric MultiProcessing, SMP)는 두 개 또는 그 이상의 프로세서가 한 개의 공유된 메모리를 사용하는 다중 프로세서 컴퓨터 아키텍처이다.

3. 현재 사용되는 대부분의 다중 프로세서 시스템은 SMP 아키텍처를 따르고 있다.

4. SMP 시스템은 작업을 위한 데이터가 메모리의 어느 위치에 있는지 상관없이 작업할 수 있도록 프로세서에게 허용한다.

5. 운영체제의 지원이 있다면, SMP 시스템은 부하의 효율적 분배를 위해 프로세서간 작업 스케줄링을 쉽게 조절할 수 있다.

6. 그러나 메모리는 프로세서보다 느리다

7. 단일 프로세서라도 메모리부터 읽는 작업에 상당한 시간을 소비한다.

8. SMP는 이를 더욱 악화시키는데, 한 번에 한 개의 프로세서만이 동일한 메모리에 접근 가능하기 때문이다.

9. 이는 다른 프로세서들을 대기하도록 만든다.

10. SMP는 운영체제와 메모리를 공유하는 여러 프로세서가 프로그램을 수행하는 것을 말한다.

11. SMP에서는 프로세서가 메모리와 입출력 버스 및 데이터 경로를 공유하며, 또한 하나의 운영체제가 모든 프로세서를 관리한다.

12. 보통 2개부터 32개의 프로세서로 이루어지며, 어떤 시스템은 64개까지 프로세서를 공유한다.

13. SMP 시스템은 보통 MPP 시스템에 비하여 병렬 프로그래밍이 훨씬 쉽고, 프로세서간 작업 분산(Workload Balance)을 시키기가 훨씬 용이하지만, 확장성은 MPP에 비하여 취약하다.

14. 또한 많은 사용자가 동시에 데이터베이스에 접근하여 일을 처리하는 OLTP 작업에서도 강점을 보인다.

# 리눅스 커널 인터페이스

1. 리눅스 커널은 설계에 따라 다양한 목적들과 다양한 속성들에 사용되는 사용자 공간 애플리케이션에 여러 인터페이스들을 제공한다.

2. 리눅스 커널에는 두 종류의 API가 존재하는데 "커널 사용자 공간" API와 "커널 내부" API가 그것이다.

3. ![image](https://user-images.githubusercontent.com/78199659/139612940-b0189c20-f647-42db-91ca-0e61ea566f13.png)

4. 리눅스 API는 커널 사용자 공간 API로서, 사용자 공간에서 프로그램들이 리눅스 커널의 시스템 자원들과 서비스들에 접근할 수 있게 한다.

5. 이것은 리눅스 커널의 시스템 호출 인터페이스와 GNU C 라이브러리(glibc)에 있는 서브루틴들로 이루어진다.

6. 리눅스 API의 개발의 초점은 POSIX에서 정의된 명세들의 사용 가능한 특징들(POSIX에서 정의되지 않은 추가적인 특징들을 구현하는 커널 사용자 공간 API처럼 합리적으로 호환되고 탄탄하며 기준에 맞는)을 제공하는 것이었다.

7. 리눅스 API는 원한다면 몇 십년 동안 안정적이고 고장나지 않은 채로 유지된다.

8. 이 안전성은 소스 코드의 이식 가능함을 보장한다.

9. 시스템 호출 인터페이스는 커널에서 모든 구현과 사용 가능한 모든 시스템 호출 전체를 위한 명칭이다.

10. 다양한 서브시스템들은 자신의 시스템 호출을 정의하며 전체는 시스템 호출 인터페이스라고 불린다.

11. 리눅스 API라는 용어는 커널 사용자 공간 ABI와 관련이 있다.

12. 기계어에서 응용 프로그램 이진 인터페이스는 컴파일된 바이너리와 관련있다.

13. 이러한 ABI 어느 것이라도 명령어 집합과 관련된다. ?

14. 유용한 ABI를 정의하고 안정적으로 유지하는 것은 리눅스 커널 개발자들이나 GNU C 라이브러리의 개발자들의 책임이 아니라, 리눅스 배포자들과 독립적인 소프트웨어 벤더들의 책임이다.

15. ABI는 모든 명령어 집합을 위해 정의되며, 이것으로는 x86, ..., ARMv8-A 등이 있다.

16. 리눅스 ABI는 반드시 소프트웨어를 다른 컴파일러와 컴파일할 수 있어야 한다.

17. 자유-오픈 소스 소프트웨어인 컴파일러들로는 GNU 컴팡일러 모음과 LLVM/클랭이 있다.

# LLVM

1. LLVM(이전이름 : Low Level Virtual Machine)은 컴파일러의 기반구조이다.

2. 프로그램을 컴파일 타임, 링크 타임, 런타임 상황에서 프로그램의 작성 언어에 상관없이 최적화를 쉽게 구현할 수 있도록 구성되어 있다.

3. LLVM은 원래는 저급 가상 기계(Low Level Virtual Machine)의 약자를 가리켰지만, LLVM이 성장하고 다양한 목적을 가지게 되면서 현재는 그 이름을 약자로서 사용하는 것이 아니라 그냥 프로젝트의 이름으로서 사용하고 있다.

4. LLVM으로 언어에 가상 기계를 생성, 가상기계가 언어에 독립적인 최적화를 실행한다.

5. LLVM은 언어와 구조로부터 독립적이며, 언어 모듈과 시스템을 위한 코드 생성 부의 사이에 위치한다.

6. LLVM은 컴파일 과정 동안 최적화와 함께 JIT를 정적 컴파일러로 사용, 개발의 각종 단계에서 사용할 수 있는 많은 부분을 가지고 있다.

7. LLVM은 전통적인 GCC 시스템에서 그랬듯이 코드를 정적으로 컴파일할 수도 있고, Java 처럼 JIT를 이용하여 기계어로 한 번 더 컴파일되는 중간 형식으로 코드를 컴파일할 수도 있다.

8. 이 말은 자바처럼 플랫폼에 독립적이란 뜻은 아니다.

9. JIT 컴파일러의 경우 런타임에 불필요한 정적 분기를 최적화하는 기능이 있는데, 이 기능은 다양한 런타임 옵션을 제공하면서 특정 환경에서는 사용되지 않는 옵션을 쉽게 식별할 수 있는 프로그램의 경우에 부분 평가(Partial Evaluation)를 하는데 유용하다.

# 이식 가능 운영 체제 인터페이스

1. 이식 가능 운영 체제 인터페이스(Portable Operating System Interface, POSIX)는 서로 다른 UNIX OS의 공통 API를 정리하며 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격이다.

2. POSIX의 마지막 글자 X는 유닉스 호환 운영체제에서 보통 X가 붙는 것에서 유래한다.

3. 규격의 내용은 커널로의 C 언어 인터페이스인 시스템 콜 뿐 아니라, 프로세스 환경, 파일과 디렉토리, 시스템 데이터베이스(암호 파일 등), tar 압축 포맷 등 다양한 분야를 아우른다.

# GNU C 라이브러리

1. GNU C 라이브러리는 일반적으로 glibc로 알려진, GNU 프로젝트가 C 표준 라이브러리를 구현한 것이다.

2. 이름과는 달리 현재는 C++도 지원한다.

3. glibc는 단일 유닉스 규격과 POSIX(1c, 1d, 1j)가 요구하는 기능들을 제공하며, ISO C11, ISO C99, 버클리 유닉스(BSD) 인터페이스 등에서 요구하는 몇몇 기능들도 제공한다.

4. glibc는 수 많은 여러 커널들과 여러 하드웨어 아키텍처에서 돌아간다.

5. 그러나 가장 흔한 사용은 x86 하드웨어 상의 리눅스 커널에서의 사용이다.

6. 공식적으로 지원되는 하드웨어는 ARM 아키텍처, 알파 프로세서, ... , 그리고 x86이다. 이것은 Hurd와 리눅스 커널을 지원한다.

7. 안드로이드와 윈도우 같이 다른 시스템을 위해 쓰여진 프로그램들을 시스템이 제공하는 glibc 인터페이스에서 돌아가게 하는 호환성 계층이 존재한다.

8. 와인도 Win32 API/ABI에서 glibc로의 호환성 계층으로 여겨진다.

9. ![image](https://user-images.githubusercontent.com/78199659/139614668-a14e5f9f-2691-437f-8e30-5f96a540a524.png

10. ![image](https://user-images.githubusercontent.com/78199659/139614676-48062f40-ecd7-4d32-ae4c-ebb631b869af.png)

11. ![image](https://user-images.githubusercontent.com/78199659/139614693-560cba40-8234-4705-8023-8d17e866c46d.png)

# 호환성 계층

1. 호환성 계층은 네이티브가 아닌 구성 요소의 지원을 허용하는 구성 요소를 일컫는 용어이다.

2. 소프트웨어 공학에서 호환성 계층은 외래의 시스템이 호스트 시스템에서 돌아가게 하기 위해 이진을 허용한다.

3. 외래의 시스템의 시스템 콜을 호스트 시스템의 네이티브 시스템 콜로 번역해 준다.

4. 외래 시스템을 위한 몇몇의 라이브러리와 함께 호스트 시스템에서도 외래 이진 프로그램을 충분히 실행할 수 있다.

```

EX

1. BSD 위의 리눅스 호환성 계층

2. 와인 - 프로그램 로더와 윈도 API를 사용하여 마이크로소프트 윈도우 이진 파일을 유닉스 계열 시스템에서 실행할 수 있음

3. 윈도우 XP의 호환성 계층 - 윈도우 98 및 MS-DOS 응용 프로그램을 더 잘 실행할 수 있게 도와준다.

```

5. 하드웨어 호환 계층은 하드웨어 에뮬레이션을 허용하는 도구를 포함하고 있다.

6. 또한, 이 용어는 테이프 재생기의 경우 테이프 어댑터로 일컫기도 한다.

7. 다른 하드웨어 호환 계층들은 외부 상자(breakout box)를 포함하는데, 외부 상자는 비호환 컴퓨터의 특정한 컴퓨터 버스의 호환성을 제공한다.

# 윈도우 API

1. 윈도우 API(Windows API, Win API)는 마이크로소프트 윈도우 운영 체제들이 사용하는 API이다. 

2. C/C++ 프로그램에서 직접 운영 체제와 상호 작용할 수 있도록 만들어졌으며, 그보다 더 낮은 수준의 제어는 Ntdll.dll을 사용한 낮은 수준의 DLL로 가능하다.

# 응용 프로그램 이진 인터페이스

1. 응용 프로그램 이진 인터페이스(Application Binary Interface, ABI)는 응용 프로그램과 운영 체제 또는 응용 프로그램과 해당 라이브러리, 마지막으로 응용 프로그램의 구성 요소 간에 사용되는 낮은 수준의 인터페이스이다.

2. ABI는 API와 다르다, API가 소스 코드에서 사용된다면 ABI는 바이너리에서 호환이 가능하다는 점이다.

3. 임베디드 응용 프로그램 이진 인터페이스(Embedded-Application Binary Interface, EABI)는 임베디드 소프트웨어 프로그램을 수행하는 파일 형식, 자료형, 레지스터 사용, 스택 프레임 조직, 명령 변수를 위한 표준 변환을 정의하고 있다.

4. EABI를 지원하는 컴파일러는 이와 같은 또다른 컴파일러가 만든 코드와 호환되는 목적 코드를 만드므로 개발자들이 다른 컴파일러가 만들어 낸 목적코드와 한 컴파일러로 만든 라이브러리를 연결할 수 있게 한다.

5. 자체적인 어셈블리어 코드를 작성하는 개발자들은 EABI를 사용하여 호환 컴파일러가 만들어낸 어셈블리 코드와 상호 작용하게 할 수 있다.

6. 일반 목적의 운영 체제에서 ABI와 EABI의 주된 차이점은 권한 명령이 응용 프로그램 코드 내에서 실행되는 점, 동적 링크가 요구되지 않는다는 점(심지어는 아예 동적 링크를 허용하지 않는 경우도 있음), 

7. 메모리 저장을 위해 더 작아진 스택 프레임 조직을 갖춘다는 점이 있다.

8. 널리 쓰이는 EABI로는 파워피씨와 ARM 아키텍처가 있다.


# 적재 가능 커널 모듈

1. 적재 가능 커널 모듈(Loadable Kernel Mode, LKM)은 운영 체제에서 실행 중인 커널을 확장하는 코드를 포함하는 목적 파일이다.

2. LKM은 일반적으로 새로운 하드웨어(장치 드라이버)나 파일시스템을 위한 지원 또는 시스템 호출을 추가하는데 사용한다.

3. LKM에 의해 제공되는 기능이 더 이상 요구되지 않으면 메모리와 자원을 할당 해제하기 위해 언로드 시킬 수 있다.

4. 대부분의 유닉스 계열 시스템과 윈도우(커널-모드 드라이버)는 적재 가능 커널 모듈을 지원한다.

# 컴퓨터 하드웨어

1. 컴퓨터 하드웨어는 케이스, 중앙 처리 장치(CPU), 모니터, 자판, 컴퓨터 기억장치, 그래픽 카드, 사운드 카드, 메인보드와 같은 컴퓨터의 물리적 부품을 의미한다.

2. 입력, 연산, 제어, 기억, 출력 등 다섯 가지 기능을 구현하며 이를 위해 컴퓨터는 여러 가지 부품들로 구성되어 있다.

3. 이와 반대가 되는 용어는 소프트웨어이며 이는 특정 작업을 수행하기 위해 하드웨어에 의해 저장되고 실행되는 명령어를 의미한다.

# 컴퓨터 소프트웨어

1. 컴퓨터 소프트웨어는 저장장치에 저장된 특정한 목적의 하나 또는 다수의 컴퓨터 프로그램을 뜻한다.

2. 프로그램 소프트웨어는 컴퓨터 하드웨어에 직접 명령어를 주거나 다른 소프트웨어에 입력을 제공함으로써, 그것을 수행하도록 구현된 기능을 수행한다.

# 펌웨어

1. 펌웨어(firmware)는 컴퓨팅과 공학 분야에서 특정 하드웨어 장치에 포함된 소프트웨어로, 소프트웨어를 읽어 실행하거나, 수정하는 것도 가능한 장치를 뜻한다.

2. 하드웨어의 제어와 구동을 담당하는 일종의 운영체제다.

3. 펌웨어는 ROM이나 PROM에 저장되며, 하드웨어보다는 교환하기가 쉽지만, 소프트웨어보다는 어렵다.

4. EX) PC에서 흔히 볼 수 있는 바이오스, 냉장고, 전기밥솥

5. 현대의 시스템에 들어가는 대부분의 장치들은 저들만의 소프트웨어를 실행하는 특수 목적의 컴퓨터들이다.

6. 이 장치들 가운데 일부는 장치 안에 있는 ROM 안에 소프트웨어(펌웨어)를 저장한다.

7. 그러나, 여러 해에 걸쳐 제조업체들은 호스트 시스템에서 펌웨어를 불러내는 것이 값이 싸면서도 유연성이 있다는 사실을 알아 냈다.

8. 그 결과, 현재의 많은 하드웨어는 호스트 컴퓨터가 필요한 펌웨어가 채워질 때까지 어떠한 방법으로도 기능을 할 수 없다.

9. 이러한 펌웨어 로드는 장치 드라이버에서 구현된다.

10. 많은 장치들의 펌웨어는 추가 하드웨어를 설치하지 않고, 보통 판매업체가 제공하는 소프트웨어를 통해 업데이트 할 수 있다.

# 장치 드라이버

1. 장치 드라이버/제어기 또는 디바이스 드라이버는 특정 하드웨어나 장치를 제어하기 위한 커널의 일부분으로 동작하는 프로그램이다.

2. 컴퓨터를 구성하는 다양한 입출력 장치마다 각각 장치드라이버가 프로그램 되어 커널에 통합되어 실행된다.

3. 높은 수준의 컴퓨터 프로그램들이 컴퓨터 하드웨어 장치와 상호 작용하기 위해 만들어진 하나의 컴퓨터 프로그램이다.

4. 장치 드라이버는 커널의 일부분이기는 하나 커널과 통합되는 것은 처음부터 해당 드라이버 프로그램 코드 소스가 커널 전체 소스에 포함되어 컴파일되는 경우도 있고,

5. 그리고 별도로 컴파일된 파일의 형태로 존재하고 부팅 시 또는 필요 시 해당 파일이 로드되어 커널과 통합되기도 한다.

6. 드라이버는 흔히 컴퓨터 버스, 또는 하드웨어와 이어진 통신 하위 시스템을 통해 장치와 통신한다.

7. 요청하는 프로그램이 드라이버의 명령어를 호출하면, 드라이버는 장치에 명령어를 전달한다.

8. 장치가 드라이버에게 데이터를 되돌려주면, 드라이버는 원래 요청한 프로그램의 명령어로 데이터를 다시 전달한다.

9. 프로그램 <=> 드라이버 <=> 장치

10. 드라이버는 하드웨어에 의존하며 특정한 운영 체제를 따른다.

11. 이러한 드라이버는 비동기 시간에 의존하는 하드웨어 인터페이스에 필요한 인터럽트를 다룰 수 있다.

12. 장치 드라이버는 흔히 장치 칩의 레지스터에 접근하여 하드웨어를 제어하며 하드웨어와 주변 기기를 사용하는 프로그램의 중간 다리 역할을 한다.

13. 커널은 부팅 시에 시작되어 컴퓨터 종료시 커널이 끝난다.

14. 장치 드라이버는 하드웨어와 밀접하게 연관되고 해당 장치를 제어하는 프로그램이다.

15. 커널 공간에서 이루어지는 작업으로는 입출력, 네트워크 등의 하드웨어 제어, 메모리와 같은 컴퓨터의 리소스 관리, 응용 프로그램의 실행 제어 등이 있다.

16. 커널과는 달리 응용 프로그램은 사용자 요청에 의해 저장장치로부터 메모리에 로드되어 실행한다.

17. 응용 프로그램이 하드웨어를 직접 제어할 수는 없기 때문에, 커널의 장치 드라이버를 사용하기 위해 시스템 호출 방법으로 커널에 접근하여 자료를 처리한다.

18. 전자 제품에서 각각의 주변 기기들을 제어하기 위해 설계된 펌웨어 또한 장치 드라이버로 분류된다.
 
# 컴퓨터 버스

1. 컴퓨터 버스는 컴퓨터 안의 부품들 간에, 또는 컴퓨터 간에 데이터와 정보를 전송하는 통로(통신 시스템)이다.

2. 이러한 표현에는 관련된 모든 하드웨어 부품들(선, 광 파이버 등) 및 통신 프로토콜을 포함한 소프트웨어를 아우른다.

3. 병렬 전기적 버스와 동일한 논리적 기능을 제공하는 물리적인 배치에 사용된다.

4. 현대의 컴퓨터 버스들은 병렬 및 비트 시리얼 연결을 둘 다 지원하며, 이들 모두 멀티드롭(전기적 병렬) 또는 데이지 체인 토폴로지로 선을 구성하거나 USB처럼 스위치 허브에 의해 연결할 수도 있다.

5. 입출력 장치와 연결된 통로는 입출력 버스(I/O Bus), 메모리와 다른 장치를 이루어지는 통로는 메모리 버스(Memory Bus)라고 한다.

# 시스템 호출

1. 시스템 호출 또는 시스템 콜(System Call)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스다.

2. 보통 C나 C++같은 고급 언어로 작성된 프로그램들은 직접 시스템 호출을 사용할 수 없기 때문에 고급 API를 통해 시스템 호출에 접근하게 하는 방법이다.

3. 운영 체제의 구성상, 커널과 응용 프로그램은 CPU의 권한 수준(privilege levels)이나 하드웨어 접근 능력이 다르다.

4. 커널은 CPU 시스템의 RAM/FLASH 등에 물리주소가 일치하는 링커구조를 가지고 특정 메모리 위치에서 동작한다.

5. 이때 커널의 기계어 코드에서 사용하는 모든 주소는 물리 주소로 고정되어 컴파일되고 로드되어 실행된다.

6. 따라서 커널은 부팅과정에서 전체 메모리 리소스 중에 일정하게 점유하여 동작하고 인터럽트 등 모든 하드웨어 접근이 가능하다.

7. 그러나 응용 프로그램은 커널이 제공하는 자원을 사용하므로 메모리에서 상황에 따라 다른 위치를 점유하고 실행된다.

8. 응용 프로그램은 사용자 요청에 따라 실행되는 프로그램이므로 물리 주소를 확정할 수 없다.

9. 따라서 응용 프로그램이 작성되면 메모리 위치가 처음부터 로드된다고 생각하고 개발도구에 링크된다.

10. 보통 MMU을 통해 논리 주소를 물리 주소로 변환한다 

11. 그리고 응용 프로그램은 CPU의 권한 수준이 사용자 공간(user space)에서 동작하며 특정한 기계어 명령 실행이 불가능하다.

12. 이와 같은 상황에서 응용 프로그램이 파일 시스템을 사용하는 등 기타 여러 상황에서 커널에 의존해야만 한다.

13. 응용 프로그램에서 커널의 서비스를 이용하는 방법이 시스템 호출이다.

14. 커널의 인터럽트 처리 등의 과정을 프로그램하려면 어셈블리어와 C와의 혼용구조로 구성된다.

15. 시스템 호출의 세 가지 기능

```

1. 사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다.

2. 시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다.

3. 커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다.

```

16. 시스템 호출의 유형 

```

1. 프로세스 제어 (Process Control)

2. 파일 조작 (File Manipulation)

3. 장치 관리 (Device Management)

4. 정보 유지 (Information mainenance)

5. 통신 (Communication)

```

# 링커

1. 링커(Linker) 또는 링크 에디터(Link Editor)는 컴퓨터 과학에서 컴파일러가 만들어낸 하나 이상의 목적 파일을 가져와 이를 단일 실행 프로그램으로 병합하는 프로그램이다.

2. 유닉스 계열 운영 체제에서 로더를 링커의 동의어로 사용되기도 한다. 이 밖에 다른 용어들도 사용되었다.

3. 이를테면 SINTRAN III 에서는 링커가 수행한 프로세스를 로딩(Loading -> 실행 코드를 파일로 로드)이라 하였다.

4. 이러한 용도가 컴파일 타임 프로세스와 실행 시간 프로세스의 구별을 모호하게 만들었기 때문에, 이 문서는 전자적인 의미로는 링크(Linking)로, 후자의 의미로는 로드(Loading)로 언급할 것이다.

5. 컴퓨터 프로그램들은 일반적으로 여러 부분의 모듈로 이루어진다.

6. 이 모든 부분/모듈들은 하나의 목적 파일 안에 포함될 필요는 없으며, 이런 경우 기호(Symbol)를 다른 모듈 안의 주소로 이용해서 서로 참조한다.

7. 그리고 이 기호는 실행을 위해 링크 될 때 메모리 주소로 맵핑된다. 일반적으로 모든 목적 파일은 3가지 종류의 기호를 포함할 수 있다.

```

1. 정의된 '외부' 기호, 혹은 '공개' 또는 '진입' 기호 - 다른 모듈이 호출하는 것을 허용한다.

2. 정의되지 않은 '외부' 기호 - 이 기호가 정의된 다른 모듈을 참조한다.

3. 지역 기호 - 재배치를 위해 목적 파일 안에서 내부적으로 사용한다.

```

8. 대부분의 컴파일러에서, 각각의 목적 파일은 하나의 입력 소스 코드 파일의 컴파일 결과이다.

9. 한 프로그램이 여러 개의 목적 파일로 구성될 때, 링커는 이 파일들을 하나의 통합된 실행 가능한 프로그램으로 합치고 이때 생겨나는 기호들을 해결한다(Resolve)

10. 링커는 라이브러리 또는 런타임 라이브러리라고 하는 모음에서 오브젝트들을 취할 수 있다.

11. 대부분의 링커들은 전체 라이브러리를 출력 파일에 포함시키지 않는다.

12. 대신, 다른 오브젝트 파일 혹은 라이브러리가 참조하는 파일들만을 포함한다.

13. 그래서 라이브러리 링킹은 반복적인 과정일 수 있는데, 어떤 참조된 모듈이 다른 추가적인 모듈을 필요로 하는 등의 경우가 있기 때문이다.

14. 라이브러리는 다양한 목적으로 존재하는데, 하나 이상의 시스템 라이브러리는 보통 자동으로 링크된다.

15. 링커는 또한 프로그램의 주소 공간 안의 오브젝트들을 배열하는 일도 책임진다.

16. 이 일은 코드를 재배치할 수도 있는데, 이 과정에서 특정한 베이스 주소를 다른 베이스로 가정한다.

17. 컴파일러는 어떤 오브젝트가 어디에 배치될지 거의 모르기 때문에, 보통 0과 같은 고정된 베이스 주소를 가정한다.

18. 기계 코드를 재배치하는 일은 절대 주소로 점프하는 코드(jump)와 로드(load), 스토어(store)의 목적 주소를 바꾸기도 한다.

19. 링커가 만드는 최종 실행 파일은 (실행 직전에) 메모리에 최종적으로 올라가기 전에 또 다른 재배치 과정을 필요로 하기도 한다.

20. 이 과정은 보통 가상 메모리를 지원하는 하드웨어에서는 생략된다.

21. 모든 프로그램이 그들만의 주소 공간에 배치되고 따라서 모든 프로그램이 같은 베이스 주소를 로드해도 충돌이 나지 않기 때문이다.

1. 링크 과정을 간단히 나타낸 그림. 목적 파일 + 정적 라이브러리 => 새로운 라이브러리 or 실행 파일로 병합

2. ![image](https://user-images.githubusercontent.com/78199659/138401326-eaa95bba-94b9-4d26-80cf-539b800ec093.png)

# 동적 링크

1. 수많은 운영 체제 환경은 동적 링크를 허용하며 프로그램이 실행될 때까지 정의되지 않은 일부 기호들을 해결하는 일을 나중으로 미룬다.

2. 다시 말해, 실행 코드에는 정의된 기호, 또 이들의 정의들을 제공하는 오브젝트나 라이브러리의 목록이 여전히 포함되어 있다.

3. 프로그램을 로드하면 이러한 오브젝트나 라이브러리도 로드할 것이며 마지막 링크를 수행한다.

4. 동적 링크는 링커가 필요 없다.

5. 이러한 접근에는 두 가지 이점이 있다.

```

자주 쓰이는 라이브러리(이를테면 표준 라이브러리 시스템)는 한 위치에만 저장되어 있으며 여러 단일 라이브러리로 중복될 필요는 없다.

라이브러리 함수의 오류가 라이브러리 파일의 교체로 수정된다면 모든 프로그램은 다시 시작할 때 동적으로 이러한 수정에 영향을 받을 수 있다.

```

6. 단점은 다음과 같다.

```

윈도 플랫폼에서 비호환 업데이트 DLL로 불리는 DLL 지옥이 이전 DLL의 행위에 의존했던 실행 파일의 실행을 저지할 수 있다.

라이브러리를 함께 사용하는 프로그램과 라이브러리 모두 검증이 필요할 수 있다. 

```

# 컴파일러

1. 컴파일러(Compiler)는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말한다.

2. 컴파일러는 High-Level Programming Language를 실행 프로그램으로 만들기 위한 Lower Level Language(예, 어셈블리 언어, Object 코드, Machine Code)로 바꾸는 데 사용된다.

3. 원래의 문서를 소스 코드 혹은 원시 코드라고 부르고, 출력된 문서를 목적 코드라고 부른다.

4. 목적 코드는 주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만 사람이 읽을 수 있는 문서 파일이나 그림 파일 등으로 옮기는 경우도 있다.

5. 원시 코드에서 목적 코드로 옮기는 과정을 컴파일(Compile)이라고 한다.

6. 컴파일러는 소스 프로그램을 읽어서 즉시 결과를 출력하는 인터프리터와는 구분된다.

7. 그러나 현대에 들어 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하므로, 컴파일러와 인터프리터 사이의 기술적 구분은 사라져 가는 추세이다.

8. 소스 코드를 컴파일하는 이유는 대부분 사람에게 이해하기 쉬운 형태의 고수준 언어로부터 실행가능한 기계어 프로그램을 만들기 위해서이다.

9. 좁은 의미의 컴파일러는 주로 고수준 언어로 쓰인 소스 코드를 저수준 언어(어셈블리어, 기계어)로 번역하는 프로그램을 가리킨다.

10. 컴파일러의 주요 기능

```

1. 고급언어를 직접 기계어 코드로 변환한다.

2. 자바의 경우 바이트 코드로 변환한다. 중간단계의 코드를 생성하고 이것을 해석해서 실행한다.

```

11. 바이트 코드 변환

```

장점은 한번 컴파일된 바이트 코드는 다른 플랫폼에서 재컴파일없이 실행할 수 있다.

그러나 단점은 바이트 코드를 해석해서 실행할 프로그램 구조가 필요하고, 직접 기계어 코드를 실행하는 것 보다 속도에서 늦다.

```

12. 컴파일러의 실행 단계 

```

구문 분석 : 소스 코드 파일을 읽어 개별 문법요소(연산자, 괄호, 식별자 등) 단위로 자른후, 이 문법요소들을 해석하여 추상 구문 트리를 생성한다.

이 과정에서 문법에 맞지 않는 소스 코드는 사용자에게 알려준다.

최적화 : 추상 구문 트리를 분석하여 최적화를 수행한다. 도달할 수 없는 코드를 식별하거나, 상수 표현식을 미리 계산해 두거나, 루프 풀기 등의 대부분의 최적화가 이 단계에서 수행된다.

코드 생성 : 최적화된 구문 트리로부터 목적 코드를 생성한다. 목표 언어가 기계어일 경우, 레지스터 할당, 연산 순서 바꾸기 등 하드웨어에 맞는 최적화가 이 단계에서 수행된다.

대부분의 하드웨어 최적화 알고리즘은 NP 복잡도를 갖지만, 휴리스틱을 통해 많은 최적화가 수행된다.

링킹 : 목적 코드가 기계어일 경우, 여러 라이브러리 목적 코드를 묶어 하나의 실행 파일을 생성하게 된다.

이 과정은 링커에 의해 수행되며, 어떤 사람들은 링커를 컴파일러의 일부로 간주하지 않기도 한다.


```

13. 컴파일러는 입출력되는 언어의 종류, 내부구조, 목적 코드의 동작에 따라 여러 가지로 분류할 수 있다.

14. 컴파일러가 실행되는 컴퓨터나 운영체제가 컴파일러의 목적 코드가 실행될 컴퓨터나 운영 체제와 같은 경우 네이티브 컴파일러(Native Compiler or Hosted Compiler)라고 한다. 

```

마이크로소프트 윈도우용 응용 프로그램을 개발하기 위해 비주얼 스튜디오로 컴파일하면 실행파일(exe 파일) 생성한다.

```

15. 반면에 크로스 컴파일러(Cross Compiler)는 다른 컴퓨터나 운영 체제에서 실행되도록 제작된다. 임베디드 시스템 등 소프트웨어 개발에 충분한 환경을 갖추지 못한 환경에서 동작할 프로그램을 만들기 위해 사용된다.

```

마이크로소프트 윈도우에서 8051, AVR, PIC 등의 시스템 프로그램을 개발하기 위해 해당 컴파일러를 사용하면 해당 CPU의 코드가 생성된다.

```

16. 또한 가상 머신에서 동작할 프로그램을 만드는 컴파일러도 있다. (EX. 자바) 이 경우 일반적으로 출력물이 가상 머신을 위해 제작된 바이트코드 형태의 기계어가 되므로 바이트코드 컴파일러라고 부른다.

17. 일단 구조와 다단 구조

```

소스를 한 번 읽고 번역하여 바로 출력물을 내놓는 컴파일러도 있지만 여러 가지 목적을 위해 중간 결과를 만들어 그 결과를 다시 최종 결과로 출력하는 컴파일러도 있다.

중간 결과를 만드는 데는 여러 가지 이유가 있다.

다양한 언어 지원 : 다양한 입력 언어를 동일한 중간 표현으로 표현하거나 동일한 중간 표현을 여러 가지 출력 언어로 표현하면 다양한 입력 언어와 출력 언어를 지원하는 컴파일러를 작성할 수 있다.

속도 및 최적화 : 고수준 언어일수록 최적화된 성능보다는 사람에게 이해하기 쉬운 형태를 염두에 두고 설계된다.

때문에 중간 형태를 거치는 것이 보다 저수준에서 효율적으로 프로그램을 최적화한 다음 최종적으로 출력물을 내놓는 데 유리할 수 있다.

저스트 인 타임 컴파일(JIT 컴파일) : 스몰토크, 자바, 마이크로소프트 중간 언어(CIL) 등의 컴파일러는 가상 머신의 바이트코드를 출력한다.

그러나 가상 머신은 플랫폼의 기계어에 비해 속도가 느릴 수밖에 없으므로 이들 가상 머신에는 저스트 인 타임 컴파일러가 탑재되어 실행 직전에 현재 플랫폼의 기계어로 다시 한 번 컴파일되어 속도를 향상시킨다.

```

# JIT 컴파일

1. JIT 컴파일(Just-In-Time Compliation) 또는 동적 번역(Dynamic Translation)은 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법이다.

2. 전통적인 입장에서 컴퓨터 프로그램을 만드는 방법은 두 가지가 있는데, 인터프리터 방식과 정적 컴파일 방식으로 나눌 수 있다.

3. 이 중 인터프리터 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다.

4. JIT 컴파일러는 두 가지의 방식을 혼합한 방식으로 생각할 수 있는데, 실행 시점에서 인터프리터 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.

5. 최근의 자바 가상 머신과 .NET, V8(node.js)에서는 JIT 컴파일을 지원한다. 즉, 자바 컴파일러가 자바 프로그램 코드를 바이트코드로 변환한 다음,

6. 실제 실행하는 시점에서 자바 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환한다.

7. 바이트코드 컴파일러는 소스 코드를 중간언어인 바이트코드로 변환한다.

8. 바이트코드는 기계어는 아니지만 가상 머신에 의해 기계어로 손쉽게 변환할 수 있는 코드이다.

9. JIT 컴파일러는 바이트코드를 읽어 빠른 속도로 기계어를 생성할 수 있다.

10. 이런 기계어 변환은 코드가 실행되는 과정에 실시간으로 일어나며(Just-In-Time), 전체 코드의 필요한 부분만 변환한다.

11. 기계어로 변환된 코드는 캐시에 저장되기 때문에 재사용시 컴파일을 다시 할 필요가 없다.

12. 일반적인 인터프리터 언어(cpython)는 바이트코드나 소스코드를 최적화 과정이 없이 번역하기 때문에 성능이 낮다.

13. 반면 정적으로 컴파일 하는 언어(C)는 실행 전에 무조건 컴파일을 해야하기 때문에 다양한 플랫폼에 맞게 컴파일을 하려면 시간이 오래 걸린다.

14. 동적 컴파일 환경은 실행 과정에서 컴파일을 할 수 있기 위해 만들어졌다.

15. JIT는 정적 컴파일러 만큼 빠르면서 인터프리터 언어의 빠른 응답속도를 추구하기 위해 사용한다.

16. 바이트코드 컴파일러가 시간이 많이 소요되는 최적화를 미리 해주기 때문에 바이트코드에서 기계어 번역은 훨씬 빠르게 진행될 수 있다.

17. 또한 바이트코드는 이식성이 뛰어나 가상 머신이 설치되어 있으면 빠르게 실행할 수 있다.

18. 플랫폼 별로 가상 머신을 개발하는 과정은 컴파일러를 만드는 것보다 간단한데, 그 이유는

```

1. 복잡한 최적화 과정은 바이트코드 컴파일러가 대신 해주므로 고려하지 않아도 된다.

2. 바이트코드는 빠른 기계어 변환을 목적으로 설계되었기 때문에 일반적인 컴파일러보다 제작 과정이 수월하다.

```

19. JIT 코드는 일반적인 인터프리터 언어에 비해 훨씬 좋은 성능을 낸다.

20. 심지어 경우에 따라 정적 컴파일러 언어보다 좋은 성능을 내곤 하는데, 이는 실행 과정에 컴파일을 할 수 있기 때문에 가지는 장점이라고 할 수 있다.

```

1. 컴파일이 CPU나 운영체제에 따라 다르게 진행될 수 있다. 예를 들어 CPU가 SSE2 Vector Instruction을 지원한다면 CPU는 이를 활용하는 방법으로 최적화를 진행한다.

2. 정적 컴파일러 언어로 Garbage Collection을 지원하게 만들 수 있지만, JIT 시스템을 이용하면 더 쉽게 GC를 사용할 수 있다.

```

# 추상 구문 트리


# 가상 머신

1. 가상 머신(Virtual Machine, VM)은 컴퓨팅 환경을 소프트웨어로 구현한 것, 즉 컴퓨터 시스템을 에뮬레이션(가상현실화)하는 소프트웨어다.

2. 가상 머신상에서 운영 체제나 응용 프로그램을 설치 및 실행할 수 있다.

3. 다른 기능들이 있는 여러 종류의 가상 머신들이 있다.

4. 시스템 가상 머신들은(또한 완전한 가상화 가상 머신들로 알려진) 실제 기계의 대체제를 제공하고 완전한 운영체계의 실행을 위해 요구되는 기능성의 수준을 제공한다.

5. 하이퍼 바이저는 하드웨어를 공유하고 관리하기 위해 네이티브 실행을 이용한다.

6. 그리고 하이퍼바이저는 독립된 다른 환경들을 같은 물리적인 기계에서 실행하기 위해서 허용한다.

7. 현대의 하이퍼바이저들은 하드웨어의 도움을 받는 가상화를 이용하는데,

8. 그것들은 주로 주 CPU들의 특정 하드웨어 기능을 사용하여 효과적이고 완전한 가상화를 제공한다.

9. 프로세스 가상머신들은 플랫폼에 독립적인 프로그램 실행 환경과 추상화를 제공하여 하나의 프로그램을 실행하도록 설계되었다.

10. 가상 머신은 실제 컴퓨터와 어느 정도의 통신과 사용을 기반으로 두 가지로 나뉜다.

11. 시스템 가상 머신은 완전한 시스템 플랫폼을 제공하며, 다시 말해 완전한 운영 체제의 실행을 지원한다.

12. 반대로, 프로세스 가상 머신은 하나의 단일 프로그램을 실행하기 위해 만들어져 있는데, 다시 말해 단일 프로세스를 지원한다.

13. 가상 머신의 중요한 특징은 안에서 돌아가는 소프트웨어가 가상 머신이 제공하는 환경과 자원에 제한을 받으며 가상 세계를 벗어날 수 없다는 점이다.

14. 시스템 가상 머신은 때로 하드웨어 가상 머신이라고 하며 각 운영 체제를 실행하는 가상 머신 사이의 기초가 되는 물리 컴퓨터를 다중화한다.

15. 가상화를 제공하는 소프트웨어 계층은 가상 머신 모니터 또는 하이퍼바이저라고 한다.

16. 하이퍼바이저는 순 그대로의 하드웨어 또는 호스트 운영 체제 위에서 실행할 수 있다.

17. 시스템 가상 머신의 주요 이점

```

여러 운영 체제를 쓰는 환경은 운영 체제가 완벽히 고립된 채로 같은 컴퓨터에서 존재할 수 있다.

가상 머신은 실제의 컴퓨터가 제공하는 것과 다른 형태의 명령어 집합 구조를 제공한다.

```

18. 저만의 운영 체제를 실행하는 여러 개의 가상 머신들을 게스트 운영 체제라고 하며, 다른 장치가 충돌을 피하기 위해 각 장치에서 실행하기 위한 서버 통합에서 쓰이며, 각 가상 머신에서는 같은 물리 컴퓨터에서 실행된다. ?

19. 이러한 사용을 제품 품질의 고립이라고 한다.

20. 여러 개의 운영 체제를 사용하려는 열망은 가상 머신의 원래 취지였으며, 여러 개의 단일 작업 운영 체제들 사이에서 시분할 단일 컴퓨터를 허용한다.

21. 게스트 운영 체제들은 모두 같을 필요는 없다.

22. 다시 말해, 같은 컴퓨터에서 다른 운영체제를 돌릴 수 있게 해 준다. (마이크로소프트 윈도우와 리눅스, 또는 최신 버전에서 지원하지 않는 소프트웨어를 지원하기 위해 옛날 버전의 운영 체제를 설치)

23. 다른 게스트 운영 체제를 지원하기 위해 가상 머신을 사용하는 것은 임베디드 시스템에서 인기를 끌고 있다.

24. 일반적으로 리눅스와 윈도와 같은 높은 수준의 운영 체제로서 실시간 운영 체제를 지원한다.

25. 다른 사용으로는 신뢰할 수 없는 운영 체제를 sandbox하는 것이다.

26. 왜냐하면 그 시스템이 개발 하위 시스템일 수도 있기 때문이다.

27. 가상 머신들은 더 나은 오류 수정의 접근과 더 빠른 다시 시동과 더불어 운영 체제 개발에 다른 이점들을 가져다 준다.

28. QoS 고립을 위한 가상 머신의 인기는 대부분의 동시대 운영 체제가 제공하는 완전하지 못한 자원 고립을 이끈다.

29. VM은 응용 프로그램 가상 머신이라고도 하며, 운영 체제 안에서 일반 응용 프로그램을 돌리고 단일 프로세스를 지원한다.

30. 프로세스가 시작하고, '끝내기'되어 파게될 때 만들어진다.

31. 목적은 아무 플랫폼에서나 같은 방식으로 실행하는 프로그램을 허용하고 기초가 되는 하드웨어나 운영 체제의 상세한 부분을 가져오는 독립 프로그래밍 환경을 제공하기 위함이다.

32. 가상 머신이라고 하는 프로세스는 고급 프로그래밍 언어에서 높은 수준의 추출을 제공한다.

33. 가상 머신 프로세스들은 해석기를 사용하여 추가된다.

34. 이러한 종류의 가상 머신은 자바 가상 머신을 사용하여 추가되는 자바와 더불어 인기를 끌었다.

35. 또다른 예로는, 닷넷 프레임워크가 있는데 공통 언어 런타임이라고 불리는 가상 머신을 실행한다.

36. 가상 머신 프로세스의 특별한 경우는 잠재적으로 균일하지 못한 컴퓨터 클러스터의 통신 구조를 넘어 추출하는 시스템들이다.

37. 그러한 가상 머신은 단일 프로세스로 이루어져 있지 않지만 클러스터에서 물리컴퓨터마다 하나의 프로세스를 이룬다.

38. 이것들은 병렬 응용 프로그램들을 프로그래밍하는 작업을 쉽게 하기 위해 만들어져 있다.

39. 이로써 프로그램이 운영체제와 상호 작용이 제공하는 통신 구조 보다 알고리즘에 집중할 수 있다.

40. 이것들은 통신이 일어난다는 사실을 숨기지 않고 단일 병렬 컴퓨터로 클러스터를 제공하지 않는다.



# 하이퍼바이저

1. 하이퍼바이저(Hypervisor)는 호스트 컴퓨터에서 다수의 운영 체제를 동시에 실행하기 위한 논리적 플랫폼을 말한다.

2. 가상화 머신 모니터 또는 가상화 머신 매니저(Virtual Machine Monitor 또는 Virtual Machine Manager, VMM)라고도 부른다.

3. 하이퍼바이저는 일반적으로 2가지로 나뉜다.

4. 타입 1(Native 또는 Bare-Metal)

5. 운영 체제가 프로그램을 제어하듯이 하이퍼바이저가 해당 하드웨어에서 직접 실행되며 게스트 운영 체제는 하드웨어 위에서 2번째 수준으로 실행된다.

6. EX) 마이크로소프트의 하이퍼-V

7. 타입 2(Hosted)

8. 하이퍼바이저는 일반 프로그램과 같이 호스트 운영 체제에서 실행되며 VM 내부에서 동작되는 게스트 운영 체제는 하드웨어에서 3번째 수준으로 실행된다.

9. EX) 마이크로소프트의 버추얼 PC와 버추얼 서버

10. ![image](https://user-images.githubusercontent.com/78199659/138630069-505a0324-c948-4024-93af-356d204f0b92.png)

11. 하이퍼바이저 콜(Hypervisor Call), 곧 하이퍼콜(Hypercall)이란 게스트 운영 체제가 (보다 높은 수준의) 제어 프로그램에서 직접 서비스에 접근할 수 있는 반가상화 인터페이스로 인용된다.

12. (같은 수준의) 운영 체제에서 감시자 호출(supervisor call)을 요청하는 것과 비슷하다.

13. 슈퍼바이저란 IBM 메인프레임에서 감시 프로그램 상태로 실행되는 운영 체제 커널을 말한다.




# 인터프리터

1. 인터프리터는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.

2. 원시 코드를 기계어로 번역하는 컴파일러와 대비된다.

3. 인터프리터는 다음의 과정 가운데 적어도 한 가지 기능을 가진 프로그램이다.

```

1. 소스 코드를 직접 실행한다.

2. 소스 코드를 효율적인 다른 중간 코드로 변환하고, 변환한 것을 바로 실행한다.

3. 인터프리터 시스템의 일부인 컴파일러가 만든, 미리 컴파일된 저장 코드의 실행을 호출한다.

```

4. 인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다.

5. 고급언어로 작성된 프로그램들을 실행하는 데에는 두 가지 방법이 있다.

6. 가장 일반적인 방법은 프로그램을 컴파일 하는 것이고, 다른 하나는 프로그램을 인터프리터에 통과시키는 방법이다.

7. 인터프리터는 고급 명령어들을 중간 형태로 번역한 다음, 그것을 실행한다.

8. 이와는 대조적으로, 컴파일러는 고급 명령어들을 직접 기계어로 번역한다.

9. 컴파일된 프로그램들은 일반적으로 인터프리터를 이용해 실행시키는 것보다 더 빠르게 실행된다.

10. 그러나 인터프리터의 장점은 기계어 명령어들이 만들어지는 컴파일 단계를 거칠 필요가 없다는데 있다.

11. 컴파일 과정은 만약 원시 프로그램의 크기가 크다면, 상당한 시간이 걸릴 수 있다.

12. 이와는 달리 인터프리터는 고급 프로그램을 즉시 실행시킬 수 있다.

# 목적 파일

1. 목적 코드(Object Code) 또는 목적 파일은 컴파일러나 어셈블러가 소스 코드 파일을 컴파일 또는 어셈블해서 생성하는 파일이다.

2. 목적 파일들은 기계어나 혹은 이에 준하는 RTL과 같은 이진 코드로 이루어져 있다.

3. 링커는 여러 개의 목적 파일을 묶어 커널과 연결함으로써 실행 파일을 만들거나, 혹은 라이브러리를 만들어내는 데에 쓰인다.

4. 목적 파일에서 필수적인 요소는 기계어(컴퓨터의 CPU가 직접 실행하는 코드)이다. 

5. 임베디드 시스템을 위한 목적 파일들은 기계어 이외에는 아무것도 포함하고 있지 않다.

# 명령 코드

1. 명령 코드(Operation Code <-> opcode)는 기계어의 일부이며 수행할 명령어를 나타내는 부호를 말한다. 

# 기계어

1. 기계어는 CPU가 직접 해독하고 실행할 수 있는 비트 단위로 쓰인 컴퓨터 언어를 통틀어 일컫는다.

2. 기계어는 프로그램을 나타내는 가장 낮은 단계의 개념이다.

3. 기계어는 어셈블리어와 1:1로 쓰일 수 있다.

4. 다시 말해 컴퓨터 프로그래밍에서 기계어는 대부분 어셈블리어를 거쳐 짜여지게 된다.

5. 어셈블리어가 아직 만들어지기 전에는 기계어를 직접 입력하여 프로그램을 작성하기도 했다.

# 어셈블리어

1. 어셈블리어(Assembly Language)또는 어셈블러 언어(Assembler Language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다.

2. 컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 된다.

3. 컴퓨터 CPU마다 지원하는 오퍼레이션의 타입과 개수는 제각각이며, 레지스터의 크기와 개수, 저장된 데이터형의 표현도 각기 다르다.

4. 모든 범용 컴퓨터는 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행할지는 다를 수 있으며, 이런 차이는 어셈블리어가 반영되게 된다.

5. 어셈블러는 니모닉 기호를 opcode로 변환하고 메모리 위치와 기타 존재물에 따라 식별자를 다시 분석함으로써 목적 코드를 만들어 낸다.

# 메모리 관리 장치

1. 메모리 관리 장치(Memory Management Unit, MMU)는 CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품이다.

2. 가상 메모리 주소를 실제 메모리 주소로 변환하며, 메모리 보호, 캐시 관리, 버스 중재 등의 역할을 담당하며 간단한 8비트 아키텍처에서는 뱅크 스위칭을 담당하기도 한다.

3. 최신 아키텍처에서 MMU는 가상 주소 공간을 2^N 비트 크기의 페이지들로 나눈다.

4. 그 가운데 일부 페이지는 실제 메모리 주소의 한 프레임에 대응되는데, 대부분의 경우 가상 주소 공간은 실제 주소 공간보다 크기 때문에 모든 페이지가 실제 메모리에 대응 되는 것은 아니다.

5. CPU가 가상 메모리 주소를 MMU에 넘겨주면 MMU는 그 주소를 받아 뒤쪽의 N 비트는 바꾸지 않고 앞쪽의 나머지 비트를 그에 해당하는 실제 메모리 주소로 바꾼다.

6. 이때 가상 메모리 주소와 실제 메모리 주소 사이의 변환을 위해 MMU는 변환 참조 버퍼(Translation Lookaside Buffer, TLB)라는 고속의 보조기억장치를 참조한다.

7. 이 보조기억장치에 원하는 변환 정보가 없을 때는 더 느린 방법으로 페이지 변환 정보를 얻어오는데, 이 페이지 변환 정보가 담겨 있는 자료구조를 페이지 테이블(Page Table)이라 한다.

8. 페이지 테이블의 동작은 아키텍처와 운영체제에 따라 서로 다르다.

9. TLB나 PTE는 또한 그 메모리 주소가 캐시되었는지, 페이지가 쓰여졌는지 (Page Dirty), 프로세스에게 메모리에 접근할 권한이 있는지 등의 정보를 저장하기도 한다.

10. TLB나 페이지 테이블이 실제 메모리 주소를 가져오지 못하는 경우가 있는데, 이를 페이지 실패(Page Fault)라 한다.

11. 대부분의 경우 페이지 실패는 가상 주소 공간의 페이지가 실제 메모리에 없기 때문에 발생한다.

12. 이 경우 운영체제가 그 처리를 담당하는데, 비어 있는 메모리 공간에 페이지를 할당하거나, 비어 있는 메모리 공간이 없을 경우 실제 메모리의 한 페이지를 빼내 하드 디스크에 저장하고 (이를 페이징이라 한다) 그 자리에 요구 받은 페이지를 할당한다.

13. ![image](https://user-images.githubusercontent.com/78199659/138395165-0e4f7231-a277-48b7-b194-af4411a0b6a1.png)


# 메모리 관리

1. 메모리 관리는 컴퓨터 메모리를 관리하는 행위이다.

2. 가장 단순한 형태의 메모리 관리 방법은 프로그램의 요청이 있을 때, 메모리의 일부를 해당 프로그램에 할당하고, 

3. 더 이상 필요하지 않을 때 나중에 다시 사용할 수 있도록 할당을 해제하는 것이다.

4. 이는 하나 이상의 프로세스가 언제든 실행되는 고급 컴퓨터 시스템에 필수적이다.

5. 가상 메모리 시스템은 프로세스가 사용하는 메모리 주소를 실제 물리 주소와 구분한다.

6. 이로써 프로세스를 구분하고 디스크 스왑 처리를 사용하여 효과적으로 사용할 수 있는 램의 양을 늘릴 수 있게 된다.

7. 가상 메모리 관리자의 품질은 전반적인 시스템 성능에 큰 영향을 미친다.

8. 쓰레기 수집은 프로그램을 위한 컴퓨터 메모리 리소스를 자동으로 할당하고 할당을 해제한다.

9. 프로그래밍 언어 수준에서 일반적으로 추가되어 있는 것이며, 수동 메모리 관리와 대조된다.

10. 운영 체제의 메모리 관리에 대한 주된 목표

```

1. 여러 프로세스가 동시에 실행될 수 있도록 메모리 공간을 제한할 것

2. 시스템 사용자들을 위해 만족할 만한 수준의 성능을 제공할 것

3. 각 프로그램의 리소스를 보호할 것

4. 프로세스 사이에 있는 메모리 공간을 공유할 것

5. 프로그래머를 위해 되도록 메모리 공간의 어드레싱을 투명하게 할 것

```

# 가상 메모리

1. 가상 메모리(Virtual Memory) 또는 가상 기억 장치(Virtual Storage)는 메모리 관리 기법의 하나로, 기계에 실제로 이용 가능한 기억 자원을 이상적으로 추상화하여 사용자들에게 매우 큰 (주) 메모리로 보이게 만드는 것을 말한다.

2. 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식이다.

3. 이러한 방식은 멀티태스킹 운영 체제에서 흔히 사용되며, 실제 주기억장치보다 큰 메모리 영역을 제공하는 방법으로도 사용된다.

4. 가상적으로 주어진 주소를 논리 주소(Logical Address) 또는 가상 주소(Virtual Address)라고 하며, 실제 메모리 상에서 유효한 주소를 실 주소(Real Address) 또는 물리 주소(Physical Address)라고 한다.

5. 가상 주소 공간은 메모리 관리 장치(MMU)에 의해서 물리 주소로 변환된다.

6. 이 덕분에 프로그래머는 가상 주소 공간상에서 프로그램을 짜게 되어 프로그램이나 데이터가 주메모리상에 어떻게 존재하는지를 의식할 필요가 없어진다.

1. ![image](https://user-images.githubusercontent.com/78199659/138395185-b01e9389-5c65-49f8-976d-80d290a63783.png)

# 프로세스

1. 프로세스(Process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.

2. 종종 스케줄링의 대상이 되는 작업(Task)이라는 용어와 거의 같은 의미로 쓰인다.

3. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다.

4. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.

5. 프로그램은 일반적으로 하드 디스크 등에 저장되어 있는 실행코드를 뜻하고, 

6. 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다.

7. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행된다.

8. 커널 내에는 준비 큐, 대기 큐, 실행 큐 등의 자료구조가 있으며 커널은 이것들을 이용하여 프로세스의 상태를 관리한다.

8. 프로세스의 상태

```

1. 생성(create) : 프로세스가 생성되는 중이다.

2. 실행(running) : 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.

3. 준비(ready) : 프로세스가 CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리고 있다. 

일반적으로 준비 상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받는다.

4. 대기(waiting) : 보류(block)라고 부르기도 한다. 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태를 말한다.

5. 종료(terminated) : 프로세스의 실행이 종료되었다.

```

10. 하나의 프로그램이 실행되면 그 프로그램에 대응되는 프로세스가 생성되어 준비 리스트의 끝에 들어간다.

12. 준비 리스트 상의 다른 프로세스들이 CPU를 할당받아 준비 리스트를 떠나면, 그 프로세스는 점차 준비 리스트의 앞으로 나가게 되고 언젠가 CPU를 사용할 수 있게 된다.

9. 프로세스의 상태전이

```

1. 디스 패치(dispatch) : 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것, 즉 준비 상태에서 실행 상태로 바뀌는 것을 디스패치라고 하며 다음과 같이 표시한다.

dispatch (processname) : ready -> running

2. 보류(block) : 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 입출력 동작을 필요로 하는 경우 프로세스는 CPU를 스스로 반납하고 보류 상태로 넘어간다.

block (processname) : running -> blocked

3. 깨움(wakeup) : 입출력 작업 종료 등 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정을 깨움이라고 하며 다음과 같이 표시한다.

wakeup (processname) : blocked -> ready

4. 시간제한(timeout) : 운영 체제는 프로세스가 CPU를 계속 독점해서 사용하지 못하게 하기 위해 clock interrupt를 두어서 프로세스가 일정 시간동안만 (시분할 시스템의 time slice) CPU를 점유할 수 있게 한다.

timeout (processname) : running -> ready

```




# 뱅크 스위칭

1. 뱅크 스위칭(Bank Switching)은 마이크로프로세서의 주소 공간보다 많은 메모리를 활용하기 위해 개발된 기술이다.

2. 주로 8비트 마이크로프로세스에서 사용되었으며, 거의 대부분의 8비트 마이크로프로세서가 16비트 주소 공간이므로 2^16 = 65536 메모리 공간을 갖는다.

3. 이것보다 많은 메모리를 확장하려면 뱅크스위칭을 사용한다.

4. 그러나 주소공간 내에서 액세스가 되어야 하므로 동시에 64kB보다 많은 공간을 식별할 수 없다.

5. 따라서 사용하는 뱅크를 설정하고 해당공간만을 액세스하다가, 뱅크를 바꾸어 다른 공간을 활용한다.

6. 같은 주소 공간의 뱅크를 스위칭하는 방법은 논리회로의 주소 디코더에 의한 설정에 의해 결정된다.

7. 같은 주소공간의 여러개의 뱅크 중에 선택된 뱅크만이 액세스 되도록 하고 선택되지 않은 뱅크는 데이터를 유지만 하도록 동작 한다.

8. 뱅크를 스위칭할 때, 전체를 하나의 단위로만 만들고 주소 공간을 스위칭하면 뱅크를 선택하여 다른 뱅크로 데이터를 복사할 수가 없게 된다.

9. 따라서 전체 주소 공간을 특정 크기로 나누어 놓고 각각의 블럭을 선택하게 함으로써 뱅크간의 데이터 복사가 가능해진다.

10. ![image](https://user-images.githubusercontent.com/78199659/138385989-f220e1db-bf0f-452c-b52b-d0b5dda60a54.png)


# 주소 공간

# 어셈블리어

1. 

# 바이오스

1. 바이오스(Basic Input/Output System, BIOS)는 운영 체제 중 가장 기본적인 소프트웨어이자 컴퓨터의 입출력을 처리하는 펌웨어다.

2. 사용자가 컴퓨터를 켜면 시작되는 프로그램으로 주변 장치(하드웨어)와 컴퓨터 운영 체제(소프트웨어) 사이의 데이터의 흐름을 관리한다.

3. 펌웨어의 한 종류로서 IBM호환 컴퓨터의 경우에 전원이 공급되면 시작되는 부팅 절차에서 하드웨어 초기화를 수행하고, 운영체제나 응용 프로그램에게 런타임 서비스(컴퓨터 프로그램의 실행을 지원하는 서비스)를 제공한다.


# 추상화 계층

1. 컴퓨터 구조에서 컴퓨터 시스템은 일반적으로 다섯 가지 수준으로 구성된다.

1. 운영체제 및 응용 프로그램

2. 커널

3. 어셈블러

4. 펌웨어

5. 하드웨어


# 제어장치 

1. 제어장치(Control Unit, CU)는 프로세스의 조작을 지시하는 컴퓨터 중앙 처리 장치(CPU)의 한 부품이다.

2. 입출력 장치 간 통신 및 조율을 제어한다.

3. 명령어들을 읽고 해석하며 데이터 처리를 위한 시퀀스를 결정한다.

# 프로세스 레지스터

1. 프로세스 레지스터(process register) 또는 단순히 레지스터는 컴퓨터의 프로세서(CPU) 내에서 자료를 보관하는 아주 빠른 기억 장소이다.

2. 일반적으로 현재 계산을 수행중인 값을 저장하는 데 사용된다.

3. 대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로 저장하는 로드-스토어 설계를 사용하고 있다.

4. 레지스터는 메모리 계층의 최상위에 위치하며, 가장 빠른 속도로 접근 가능한 메모리이다.

5. 최신 프로세서에서 레지스터는 대게 레지스터 파일로 구현되지만, 과거에는 플립플롭, 마그네틱 코어, 박막 필름 메모리 등으로 구현되기도 했다.

6. 프로세서 내부의 레지스터 구성

```

프로그램 계수기(PC) : 다음에 실행할 명령어의 주소를 가지고 있다.

명령어 레지스터(IR) : 현재 수행 중인 명령어를 가지고 있다.

메모리 주소 레지스터(MAR) : 메모리로부터 읽어오거나 메모리에 쓰기 위한 주소를 가지고 있다.

```

# 메모리 계층 구조

1. 메모리 계층 구조(Memory Hierarchy)란 메모리를 필요에 따라 여러가지 종류로 나누어 둠을 의미한다.

2. 이때 필요한 대부분의 경우 CPU가 메모리에 더 빨리 접근하기 위함이다.

3. ![image](https://user-images.githubusercontent.com/78199659/138234076-7a2e26f5-9c96-4656-b57e-36c6eeb077a2.png)

4. 레지스터와 캐시는 CPU 내부에 존재한다. 당연히 CPU는 아주 빠르게 접근할 수 있다.

5. 메모리는 CPU 외부에 존재한다.

6. 레지스터와 캐시보다 더 느리게 접근할 수 밖에 없다.

7. 하드 디스크는 CPU가 직접 접근할 방법조차 없다.

8. CPU가 하드 디스크에 접근하기 위해서는 하드 디스크의 데이터를 메모리로 이동시키고, 메모리에서 접근해야 한다.

# 램

1. 컴퓨터에서 랜덤 액세스 메모리(Random Access Memory, RAM)는 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치다.

2. 반도체 회로로 구성되어 있으며 휘발성 메모리다.

3. RAM은 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸리는 메모리이기에 '랜덤'이라는 명칭이 주어진다.

4. 반면, 하드 디스크, 플로피 디스크 등의 자기 디스크나 자기 테이프는 저장된 위치에 따라 접근하는 데 걸리는 시간이 다르다.

# 고정 기억 장치 

1. 고정 기억 장치 또는 롬(Read-Only Memory, ROM)은 반도체 기억장치의 하나로 사람의 본능에 비유할 수 있으며, 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있다.

2. 그리고 그 정보들을 기억하기 위해 다른 정보들은 기억하지 않는다.

3. 그러나 램(RAM)은 읽고 쓰기가 가능하다.

4. 대신 전원을 끄면 데이터가 지워진다.

5. 하지만 롬은 전원을 꺼도 데이터가 지워지지 않기 때문에 바이오스(BIOS)나 운영 체제(OS)또는 펌웨어의 저장에 쓰였으나 최근에는 일부분이 읽고 쓰기가 가능한 플래시 메모리 등으로 일부 대체되었다.

# 플래시 메모리

1. 플래시 메모리(flash memory)는 전기적으로 데이터를 지우고 다시 기록할 수 있는(electrically erased and reprogrammed) 비휘발성 컴퓨터 기억 장치를 말한다.

2. EEPROM과 다르게 여러 구역으로 구성된 블록 안에서 지우고 쓸 수 있다.

3. 이제는 플래시 메모리의 가격이 EEPROM 보다 훨씬 싸기 때문에, 비휘발성 고체 상태(solid-state) 저장 매체가 상당량 필요한 곳에서는 가장 많이 사용되는 메모리 종류가 되었다.

4. 대표적인 활용 예로 디지털 음악 재생기(MP3), 디지털 카메라, 휴대 전화를 들 수 있다. 일반적인 데이터를 저장하고 컴퓨터 사이에 데이터를 옮기는 용도로 USB 드라이브를 많이 사용하는데, 이때도 플래시 메모리가 쓰인다.

5. 플래시 메모리는 메모리 칩 안에 정보를 유지시키는 데에 전력이 필요 없는 비휘발성 메모리이다.

6. 게다가 플래시 메모리는 읽기 속도가 빠르며(단, 개인용 컴퓨터에서 메인 메모리로 쓰이는 DRAM만큼 빠르지는 않고, 순차 읽기 속도는 하드디스크가 더 빠를 수 있음) 하드 디스크보다 충격에 강하다.

7. 이러한 특징으로 배터리로 동작하는 장치에서 저장 장치로 많이 사용한다.

# 기억 장치

1. 주기억 장치 - 1차 기억 장치 - 컴퓨터 메모리 - 휘발성 메모리 - 전원 공급이 중단되면 기억된 내용이 지워진다. 

- 디램(Dynamic Random Access Memory, DRAM) - 데이터를 유지하기 위해 일정 시간마다 재생(refresh)해 주어야 하는 램

- 에스램(Static Random Access Memory, SRAM) - 전원이 공급되는 동안 데이터가 유지되는 램. 일정 시간마다 재생해주지 않아도 된다.

2. 보조기억 장치 - 2차 기억 장치 - 비휘발성 메모리(non-volatile memory, NVM) - 전원 공급이 끊어져도 기억된 내용은 지워지지 않는다. (장기간의 영구적 저장 공간) - 롬, 플래시 메모리, 마그네틱 컴퓨터 기억 장치(하드 디스크, 디스켓 드라이브, 마그네틱 테이프), 광디스크 드라이브 등

- 에프램(Ferroelectic Random Access Memory, FRAM) - 디램과 비슷하지만 데이터를 유지하기 때문에 재생해주지 않아도 된다.

- 피램(Phase-change Random Access Memory, PRAM) - 상변태를 하는 물질을 이용하여 저항차이로 데이터를 저장한다. 디램에 비하여 전력 소모가 매우 작은 장점이 있다.

3. 여러 기업들이 휘발성 메모리인 램(RAM)에 비해, 속도나 용량 면에서 뒤떨어지지 않는 신소재의 비휘발성 메모리를 개발하려고 노력하고 있다.

# 네트워크 인터페이스 카드

1. PC나 서버 등의 컴퓨터를 네트워크에 연결시키기 위한 장치. 

2. 네트워크 카드, 이더넷 카드, LAN 어댑터, LAN 카드라고도 한다.

3. 기능은 PC와 NIC 사이에서 논리적으로 연결하는 소프트웨어(네트워크 드라이브)가 있어, 

4. PC에서 NIC로 정보를 보내면 버퍼에 저장한 다음 네트워크에 맞는 시리얼 형태로 보내는 역할을 한다.

5. 네트워크 별로 이더넷, 토큰링, 고속 이더넷, 기가비트 이더넷, 비동기 전송 방식(ATM)등 다양한 카드가 사용된다.

# RFID

1. RFID(Radio-Frequency Identification)는 주파수를 이용해 ID를 식별하는 방식으로 일명 전자태그로 불린다.

2. RFID 기술이란 전파를 이용해 먼 거리에서 정보를 인식하는 기술을 말하며, 전자기 유도 방식으로 통신한다.

3. 여기에는 RFID 태그(이하 태그)와, RFID 판독기(이하 판도기)가 필요하다.

4. 태그는 안테나와 집적회로로 이루어지는데, 집적 회로 안에 정보를 기록하고 안테나를 통해 판독기에게 정보를 송신한다.

5. 이 정보는 태그가 부착된 대상을 식별하는 데 이용된다.

6. 쉽게 말해, 바코드와 유사한 기능을 하는 것이다.

7. RFID가 바코드 시스템과 다른 점은 빛을 이용해 판독하는 대신 전파를 이용한다는 것이다.

8. 따라서 바코드 판독기처럼 짧은 거리에서만 작동하지 않고 먼 거리에서도 태그를 읽을 수 있으며, 심지어 사이에 있는 물체를 통과해서 정보를 수신할 수도 있다.

9. RFID는 사용하는 동력으로 분류할 수 있다.

10. 오직 판독기의 동력만으로 칩의 정보를 읽고 통신하는 RFID를 수동형(Passive) RFID라 한다.

11. 반수동형(Semi-Passive) RFID란 태그에 건전지가 내장되어 있어 칩의 정보를 읽는 데는 그 동력을 사용하고, 통신에는 판독기의 동력을 사용하는 것을 말한다.

12. 마지막으로 능동형(Actvie) RFID는 칩의 정보를 읽고 그 정보를 통신하는 데 모두 태그의 동력을 사용한다.

# 공개 키 인프라 

1. 공개 키 인프라(Public Key Infrastructure, PKI)는 디지털 인증의 생성, 관리, 배포, 사용, 저장, 파기와

- 공개 키 암호화의 관리에 쓰이는 일련의 역할, 정책, 하드웨어, 소프트웨어, 절차의 총칭으로 전자 상거래, 인터넷 뱅킹, 민감한 정보를 담은 이메일을 포함한 다양한 네트워크 활동에 있어 정보의 안전한 전송이 목적이다.

- 암호학적으로 공개된 키를 개인이나 집단을 대표하는 적절한 주체와 엮는 것이며 이는 인증기관(Certificate Authorithy, CA)의 등록과 해당 기관에 의한 인증의 발행을 통해 성립된다.

```

Message Digest

대칭키(Symmetric Key Alogorithm)

비대칭키(Asymmetric Key Alogorithm)

```

2. Cryptographic Hash Function

```

암호화 해쉬(Cryptographic Hash)

주로 하는 일은 메시지 축약(Message Digest)이다.

아무리 긴 파일이라도 간단하게 축약시킨다.

MD5 - 128bit, SHA-1 160bit

즉 결과가 MD5는 16byte, SHA-1은 20byte로 축약된다.

```

3. Symmetric Key Alogorithm

```

One Key(대칭 키)

Encryption, Decryption 시 같은 '키'를 사용

3DES, AES

```

4. Asymmetric Key Alogorithm

```

비 대칭키

Two Key (Private Key : 개인키, Public Key : 공개키)

Encryption, Decryption 시 서로 다른 '키'를 사용

RSA

```

# 공용 게이트웨이 인터페이스

1. 공용 게이트웨이 인터페이스(Common Gateway Interface, CGI)는 웹 서버 상에서 사용자 프로그램을 동작시키기 위한 조합이다.

2. 존재하는 많은 웹 서버 프로그램은 CGI의 기능을 이용할 수 있다.

3. 웹 서버 프로그램의 기능의 주체는 미리 준비된 정보를 클라이언트의 요구에 응답해 보내는 것이다.

4. 그 때문에 서버 프로그램 그룹에서는 정보를 그 장소에서 동적으로 생성하고 클라이언트에 송신하려하는 조합을 작성하는 것이 불가능했다.

5. 서버 프로그램에서 다른 프로그램을 불러내고, 그 처리 결과를 클라이언트에 송신하는 방법이 고안되었다.

6. 이를 실현하기 위한 서버 프로그램과 외부 프로그램과의 연계법을 정한 것이 CGI이다.

7. CGI는 환경변수나 표준입출력을 다룰 수 있는 프로그래밍 언어에서라면 언어의 구별을 묻지 않고 확장하여 이용하는 것이 가능하나, 실행속도나 텍스트 처리의 용이함 등의 균형에 의해 펄이 사용되는 경우가 많았다.

8. 웹 서버의 프로세스로서 인터프리터를 상주시킴으로써, CGI로부터 프로그램을 호출해 부하를 줄임으로써 성능을 개선한 자바 서블릿이나 mod perl, mod php, FastCGI 등도 공개되었다.

# 자바 서블릿

1. 자바 서블릿(Java Servlet)은 자바를 이용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 "서블릿"이라 부른다.

2. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.

3. 서블릿은 JSP와 비슷한 점이 있지만, JSP가 HTML 문서 안에 Java 코드를 포함하고 있는 반면, 서블릿은 자바 코드 안에 HTML을 포함하고 있다는 차이점이 있다.

4. 자바 서블릿은 자바 EE 사양의 일부분으로, 주로 이 기능을 이용하여 쇼핑몰이나 온라인 뱅킹 등의 다양한 웹 시스템이 구현되고 있다.

# 운영 체제 수준 가상화

1. 운영 체제 수준 가상화(Operating-System-Level Vritualization)는 운영 체제의 커널이 하나의 사용자 공간 인스턴스가 아닌, 여러 개의 격리된 사용자 공간 인스턴스를 갖출 수 있도록 하는 서버 가상화 방식이다.

2. 이러한 인스턴스들은 종종 컨테이너(Container), 소프트웨어 컨테이너(Software Container), 가상화 엔진(Virtual Engine) 이라고도 부르며 소유자와 사용자의 관점에서 실제 서버인 것처럼 보이게 한다.

3. 유닉스 계열 운영 체제에서 이 기술은 표준 chroot 메커니즘의 고급 구현체로 간주될 수 있다.

4. 격리 메커니즘뿐 아니라 커널은 다른 컨테이너 상의 특정 컨테이너 활동의 영향력을 제한시키기 위한 자원 관리 기능을 제공하기도 한다.

5. 운영 체제 수준 가상화는 보통 가상 호스팅 환경에 사용되며, 상호 신뢰하지 않는 수많은 사용자들 간에 한정된 하드웨어 자원을 안전하게 할당하는데 유용하다.

6. 시스템 관리자들 또한 개별 호스트 상의 서비스들을 특정 서버의 컨테이너로 이동함으로써 서버 하드웨어를 개선하기 위해 적은 빈도로 이것을 사용할수 있다.

7. 다른 일반적인 시나리오에는 보안 개선, 하드웨어 독립, 자원 관리 기능 추가를 위해 여러 애플리케이션들을 개개의 컨테이너로 분리시키는 것을 포함한다.

8. 그러나 chroot 메커니즘을 이용하여 제공되는 개선된 보안은 상실하게 된다.

9. 클러스터 내 노드 간 컨테이너의 동적 부하 분산을 위해 실시간 이관이 가능한 운영 체제 수준 가상화 구현을 사용할 수 있다.

# 도커

1. https://www.44bits.io/ko/post/why-should-i-use-docker-container

1. 도커(Docker)는 리눅스의 응용 프로그램들을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 오픈 소스 프로젝트이다.

```

도커 컨테이너는 일종의 소프트웨어를 소프트웨어의 실행에 필요한 모든 것을 포함하는 완전한 파일 시스템안에 감싼다.

여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 무엇이든 아우른다.

이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.

```

2. 도커는 리눅스에서 운영 체제 수준 가상화의 추상화 및 자동화 계층을 추가적으로 제공한다.

3. 도커는 cgroups와 커널 네임스페이스와 같은 리눅스 커널의 기능들과 OverayFS, aufs와 같은 유니언 가능 파일 시스템의 리소스 격리 기능을 사용하며,

4. 이를 통해 독립적인 "컨테이너"가 하나의 리눅스 인스턴스 안에서 실행할 수 있게 함으로써 가상 머신을 시작하여 유지보수해야 하는 부담을 없애준다.

5. 리눅스 커널의 네임스페이스 지원은 대체적으로 프로세스 트리, 네트워크 사용자 ID, 마운트된 파일 시스템을 포함한 운영환경에 대한 응용 프로그램의 관점을 격리시키지만,

6. 커널의 cgroup들은 CPU, 메모리, 블록 입출력, 네트워크를 포함한 리소스 제한을 제공한다.

7. 버전 0.9부터 도커는 libvirt, LXC(리눅스 컨테이너), systemd-nspawn을 통한 추상화된 가상화 인터페이스를 사용하는 것 뿐 아니라 리눅스 커널이 제공하는 가상화 기능을 직접 사용하기 위한 유일한 수단으로 lincontainer 라이브러리를 포함하고 있다.

8. <a title="User:Maklaan, Public domain, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Docker-linux-interfaces.svg"><img width="512" alt="Docker-linux-interfaces" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Docker-linux-interfaces.svg/512px-Docker-linux-interfaces.svg.png"></a>

9. 도커 베이스 이미지에 액션을 취하면, 유니언 파일 시스템 계층들이 만들어지고 문서화되는데, 이렇게 함으로써 각 계층은 어떻게 액션을 재생성할지에 대해 완전하게 기술하게 된다.

10. 이러한 전략은 이를테면 완전한 VM과 비교하면 도커의 이미지를 가볍게 만들어주며, 오직 레이어 업데이트만 전파해 주면 된다.

11. 도커는 응용 프로그램과 그 의존성을 가상 컨테이너에 담을 수 있는 도구이며, 이 컨테이너는 어떠한 리눅스 서버에서라도 구동이 가능하다.

12. 이것은 사내, 공용 클라우드, 개인 클라우드, 베어 메탈 등 응용 프로그램을 실행할 수 있는 곳에서는 유연성과 이식성을 적용하는데 도움을 준다.

13. 도커는 도급 API를 구현함으로써 프로세스들을 별도의 장소에서 실행할 수 있는 가벼운 컨테이너들을 제공한다.

14. 리눅스 커널이 제공하는 기능들(주로 cgroups와 네임 스페이스) 위에 빌드되기 때문에 도커 컨테이너는 가상 머신과는 달리 별도의 운영 체제를 요구하거나 포함하지 않는다.

15. 그 대신, 커널의 기능에 의존하며 리소스 격리(CPU, 메모리, 블록 입출력, 네트워크 등) 및 격리된 네임 스페이스를 사용하여 운영 체제에 대한 응용 프로그램의 관점을 격리시킨다.

16. 도커는 매우 가볍기 때문에, 하나의 서버나 가상 머신이 여러 컨테이너들을 동시에 구동할 수 있다.

17. 컨테이너를 사용하여 리소스를 격리시키고, 서비스를 제한시키며, 프로세스를 예비할 수 있으며 이렇게 하여 자신만의 프로세스 ID 공간, 파일 시스템 구조, 네트워크 인터페이스를 갖고서 운영 체제에 대하여 거의 완전히 개인화된 관점을 갖게 한다.

18. 여러 개의 컨테이너들은 동일한 커널을 공유하지만 각 컨테이너는 CPU, 메모리, 입출력과 같이 오직 정의된 양의 리소스에만 제한을 받을 수 있다.

19. 도커를 사용하여 컨테이너를 만들고 관리하면 다수의 응용 프로그램, 작업자의 작업, 다른 프로세스들이 자율적으로 하나의 물리 머신이나 여러 개의 가상 머신을 통해 구동될 수 있게 되므로 고도의 분산 시스템을 생성하는 일이 단순해진다.

20. 리소스가 사용 가능해질 때 또는 더 많은 노드가 필요할 때 노드가 배치될 수 있게 하므로 Apache Cassandra, 몽고 DB, Riak와 같은 시스템을 위한 PaaS 스타일의 배치 및 규모 증강이 가능해진다.

21. 또, 도커는 작업이나 워크로드 큐, 기타 분산 시스템들의 생성 및 운영을 단순하게 한다.

# 리눅스 컨테이너

1. 리눅스 컨테이너(LinuX Container, LXC)는 단일 컨트롤 호스트 상에서 여러 개의 고립된 리눅스 시스템(컨테이너) 들을 실행하기 위한 운영 시스템 레벨 가상화 방법이다.

2. 리눅스 커널은 cgroups를 절충하여 가상화 머신을 시작할 필요 없이 자원 할당(CPU, 메모리, 블록 I/O, 네트워크 등)을 한다.

3. cgroups는 또한 애플리케이션 입장에서 프로세스 트리, 네트워크, 사용자 ID, 마운트된 파일 시스템 등의 운영 환경을 고립시키기 위해 namespace-isolation을 제공한다.

4. LXC는 cgroups와 namespace를 결합하여 애플리케이션을 위한 고립된 환경을 제공한다.

5. 도커(Docker) 또한 실행 드라이버의 하나로 LXC를 사용할 수 있으며 이를 통해 이미지 관리와 개발 서비스를 제공한다.

6. LXC는 완전한 가상머신을 작성하는 대신 자신의 고유한 프로세스와 네트워크 스페이스를 가지는 가상 환경을 통해 운영 시스템 레벨의 가상화를 제공한다.

# cgroups

1. cgroups(Control Groups의 약자)는 프로세스들의 자원의 사용(CPU, 메모리, 디스크 입출력, 네트워크 등)을 제한하고 격리시키는 리눅스 커널 기능이다.

2. 수많은 새로운 기능과 컨트롤러들을 추가하고 있는데, 이를테면 kernfs 지원, 방화벽, 통합된 계층 구조를 포함한다.

# 클라우드 컴퓨팅