# Session 객체란? Redis Session?

1. https://hyuntaeknote.tistory.com/8

2. https://hyuntaeknote.tistory.com/3?category=867120

3. https://hyuntaeknote.tistory.com/4?category=867120

# KEY 

1. 무상태 (stateless)

- 비연결적인 특성으로 연결이 해제됨과 동시에 서버와 클라이언트는 클라이언트가 이전에 요청한 결과에 대해서 잊어버리게 됩니다.

- 즉, 클라이언트가 이전 요청과 같은 데이터를 원한다고 하더라도 다시 서버에 연결을 하여 동일한 요청을 시도해야만 합니다.

2. 비연결성 (Connectionless)

- 비연결성이란 클라이언트가 요청(request)을 하고, 서버가 해당 요청에 적합한 응답(response)를 하게 되면 바로 연결을 끊는 성질을 의미합니다. 

# 개념

2. 세션 객체는 Key에 해당하는 SESSION ID와 이에 대응하는 Value로 구성됩니다.

3. Value에는 세션 생성 시간, 마지막 접근 시간 및 User가 저장한 속성 등 이 Map 형태로 저장됩니다.

4. 세션 객체가 저장되는 방식과 유사하게 Key-Value 형태로 데이터를 저장하는 데이터베이스가 있습니다.

5. 이를 Key-Value 데이터베이스 혹은 Key-Value Model NoSQL이라고 합니다.

6. 이러한 데이터베이스의 특징은 저장구조가 Key-Value 형태로 단순하다는 점입니다.

7. 이로 인해 관계형 데이터베이스와 같이 복잡한 조회 연산을 지원하지 않지만,

8. 단일 키 처리만을 지원하기 때문에 고속 읽기와 쓰기에 최적화된 경우가 많습니다.

9. 특히, 세션에 저장되는 데이터의 경우에는 대부분 비교적 간단한 연산을 통해 처리를 할 수 있습니다.

10. 이러한 점에서 Key-Value 형태의 데이터베이스가 세션 저장소로써 적합하다고 볼 수 있습니다.

# 쿠키

1. 쿠키는 웹 브라우저가 보관하는 데이터입니다.

2. 웹 서버는 쿠키를 생성하여 웹 브라우저에 정보를 전송할 수 있습니다.

3. 쿠키는 키 - 밸류 형태로 웹 브라우저의 쿠키 저장소에 저장됩니다.

4. 서버로부터 쿠키를 전달받은 웹 브라우저는 이후 웹 서버에 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송합니다.

5. 이를 이용하면 웹 서버와 클라이언트는 필요한 값을 공유하고 상태를 유지할 수 있습니다.

6. 클라이언트에 보관된 쿠키는 유효기간 설정이 가능합니다.

7. 유효기간을 설정하면 쿠키는 특정 시간이 지나면 자동으로 소멸합니다.

8. 유효기간을 설정하지 않을 시에는 브라우저 종료와 함께 소멸합니다.

9. 하지만 쿠키만으로 로그인을 구현하는 것은 한계가 있습니다.

10. 쿠키는 네트워크를 통해 전달되기 때문에 중간에 쿠키를 탈취할 수 있다는 취약점이 있습니다.

11. 이를 보완하고자 우리는 세션(Session) 을 사용합니다.

# 세션

1. 세션도 마찬가지로 클라이언트의 상태를 저장할 수 있습니다.

2. 쿠키와 다른 점은 쿠키는 각 브라우저의 별도 쿠키 저장소에 저장되는 반면에 세션은 서버에 저장이 됩니다.

3. 웹 브라우저는 각각 별도의 세션을 갖습니다.

4. 각 세션을 구분하기 위해 고유 ID 를 할당하고, 웹 서버는 각 브라우저에 세션 ID 를 전송합니다.

5. 웹 브라우저는 웹 서버에 연결 시 매번 세션 ID 를 보내서 웹 서버가 어떤 세션을 사용할 지 알 수 있도록 합니다.

6. 이 때, 웹 서버와 웹 브라우저가 세션 ID 를 주고받기 위해서 사용하는 것이 쿠키입니다. (Tomcat 에서 발급하는 쿠키의 Key 는 JSESSIONID 입니다.)

7. 이를 종합하여 로그인이 이루어지는 과정을 보겠습니다.

8. 우리는 로그인 정보를 웹 컨테이너 메모리의 세션 객체에 저장하게 되고, 클라이언트는 세션 ID를 전송하여 브라우저 고유 세션을 식별하게 됩니다.

9. 이 후 세션 객체 내부에 로그인 여부를 확인할 수 있는 특정 속성이 존재하면 로그인한 것으로 판단할 수 있습니다.

10. 아래 그림을 보면 클라이언트와 웹서버가 세션과 쿠키를 이용하여 어떻게 로그인 인증 절차를 가지는지 확인하실 수 있습니다.

11. ![다운로드](https://user-images.githubusercontent.com/78199659/137417474-09e69bde-6b08-4583-95e3-a6acb62a42ca.png)

12. Login Request -> ID/PW 확인 -> Login Response -> 웹 서버 내부 회원 세션 생성 -> Session ID 발급 -> Response + Session ID -> 쿠키 저장소에 Session ID 저장 -> 인증이 필요한 요청마다 헤더에 쿠키 삽입 -> request + cookie -> 쿠키 인증 -> 세션 정보 획득 -> Response

# 멀티 서버에서 세션을 저장하는 방법 세 가지

1. https://hyuntaeknote.tistory.com/6?category=867120

1. 우선 구성 방식

- Multi Server 환경에서 Session이 어떻게 구성되는지?

- 서버가 네 개면 각 서버에 대한 내용을 저장하는 세션 저장소가 네 개가 된다.

- 여러 대로 나뉜 서버가 하나의 서비스를 운영하기 위해서는 4개의 분리된 세션을 하나의 시스템 처럼 동작하게 하거나, 고정된 세션을 사용해야 한다.

2. Sticky Session 방식

```

예를 들어, User1 이 1번부터 3번까지의 서버 중 1번 서버에 세션을 생성하였다면,

이후에 User1이 보내는 모든 요청은 1번 서버로만 보내지게 됩니다.

즉, Load Balancer는 User가 첫 번째 세션을 생성한 서버로 모든 요청을 리다이렉트 하여 고정된 세션만 사용하게 합니다.

이를 위해서 로드 밸런서는 요청을 받으면 가장 먼저 요청에 쿠키가 존재하는지 확인합니다.

쿠키가 있으면 해당 요청이 쿠키에 지정된 서버로 전송됩니다.

쿠키가 없는 경우에는 로드 밸런서가 기존 로드 밸런싱 알고리즘을 기반으로 서버를 선정합니다.

동일한 사용자가 계속 해당 서버에 요청을 보낼 수 있도록 지속적으로 서버 정보가 쿠키를 통해 응답에 삽입되어 보내집니다.
 
이러한 방식을 사용하면 유저는 세션이 유지되는 동안 동일한 서버만을 사용하기 때문에 정합성 이슈에서 자유로워질 수 있습니다.

하지만 이 방식에도 단점은 존재합니다.

먼저, 고정된 세션을 사용한다는 것은 특정 서버에 트래픽이 집중될 위험이 있습니다.

왜냐하면 사용자가 접속해야 하는 서버가 정해져 있기 때문에 하나의 서버에 트래픽이 집중되어 있더라도 사용자는 자신의 세션이 없는 다른 서버를 사용할 수 없습니다.

```

3. 세션 클러스터링 - all-to-all 

- 클러스터링이란? 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것을 클러스터링이라고 합니다. 

- 서버 또한 컴퓨터로써 여러 대가 하나의 서비스를 하기 위해서는 클러스터링이 필요합니다.

```

all-to-all 세션 복제란 하나의 세션 저장소에 변경되는 요소가 발생하면 변경된 사항이 다른 모든 세션에 복제가 된다는 것을 말합니다.

그림과 같이 세션을 복제한다면 유저가 이후에 어떤 서버에 접속하더라도 로그인 정보가 세션에 복제되어 있으므로 정합성 이슈가 해결 가능합니다.

이로써 서버 하나에 장애가 발생하더라도 서비스는 중단되지 않고 운영 가능합니다.

하지만 Tomcat의 all-to-all 세션 복제 방식은 고려해야 할 단점들이 존재합니다.

우선, 모든 서버가 동일한 세션 객체를 가져야 하기 때문에 많은 메모리가 필요합니다.

또한 세션 저장소에 데이터가 저장될 때마다 모든 서버에 값을 입력해야 하므로 서버 수에 비례하여 네트워크 트래픽이 증가하는 등 성능 저하가 발생하게 됩니다.

그러므로 해당 방식은 소규모 클러스터에서 좋은 효율을 보여줍니다.

4개 이상의 서버를 가진 대규모 클러스터들에는 추천하지 않는 방식입니다.

```

4. 세션 클러스터링 - primary-secondary 세션 복제

```

그림과 같이 Primary 서버는 Secondary(Backup) 서버에 세션 객체의 Key-Value 전체를 복제합니다.

하지만, 이외의 서버에는 Key에 해당하는 JSESSION ID만을 복제하기 때문에 메모리 사용이 all-to-all 방식보다 줄어들게 됩니다.

세션 객체 전체를 복제하는 시간보다 Key만 복제하는 것이 상대적으로 시간도 절약되겠죠?

그럼에도 불구하고, 아직 문제점은 존재합니다. 세션을 복제하는데 걸리는 시간은 줄일 수 있었으나,

Primay 서버와 Secondary 서버를 제외한 Proxy 서버에 세션 정보를 요청할 경우에는 다시 Primary 서버에 요청하여 해당 Key에 해당하는 객체를 받아와야만 합니다.

이러한 단점도 무시할 수 없겠죠?

이처럼 Tomcat의 세션 클러스터링은 정합성 이슈를 해결할 수 있지만, 성능적인 한계가 존재합니다.

그렇다면 위의 두 방식의 단점을 보완하여 다중 서버에서 세션을 공유할 수 있는 방법은 없을까요?

```

5. 세션 스토리지 분리를 통해 Scale-Out 시, 발생하는 정합성 이슈를 해결해보자!

```

세션 스토리지를 분리한다는 건 어떤 것일까요?

이는 기존 서버가 갖고 있는 로컬 세션 저장소를 이용하는 것이 아니라, 별도의 세션 저장소를 사용하는 것을 의미합니다! 어떻게 가능할까요?

아래 그림을 보시면 쉽게 이해하실 수 있습니다.

```

6. ![다운로드 (1)](https://user-images.githubusercontent.com/78199659/137418687-78e21ae0-8cb8-4b1b-a82f-a21c65a7b414.png)


```

보시는 바와 같이 세션 스토리지가 분리되면, 서버가 아무리 늘어난다고 할 지라도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있게 됩니다.

이러한 방식을 사용한다면 로드밸런싱 알고리즘만 잘 구현되어 있다는 가정 하에 Sticky Session처럼 트래픽이 비정상적으로 몰리는 현상을 고려하지 않아도 되게 됩니다.

또한 서버가 하나 장애가 발생하더라도 별도의 세션 저장소가 존재하기 때문에 서비스를 계속해서 제공할 수 있겠죠? 즉, 가용성을 확보할 수 있습니다.

뿐만 아니라 우리가 가장 근본적으로 해결하고자 하던 정합성 문제도 해결할 수 있습니다. 여러 대의 서버가 하나의 세션을 사용하기 때문에 기존에 개별적으로 갖고 있던 로컬 세션 저장소의 데이터 불일치가 발생하지 않기 때문입니다.

무엇보다도 세션 저장소가 하나이기 때문에 데이터 정합성 해결을 위한 별도의 세션 복제를 할 필요가 없어서 이에 대한 성능적인 문제도 해결이 가능합니다.

단, 세션 저장소도 세션 객체를 복제해야 할 필요가 있습니다.

이는 데이터 정합성 문제를 해결하기 위한 것이 아니라, 하나의 세션 저장소를 운영한다는 것은 그만큼 해당 서버에 장애가 발생하면,

모든 세션 이용이 불가하다는 뜻이기 때문에 가용성을 확보하기 위해 동일한 세션 저장소 하나를 더 구성하여 복제하는 것입니다.

그럼 세션을 저장하는 저장소는 무엇을 사용해야 할까요?

```

# 세션 스토리지로는 어떤 데이터베이스를 활용해야 할까?

1. 웹 서비스의 특성상 대부분의 요청은 인가된 사용자가 보내는 요청인지 확인하는 절차가 선행되어야 합니다.

2. 즉, 대부분의 요청에서 로그인한 사용자인지 아닌지 확인하기 위해 매번 세션 스토리지를 방문해야 합니다.

3. 이러한 특성을 고려한다면 세션 스토리지를 선정할 때, 성능에 영향이 미치지 않도록 빠르게 데이터를 찾아서 제공할 수 있는 데이터베이스를 사용해야 하겠죠?

4. 지금부터 어떠한 데이터베이스가 세션 스토리지에 적합한지 알아보겠습니다.

```

데이터베이스는 데이터가 어느 곳에 저장이 되는가를 기준으로 디스크 기반의 데이터베이스와 In-Memory 데이터베이스로 분류됩니다.

이름 그대로 디스크 기반의 데이터베이스는 데이터를 Disk에 저장하여 관리하며, In-Memory 데이터베이스는 메모리에 데이터를 저장하고 관리하는 데이터베이스를 말합니다.

조금 더 구체적으로 알아볼까요? 우선, 디스크 기반 데이터베이스에는 우리가 흔히 사용하는 예로 MySQL, Oracle, MS-SQL 등과 같은 관계형 데이터베이스가 있습니다.

디스크 기반 데이터베이스의 특징은 데이터를 디스크에 저장하여 관리한다는 점입니다.

물론, 앞서 언급한 데이터베이스들도 스토리지 엔진에 따라서 데이터를 디스크에 저장하기도 하고, 메모리에 저장하기도 합니다.

디스크 기반 데이터베이스는 데이터를 디스크에 저장함으로써 전원이 공급이 되지 않더라도 영구적으로 보관이 가능하지만,

위 그림과 같이 내부 원판(Flatter)을 회전시켜서 데이터를 읽고 쓰는 기계식 방식을 사용하기 때문에 전자식 저장매체보다는 속도가 현저히 느립니다.

최근 들어, 하드디스크 대체하여 SSD 사용하는 이유도 SSD는 플래시 메모리를 사용한 전자식 저장매체이기 때문에 기계식 저장매체인 하드디스크보다 빠른 속도로 데이터를 읽고 쓸 수 있기 때문입니다.

SSD가 Disk 기반의 데이터베이스보다 빠른 I/O를 처리할 수 있지만, 우리가 컴퓨터의 메모리로써 사용하는 RAM에 비해서는 역시 속도가 떨어집니다.

```

5. ![다운로드 (2)](https://user-images.githubusercontent.com/78199659/137419567-f1073b33-fbc2-4994-a078-51970e0f181d.png)

```

위에 보시는 표는 컴퓨터 주요 부품별 처리 속도를 나타냅니다. 
 
보시는 바와 같이 SSD와 DISK는 약 1,000배 이상의 요청 처리 속도 차가 발생합니다.

표에서 보기에 DISK의 단위가 너무 커서 D-RAM과 SSD의 처리속도 차이가 미비해 보일지 모르지만, SSD의 경우에도 메모리와 1,000배 정도의 속도 차이를 발생시킵니다.

예를 들어, 메모리가 1초에 100만 건을 처리할 수 있는 작업이 있다고 한다면, 디스크의 경우에 이러한 100만 건의 작업을 처리하기 위해서 약 300시간이 걸리게 됩니다.

메모리와 Disk의 처리속도가 엄청난 차이를 보인다는 것을 알겠죠? 처음에 언급했다시피 데이터베이스 종류에는 데이터를 어디에 저장하는가에 따라 디스크 기반의 데이터베이스와 In-Memory 데이터베이스로 분류된다고 하였습니다.

In-Memory 데이터베이스는 메모리에 데이터를 저장하고 관리하기 때문에 I/O에 대한 부담을 덜 수 있습니다.

하지만, 메모리의 경우에도 단점은 존재합니다. 빠른 속도를 자랑하는 대신 전원이 공급되지 않는 순간, 기억하고 있는 데이터를 전부 잃어버리게 됩니다.

그렇다면, 세션 객체를 저장하기에 메모리도 안전하지 않은 것일까요?

지금부터 이에 대해 알아보겠습니다!

```

6. 세션 저장소로써 In-Memory 데이터베이스는 적합할까?

```

이는 저장되는 데이터의 종류에 따라서 달라집니다.

잘 생각해보면 세션에 저장하는 데이터들은 영구적으로 저장하는 데이터가 아닙니다.

로그인한 사용자 정보를 예로 들어보면 로그아웃을 할 경우, 사용자의 세션 객체는 만료됩니다.

더 나아가 로그아웃을 하지 않더라도 개발자가 정한 일정 시간이 지나면 자동적으로 만료되게 됩니다.

만료된 이후에 다시 서비스를 사용하기 위해서는 재로그인을 하면 됩니다.

또한 로그아웃을 하지 않고, 브라우저를 종료한 경우에도 쿠키에 저장된 세션 ID가 사라지기 때문에 서버에 저장되어 있던 기존 세션 객체 사용이 불가하므로 다시 로그인을 해야 합니다.

이렇게 세션을 관리하는 이유는 다양합니다. 

현재 사용 중이지 않는 사용자의 데이터를 계속해서 세션 저장소에 보관하게 된다면, 일정 시간 후에는 메모리 부족 현상이 발생할 수 있습니다. 

또한 세션이 지속적으로 유지된다면 해커의 세션 기반 공격에 대한 노출이 증가하기 때문에 일정 시간 후 세션을 만료시키도록 해야 합니다.

세션에 저장되는 데이터가 이러한 특성을 지니기 때문에 상대적으로 서비스 장애로 인하여 데이터가 소멸됨에 있어서 피해가 적습니다. 

계속해서 로그인한 사용자 데이터의 경우를 생각해보면 세션 객체에 저장되는 사용자 정보 역시 In-Memory 데이터베이스의 장애로 인해 내부에서 소멸하더라도 사용자가 다시 로그인 요청을 하여 세션에 저장될 정보를 가져온다면 서비스를 재사용할 수 있습니다.
 
물론 이러한 단점으로 발생하는 서비스 중단을 해결하기 위해서 일부 In-Memory 데이터베이스에서는 Replication이라는 기능을 통해 failover를 지원합니다. 

아래 그림을 보시는 바와 같이 Master DB를 Slave DB에 복제함으로써 가용성을 높일 수 있습니다. 

만일 Master DB에 장애가 발생하여 사용할 수 없을 시에는 Slave DB를 Master DB로 승격시켜 서비스를 중단 없이 지속적으로 제공할 수 있습니다.

```

7. ![다운로드 (3)](https://user-images.githubusercontent.com/78199659/137419788-6f906b89-0214-4d6a-b8ce-18b900a91195.png)

# 세션 객체는 어떤 형태로 구성되어 있을까?

```

데이터베이스를 선정하기 전에 어떤 형태의 데이터가 저장되는지가 중요하다고 언급하였습니다.

그렇다면 우리가 저장해야 할 데이터인 세션 객체가 어떤 형태로 구성되어 있는지 알아야겠죠?

우선, 세션 객체에 대해서 간단히 알아봅시다.

```

1. ![다운로드 (4)](https://user-images.githubusercontent.com/78199659/137420042-91734fe9-44de-4a8d-bb33-b16d7f296d37.png)


```

세션 객체는 Key에 해당하는 SESSION ID와 이에 대응하는 Value로 구성됩니다. 

Value에는 세션 생성 시간, 마지막 접근 시간 및 User가 저장한 속성 등 이 Map 형태로 저장됩니다. (그림은 임의의 값으로 표현하였지만, 실제 저장되는 데이터 타입 및 값에 있어서 차이가 있을 수 있습니다.)

세션 객체가 저장되는 방식과 유사하게 Key-Value 형태로 데이터를 저장하는 데이터베이스가 있습니다. 

이를 Key-Value 데이터베이스 혹은 Key-Value Model NoSQL이라고 합니다.

이러한 데이터베이스의 특징은 저장구조가 Key-Value 형태로 단순하다는 점입니다. 

이로 인해 관계형 데이터베이스와 같이 복잡한 조회 연산을 지원하지 않지만, 단일 키 처리만을 지원하기 때문에 고속 읽기와 쓰기에 최적화된 경우가 많습니다. 

특히, 세션에 저장되는 데이터의 경우에는 대부분 비교적 간단한 연산을 통해 처리를 할 수 있습니다. 

이러한 점에서 Key-Value 형태의 데이터베이스가 세션 저장소로써 적합하다고 볼 수 있습니다.

그중에서도 세션 저장소로 가장 많이 사용되는 것이 바로 Redis와 Memcached입니다!

엄밀히 말하면 Memcached는 캐시 솔루션으로써 전원이 꺼지게 되면 데이터가 사라지기 때문에 영속성을 보장할 수 없다는 점에서 데이터베이스 혹은 저장소는 아닙니다. 

'Redis의 경우도 마찬가지 아닌가?'라고 생각하실 수 있으나, Redis는 AOF와 RDB 기능을 통해서 디스크에 데이터를 저장하여 영속성을 보장할 수 있습니다. 

세션의 경우, 이전 포스팅에 언급했다시피 영속성이 크게 영향을 미치지 않기 때문에 해당 논제에 대해서는 더 이상 언급하지 않겠습니다.

과연 두 인 메모리 솔루션 중에서 어떤 것을 사용해야 할까요?
 
먼저, 두 솔루션의 차이점부터 분석해보겠습니다.

```

# Redis Vs Memcached

```

Memcached와 Redis는 In-Memory 기반으로 동작한다는 점과, Key-Value 형태로 데이터를 저장한다는 점에서 공통적인 특성을 지니고 있습니다. 

이러한 특성은 두 저장소 모두 빠르게 데이터를 처리할 수 있다는 장점으로 이어집니다. 그렇다면 어떤 차이점을 가지고 있을까요?

첫 번째는 failover(장애 극복 기능)입니다. Redis의 경우, Replication을 지원하기 때문에 서버 하나에 장애가 발생하더라도 복제된 Slave 서버를 Master로 승격시켜서 서비스를 중단 없이 운영할 수 있도록 합니다.

하지만, Memcached의 경우에는 Replication을 지원하지 않습니다. 

대신에 서비스 중단을 최소화하기 위해서 'Consistent Hashing'이라는 알고리즘을 통해 여러 대의 Memcached 서버에 데이터를 분산 저장하여 관리하게 됩니다. 

Consistent Hashing으로 인하여 서버 1대가 장애가 발생하더라도, 나머지 노드에 있는 데이터들은 재배치할 필요 없이 장애가 발생한 노드의 데이터들만 손실되기 때문에 나머지 노드들은 지속적으로 운영이 가능합니다.

이러한 방식의 경우,  Memcached 서버의 숫자를 늘리게 되면 그 피해를 감소시킬 수 있습니다. 

예를 들어, 3대 중 1대에 장애가 발생하면, 약 33%의 데이터를 손실하지만, 4대 중 1대에서 장애가 발생한다면, 25%의 데이터만 손실됩니다. 

그러므로 노드가 많을수록 서비스 장애에 대한 피해는 줄어듭니다.

Memcached가 Replication을 지원하지 않기 때문에 이렇게 손실을 감안하고 운영을 하는 경우도 있지만, 각 노드에 BackUp 서버를 배치하여 직접 failover를 구현하고, 가용성을 보장할 수 있습니다. 

BackUp 노드를 만드는 방법은 MySQL BinLog를 이용하거나, Primary-Secondary 서버 각 2대의 서버에 데이터를 쓰고 관리하는 방법 혹은 Repcached라는 패치를 통하여 Replication을 구현하는 등 다양한 방법이 존재합니다. 

이렇듯 Redis와 Memcached의 경우, 각자의 방법으로 failover를 지원합니다. 다만 Redis의 경우 Replication을 솔루션 자체에서 지원을 하기 때문에 보다 더 쉽게 failover 기능을 구현할 수 있다는 장점이 있습니다.

```

1. ![다운로드 (5)](https://user-images.githubusercontent.com/78199659/137420321-0d3d9e0c-f8b4-4e04-8bd5-f058022647f4.png)

```

두 번째는 응답속도의 균일성에서 차이가 발생할 수 있습니다. 

Redis의 경우, 대규모 트래픽이 발생하면 Memcached에 비해 응답속도의 안정성이 떨어질 수 있습니다. 

이유는 Redis는 메모리 할당을 하는 데 있어서 jemalloc 알고리즘을 사용하여 매번 malloc과 free를 통하여 메모리를 할당하기 때문입니다. 

이는 메모리 단편화 문제를 발생시키고, 이러한 단편화 문제로 인하여 응답속도가 느려질 수 있기 때문입니다.


```

2. ![image](https://user-images.githubusercontent.com/78199659/137420374-a4117cbf-3d09-413b-adb1-5ab3d5a88408.png)

```

반면, Memcached의 경우 메모리 할당에 있어서 slab allocator를 사용하기 때문에 내부적으로 메모리 할당을 다시 하지 않고 관리할 수 있습니다. 

slab allocator에 대한 상세한 내용은 아래 링크를 확인하시면 더 세부적인 동작을 참고하실 수 있습니다.

http://jake.dothome.co.kr/slub/
 
이러한 결과, 응답속도가 일정한가에 대해서는 Memcached가 조금 더 좋은 성능을 보이는 듯합니다. 

이 또한 극단적인 예시이기 때문에 Redis의 응답속도는 절대적으로 불안하다고 생각하시면 안 됩니다! "대규모 트래픽이 들어왔을 때, Memcached보다 응답속도 안정성이 떨어질 수 있다." 정도로 이해하시면 될 것 같습니다.

```

```

세 번째는 Redis는 싱글 스레드로 동작하고, Memcached는 멀티 스레드로 동작을 한다는 점입니다. 

'Redis가 싱글 쓰레드로 설계되었기 때문에 병목현상이 발생하지 않을까?'라는 생각을 하실 수 있습니다. 

Redis 공식 홈페이지(https://redis.io/topics/faq)에도 이에 대한 FAQ를 진행하여 게시해놓은 걸 보면, 많은 사람들이 이 점에 대해 의문을 갖는 것을 알 수 있었습니다.
 
이에 대한 답변을 정리해보자면 우선, Redis는 데이터가 메모리에서 저장되고, 관리되기 때문에 CPU가 Redis에서 병목현상을 발생시키는 빈도가 적다고 명시되어 있습니다. 

이에 따라 Redis가 제시한 벤치마크의 경우, 평균적으로 Linux 환경에서 Redis는 파이프라인을 사용하면 초당 약 100만 건의 요청을 전달 가능하다고 제시하였습니다. 

그러므로 응용 프로그램이 O(N) 혹은 O(log(N)) 정도의 연산을 한다면 CPU에 큰 부담을 주는 것은 아니라고 명시하였습니다. 

그럼에도 불구하고 CPU를 더 많이 사용하기 위해서는 Replication과 Sharding을 활용하여 Redis의 인스턴스를 증가시키고, 각 인스턴스로 데이터를 분산시켜서 사용하면 가능합니다.

얼핏 보면, 'Memcached가 멀티스레드로 동작하기 때문에 훨씬 좋은 성능을 내는 것 아닌가?'라는 생각을 하실 수 있습니다. 

그러나 실제 수행 속도에 있어서는 큰 차이를 느낄 수 없습니다.

왜냐하면, Memcached는 명령어를 파싱 하는 것까지는 멀티 스레드 형태로 수행되지만, 실제 데이터에 접근하는 연산들의 경우에는 Golbal cache lock으로 인하여 서버 전체의 캐시에 대해 잠금 상태가 되기 때문입니다. 

이로 인해 Memcached는 멀티 스레드로 구성되었음에도 불구하고, 데이터 연산에 있어서는 싱글 스레드처럼 동기화되어서 동작하게 됩니다.

여기까지 보았을 때, Redis와 Memcached 각각 다른 방식으로 캐시를 처리하고 있음을 알 수 있습니다. 

두 솔루션 모두 장점과 단점을 지니고 있지만, 위에서 보았듯이 사용할 수 없을 정도로 치명적인 단점을 갖는 솔루션은 없습니다.
 
그렇다면 결정적으로 이 두 솔루션의 Performance를 비교한 결과를 통해 어떤 솔루션을 사용하는 것이 나을지 알아보겠습니다.

```
# Performance

```

Memcached의 경우 Write 연산에 있어서, Redis 보다 좋은 성능을 보임을 알 수 있습니다. 

하지만, Read 연산에 있어서는 Redis가 더 좋은 성능을 보입니다.

이를 비교해보았을 때, Redis가 세션을 저장하는 데 더 적합하다는 점을 알 수 있습니다. 

세션 관련 작업의 경우, 쓰기 연산보다는 읽기 연산이 압도적으로 높은 작업이기 때문에 읽기 성능이 더 좋은 Redis를 사용하는 것이 더 효율적임을 알 수 있습니다. 

마지막으로 Redis가 Read/Write에 있어서 메모리를 더 효율적으로 사용하는 것을 볼 수 있습니다.

위 결과를 종합한 결과, 쓰기 성능에서는 Memcached가 앞서지만 메모리 사용 효율과 처리속도를 모두 고려한다면 Redis가 상대적으로 더 나은 선택임을 알 수 있습니다.

```

