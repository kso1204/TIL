# 클린 아키텍쳐

1. 설계와 아키텍쳐란?

- 설계 = 아키텍처
- 목표? 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화
- 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다
- 빨리 가는 유일한 방법은 제대로 가는 것이다.
- TDD를 사용할 때와 사용하지 않았을 때의 속도 차이는 TDD를 사용할 때가 더 빠르다

2. 두 가지 가치에 대한 이야기

- 행위와 구조
- 첫 번째 가치 : 행위 
- 두 번째 가치 : 소프트웨어(Soft + ware) -> 부드러운 제품
- 부드럽다 = 변경하기 쉽다 = 변경사항을 간단하고 쉽게 적용할 수 있어야 한다
- 이러한 변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야하며, 변경사항의 형태와는 관련이 없어야 한다.
- 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

3. 패러다임 개요

- 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체지향 프로그래밍 : 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍 : 할당문에 대해 규칙을 부과한다.
- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.
 

4. 구조적 프로그래밍

- 구조적 프로그래밍이 오늘까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.
- 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유기도 하다.
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.

5. 객체 지향 프로그래밍

- 객체 지향 프로그래밍이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.

6. 함수형 프로그래밍

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 소프트웨어의 핵심은 순차, 분기, 반복, 참조로 구성된다.

7. SRP: 단일 책임 원칙

- 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
- 해당 변경을 요청하는 한 명 이상의 사람들을 액터라고 한다.
- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 서로 다른 액터가 의존하는 코드를 서로 분리하라
- 원칙을 위반하는 징후 1: 우발정 중복, 2: 병합

8. OCP: 개방-폐쇄 원칙 *** 그림 많음 책 참조

- 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이 이 원칙의 요지다
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
- 변경되는 코드의 양이 가능한 한 최소화 되게 하려면?
- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.
- P75 재무 데이터 -> 재무 분석기 -> 보고서용 재무 데이터를
- 보고서용 재무 데이터 1. 보고서를 웹에 표시, 2. 보고서를 프린터로 출력
- 여기서 얻을 수 있는 가장 중요한 영감은 보고서 생성이 두 개의 책임으로 분리된다는 사실이다.
- 하나는 보고서용 데이터를 계산하는 책임이며, 나머지 하나는 이 데이터를 웹으로 보여주거나 종이로 프린트하기에 적합한 형태로 표현하는 책임이다.
- 이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.
- 또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.
- 이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 컴포넌트 단위로 구분해야 한다.
- 컴포넌트는 컨트롤러, 인터랙트, 데이터베이스, 프레젠터, 뷰 등..
- <'I'>는 인터페이스이며 <'DS'>로 표시된 클래스는 데이터 구조다.
- 화살표가 열려 있다면 사용관계이며, 닫혀 있다면 구현(implements) 관계 또는 상속(inheritance) 관계다
- 여기에서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다.
- 예를 들어 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다.
- 여기에서 주목해야 할 또 다른점은 이중선은 화살표와 오직 한 방향으로만 교차한다는 사실이다.
- 모든 컴포넌트 관계는 단 방향으로 이루어진다는 뜻이다. 이들 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
- A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.
- 이 예제의 경우 Presenter에서 발생한 변경으로부터 Controller를 보호하고자 한다.
- 그리고 View에서 발생한 변경으로부터 Presenter를 보호하고자 한다.
- Interactor는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다.
- Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다.
- Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.
- 왜 Interactor가 이처럼 특별한 위치를 차지해야만 하는가? 그 이유는 바로 Interator가 업무 규칙을 포함하기 때문이다.
- Interactor는 애플리케이션에서 가장 높은 수준의 정책을 포함한다.
- Interactor 이외의 컴포넌트는 모두 주변적인 문제를 처리한다. 가장 중요한 문제는 Interactor가 담당한다.
- Interactor 입장에서는 Controller가 부수적이지만, Controller는 Presenter와 View에 비해서는 중심적인 문제를 담당한다.
- 보호의 계층구조가 '수준(level)'이라는 개념을 바탕으로 어떻게 생성되는지 주목하자.
- Interactor는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다. View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다.
- 이것이 바로 OCP가 동작하는 방식이다.
- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 로직화한다.
- 컴포넌트 계층을 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- 방향성 제어
- 예를 들어 FinacialDataGateway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다.
- FinancialDataGateway 인터페이스가 없었다면, 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다.
- 정보 은닉
- FinancialReportRequests 인터페이스는 방향성 제어와는 다른 목적을 가진다.
- 이 인터페이스는 FinancialReportCcontorller가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.
- 만약 이 인터페이스가 없었다면, Controller는 FinancialEntities에 대해 추이 종속성을 가지게 된다.
- 추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.
- 이 원칙은 인터페이스 분리 원칙(ISP)과 공통 재사용 원칙(CRP)을 설명할 때 다시 한번 설명한다.
- 다시 말해서 Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만,
- 반대로 Interactor에서 발생한 변경으로부터 Controller가 보호되기를 바란다.
- 이를 위해 Interactor 내부를 은닉한다.
- OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.
- 추이 종속성 - 클래스 A가 클래스 B에 의존하고, 클래스 B가 클래스 C에 의존한다면 클래스 A는 클래스 C에 의존한다. 만약 클래스 의존성이 순환적이라면 모든 클래스가 서로 의존하게 되는 문제가 있다.

9. LSP: 리스코프 치환 원칙

- 하위 타입에 관한 유명한 원칙. 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
- S타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.
- License라는 클래스가 이싿고 해보자, 이 클래스는 calcFee()라는 메서드를 가지며, Billing 애플리케이션에서 이 메시더를 호출한다.
- License에는 PersonalLicense와 BusinessLicense라는 두 가지 '하위 타입'이 존재한다. 이들 두 하위 타입은 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다.
- 이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하기 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.

10. ISP: 인터페이스 분리 법칙

- 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
- 다수의 사용자가 OPS 클래스의 오퍼레이션을 사용한다고 가정하자.
- User1은 OPS 클래스의 OP1을, 
- User2는 OPS 클래스의 OP2를,
- User3은 OPS 클래스의 OP3을..
- User1에서는 OPS 클래스의 OP2와 OP3을 전혀 사용하지 않음에도 User1의 소스 코드는 이 두 메서드에 의존하게 된다.
- 이러한 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.

11. DIP: 의존성 역전 원칙

- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.
- '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
- 자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다.
- 구체적인 대상에는 절대로 의존해서는 안 된다.
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다.
- 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다.
- 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다.
- 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.
- 이 원칙에서 전달하는 내용은 다음과 같다.
- 변동성이 큰 구체 클래스를 참조하지 말라 - 대신 추상 인터페이스를 참조하라.
- 이 규칙은 언어가 정적 타입이든 동적 타입이든 관계없이 모두 적용된다. 또한 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.
- 변동성이 큰 구체 클래스로부터 파생하지 말라 - 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.
- 따라서 상속은 아주 신중하게 사용해야 한다. 동적 타입언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함이 없다.
- 구체 함수를 오버라이드 하지 말라 - 대체로 구체 함수는 소스 코드 의존성을 필요로 한다.
- 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
- 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에게 각자의 용도에 맞게 구현해야 한다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
- 추상팩토리 P94
- Application은 service 인터페이스를 통해 ConcreteImpl을 사용하지만, Application에서는 어떤 식으로든 ConcreteImpl의 인스턴스를 생성해야 한다.
- ConcreteImpl에 대해 소스 코드 의존성을 만들지 않으면서 이 목적을 이루기 위해 Application은 ServiceFactory 인터페이스의 makeSve 메소드를 호출한다.
- 이 메서드는 ServiceFactory로부터 파생된 ServiceFactoryImpl에서 구현된다.
- 그리고 ServcieFactoryImpl 구현체가 ConcrteImpl의 인스턴스를 생성한 후 Service 타입으로 반환한다.

12. 컴포넌트

- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

13. 컴포넌트 응집도

- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙
- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야한다.
- 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라, 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라
- 이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다.
- 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
- 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
- CRP는 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.
- 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.
- 필요하지 않은 것에 의존하지 말라
- REP와 CCP는 포함 원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.
- CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.
- 뛰어난 아키텍트라면 이 원칙들이 균형을 이루는 방법을 찾아야 한다.
- REP - 재사용성을 위한 그룹
- CRP - 불필요한 릴리스를 피하기 위해 분리하기
- CCP - 유지보수성을 위한 그룹

14. 컴포넌트 결합

- ADP: 의존성 비순환 법칙
- 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.
- 주 단위 빌드
- 주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다.
- 프로그램이 커질수록 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.
- 순환 의존성 제거하기
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
- 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.
- 의존성 구조에 순환이 있어서는 안 된다.
- 컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 복구하는 방법
- 의존성 역전 원칙(DIP)을 사용한다.
- P121
- User가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다.
- 그리고 이 인터페이스는 Entities에 위치시키고, Authroize에서는 이 인터페이스를 상속받는다.
- 이렇게 하면 Entities와 Authorize 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.
- 또는 Entites와 Authorize가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.
- 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.
- 오히려 컴포넌트 의존성 다이어그램은 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
- 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
- P126(152) 안전성과 불안전성, 독립, 책임성
- 안전성 지표
- 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법
- Fan-in 안으로 들어오는 의존성, Fan-out 바깥으로 나가는 의존성
- I 불안전성 I = Fanout/(fanin+fan-out) 이 지표는 0, 1범위의 값을 가진다.
- 0이면 최고 안전, I=1이면 최고 불안정
- SAP: 안정된 추상화 원칙 - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
- 고수준 정책을 어디에 위치 시켜야 하는가?
- 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
- 해답은 개방 폐쇄 원칙에서 찾을 수 있다.
- OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있을 뿐만 아니라 바람직한 방식이라고 말한다.
- 어떤 클래스가 이 원칙을 준수하는가? 바로 추상 클래스다.
- 안정된 추상화 원칙
- 안전성과 추상화 정도 사이의 관계를 정의한다. 
- 이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.
- 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.
- 따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
- 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.
- SAP와 ADP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다.
- 실제로 SDP에서는 의존성이 반드시 안전성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다.
- 따라서 의존성은 추상화의 방향으로 향하게 된다.

15. 아키텍처란?

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.
- 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.
- 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.

16. 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

- 유스케이스
- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
- 만약 시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 한다.
- 장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것이다.

- 운영
- 시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다.
- 만약 시스템에서 수 밀리초 안에 3차원의 빅데이터 테이블에 질의해야 한다면, 반드시 이러한 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야 한다.

- 개발
- 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

- 배포
- 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 내버려 두지 않는다.
- 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.

17. 경계:선 긋기

- 경계는 변경의 축이 있는 지점에 그어진다.
- 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다.
- 단일 책임 원칙은 어디에 경계를 그어야 할지를 알려준다.
- 소프트웨어 아키텍처에서 경계션을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다.
- 의존성 화살표는 저수준 세부사항에서 고수준 추상화를 향하도록 배치한다.

18. 경계 해부학

- 제어흐름은 경계를 횡단할 때 저수준에서 고수준으로 향한다.

19. 정책과 수준

- 이 장에서 설명한 정책에 대한 논의는 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.

20. 업무 규칙

- 핵심 업무 규칙 - 대출에 N%의 이자를 부과한다.
- 핵심 업무 데이터 - 대출에는 대출 잔액, 이자율, 지급일정이 필요하다.
- 엔티티 - 핵심 규칙과 핵심 업무 데이터를 객체로 만든 것?
- 엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.
- 엔티티 객체는 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근할 수 있다.
- 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.

```
Loan

- priciple
- rate
- period

----------

+ makePayment()
+ applyInterest()
+ chargeLateFee()

세 가지의 핵심 업무 데이터와, 데이터와 관련된 세 가지 핵심 업무 규칙

```

- 엔티티는 순전히 업무에 대한 것이며, 이외의 것은 없다.
- 유스케이스 - 은행에서 대출 담당자가 신청자의 신상정보를 수집하여 검증한 후, 신청자의 신용도가 500보다 낮다면 대출 견적을 제공하지 않기로 결정한 것
- 유스케이스는 사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.
- 엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명한다.

- P228
- 마지막 줄에서 customer를 언급한다는 점에 주목하자. 이는 Customer 엔티티에 대한 참조이며, 은행과 고객의 관계를 결정짓는 핵심 업무 규칙은 바로 이 Customer 엔티티에 포함된다.
- 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담는다. 엔티티가 어떻게 춤을 출지는 유스케이스가 제어하는 것이다.
- 주목할 또 다른 사실은 인터페이스로 들어오는 데이터와 인터페이스에서 되돌려주는 데이터를 형식 없이 명시한다는 점만 빼면, 유스케이스는 사용자 인터페이스를 기술하지 않는다는 것이다.
- 유스케이스만 봐서는 이 애플리케이션이 웹을 통해 전달되는지, 리치 클라이언트인지, 콘솔 기반인지, 아니면 순수한 서비스인지를 구분하기란 불가능하다.
- 이 점은 매우 중요하다. 유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다.
- 유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치한다.
- 엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있다.
- 유스케이스는 엔티티에 의존한다. 엔티티는 유스케이스에 의존하지 않는다.
- 업무 규칙은 소프트웨어 시스템이 존재하는 이유다. 업무 규칙은 핵심적인 기능이다. 업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반한다. 업무 규칙은 집안의 가보다
- 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다.
- 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.

21. 소리치는 아키텍처

- 좋은 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합은 분리시킨다.
- 프레임워크는 매우 강력하고 상당히 유용할 수 있다.
- 그러나 프레임워크는 도구일 뿐, 삶의 방식은 아니다.
- 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발하라.
- 아키텍처가 유스케이스를 최우선으로 한다면, 그리고 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.
- 당신이 헬스 케어 시스템을 구축하고 있다면, 새로운 프로그래머가 소스 저장소를 봤을 때 첫 인상은 "오, 헬스 케어 시스템이군"이어야만 한다.
- 새로 합류한 프로그래머는 시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야 한다.
- 언젠가 이들은 당신을 찾아와서 이렇게 말할 것이다.
- "모델처럼 보이는 것들을 확인했습니다. 그런데 뷰와 컨트롤러는 어디에 있죠?
- "아, 그것은 세부사항이므로 당장은 고려할 필요가 없습니다. 나중에 결정할 겁니다."

22. 클린 아키텍처

- 관심사의 분리
- 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성한다.
- 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자의 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.
- 프레임워크 독립성 - 아키텍처는 프레임워크의 존재 여부에 의존하지 않는다. 이를 통해 이러한 프레임워크를 도구로 사용할 수 있으며, 프레임워크가 지닌 제약사항안으로 시스템을 욱여 넣도록 강제하지 않는다.
- 테스트 용이성 - 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트할 수 있다.
- UI 독립성 - 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
- 예를 들어 업무 규칙을 변경하지 않은 채 웹 UI를 콘솔 UI로 대체할 수 있다.
- 데이터베이스 독립성 - 오라클이나 MS SQL 서버를 몽고DB, 빅테이블, 카우치DB 등으로 교체할 수 있다. 업무 규칙은 데이터베이스에 결합되지 않는다.
- 모든 외부 에이전시에 대한 독립성 - 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.
- P242 의존성 규칙
- 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
- 엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다.
- 유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다.
- 인터페이스 어댑터계층은 일련의 어댑터들로 구성된다
- 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.
- 이 계층은, 예를들어 GUI의 MVC 아키텍처를 모두 포함한다. 프레젠터, 뷰, 컨트롤러는 모두 인터페이스 어댑터 계층에 속한다.
- 프레임워크와 드라이버는 모든 세부사항이 위치하는 곳이다. 웹이나 데이터베이스 같은 것들을 외부에 위치시켜서 피해를 최소화한다.
- 원은 네 개 보다 더 많이 필요할 수 있지만, 어떠한 경우에도 의존성 규칙은 적용된다.
- 소스 코드 의존성은 항상 안쪽을 향한다.
- 안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다.
- 가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.
- 경계 횡단하기 ****
- 그림 22.1의 우측 하단 다이어그램
- 컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다.
- 우선 제어흐름에 주목해보자.
- 컨트롤러에서 시작해서 유스케이스를 지난 후, 프레젠터에서 실행되면서 마무리된다.
- 다음으로 소스코드 의존성도 주목해보자
- 각 의존성은 유스케이스를 향해 안쪽을 가리킨다.
- 이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우***, 대체로 의존성 역전 원칙을 사용하여 해결한다.
- 예를 들어 자바 같은 언어에서는 인터페이스와 상속 관계를 적절하게 배치함으로써, 제어흐름이 경계를 가로지르는 바로 그 지점에서 소스 코드 의존성을 제어흐름과는 반대가 되게 만들 수 있다.
- 별다른 조치 없이 제어흐름을 따라 구현하면 안쪽 원의 코드가 바깥쪽 원의 코드를 호출하게 된다. 바로 이 지점에서 소스 코드 의존성을 역전시켜서, (제어흐름과는 반대로) 바깥쪽 원의 코드가 안쪽 원의 코드를 호출하게 만드는 것이다.

```

프레젠터 -> 유스케이스 출력 포트(I) <- 유스케이스 인터랙터 -> 유스케이스 입력 포트(I) <- 컨트롤러

제어흐름 컨트롤러 -> 유스케이스 인터랙터 -> 프레젠터

```

- P246 전형적인 시나리오

```

웹 서버는 사용자로부터 입력 데이터를 모아서 좌측 상단의 Controller로 전달한다.

Controller는 데이터를 평범한 자바 객체(POJO)로 묶은 후, InputBoundary 인터페이스를 통해 UseCaseInteractor로 전달한다. 

UsecaseInterator는 이 데이터를 해석해서 Entities가 어떻게 춤출지를 제어하는 데 사용한다.

UseCaseInteractorsms DataAccessInterface를 사용하여 Entities가 사용할 데이터를 데이터베이스에서 불러와서 메모리로 로드한다.

Entities가 완성되면, UseCaseInteractor는 Entities로부터 데이터를 모아서 또 다른 평범한 자바 객체인 OutputData를 구성한다.

그러고 나서 OutputData는 OutputBoundary 인터페이스를 통해 Presenter로 전달된다.

Presenter가 맡은 역할은 OutputData를 ViewModel과 같이 화면에 출력할 수 있는 형식으로 재구성하는 일이다.

ViewModel 또한 평범한 자바 객체다.

ViewModel은 주로 문자열과 플래그로 구성되며, View에서는 이 데이터를 화면에 출력한다.

OutputData에서는 Date 객체를 포함할 수 있는 반면, Presenter는 ViewModel을 로드할 떄 Date 객체를 사용자가 보기에 적절한 형식의 문자열로 변환한다.

이 변환은 Currency 객체나 다른 업무 관련 데이터 모두에 똑같이 적용된다. Button과 MenuItem의 이름은 ViewModel에 위치하며,

해당 Button과 MenuItem을 비활성화할지를 알려주는 플래그 또한 ViewModel에 위치한다.

따라서 ViewModel에서 HTML 페이지로 데이터를 옮기는 일을 빼면, View에서 해야 할 일은 거의 남아 있지 않다.

의존성의 방향에 주목해라. 모든 의존성은 경계선을 안쪽으로 가로지르며, 따라서 의존성 규칙을 준수한다.

이상의 간단한 규칙들을 준수하는 일은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어줄 것이다.

소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.

데이터베이스나 웹 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할 수 있다.

```

23. 프레젠터와 험블 객체 ****

- 험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- 아이디어는 매우 단순하다. 행위들을 두 개의 모듈 또는 클래스로 나눈다.
- 이들 모듈 중 하나가 험블이다.
- 가장 기본적인 본질은 남기고, 테스트하기 어려운 행위를 모두 햄블 객체로 옮긴다.
- 나머지 모듈에는 험블객체에 속하지 않은, 테스트하기 쉬운 행위를 모두 옮긴다.
- 화면에 표시되고 애플리케이션에서 어느 정도 제어할 수 있는 요소라면 무조건 뷰 모델 내부에 문자열, 불, 또는 열겨형 형태로 표현한다.
- 뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없다. 따라서 뷰는 보잘 것 없다.
- 테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다.
- 험블 객체 패턴이 좋은 예인데, 행위를 테스트 하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍쳐 경계가 정의되기 때문이다.
- 프레젠터와 뷰 사이의 경계는 이러한 경계 중 하나이며, 이 밖에도 수많은 경계가 존재한다.
- 유스케이스 인터랙트와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치한다.
- 이 게이트웨이는 다형적 인터페이스로, 애플리케이션이 데이터베이스에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메서드를 포함한다.
- 예를 들어 애플리케이션에서 어제 로그인한 모든 사용자의 성을 알 수 있어야 한다면,
- UserGateway 인터페이스는 getLastNamesOfUserWhoLoggedInAfter라는 메서드를 제공할 것이고, 이 메서드는 날짜를 인자로 받아서 사용자 성들을 담은 목록을 반환할 것이다.
- 다시 한번 말하지만 유스케이스 계층은 SQL을 허용하지 않는다.
- 따라서 유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다.
- 그리고 인터페이스의 구현체는 데이터베이스 계층에 위치한다.
- 이 구현체는 험블 객체다.
- 구현체에서 직접 SQL을 사용하거나 데이터베이스에 대한 임의의 인터페이스를 통해 게이트웨이의 메서드에서 필요한 데이터에 접근한다.
- 이와 달리 인터랙트는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다.
- 따라서 테스트하기 쉬운데, 게이트웨이는 스텁이나 테스트 더블로 적당히 교체할 수 있기 때문이다.
- 테스트 더블 = 테스트 대역 = 테스트를 용이하게 하기 위해 진짜 객체를 대체하는 객체, 스텁(Stub), 모의(Mock), 가짜(Fake) 객체를 묶어서 지칭할 때 사용한다.
- 데이터 매퍼와, 서비스 리스너.. 읽어보기

24. 부분적 경계

- 아키텍처 경계를 부분적으로 구현하는 간단한 방법 세 가지
- 마지막 단계 건너뛰기
- 일차원 경계
- 퍼사드

25. 계층과 경계

- 시스템이 발전함에 따라 주의를 기울여야 한다.
- 경계가 필요할 수도 있는 부분에 주목하고, 경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관찰해야 한다.
- 첫 조짐이 보이는 시점이 되면, 해당 경계를 구현하는 비용과 무시할 떄 감수할 비용을 가늠해 본다.

26. 메인 컴포넌트

- 메인 컴포넌트 = 모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며, 관리한다.
- 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다.
- 메인은 시스템의 초기 진입점이다.
- 운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.
- 메인은 모든 팩토리와 전략, 그리고 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할을 맡는다.
- 메인을 애플리케이션의 플러그인이라고 생각하자.
- 메인은 초기 조건과 설정을 구성하고, 외부 자우너을 모두 수집한 후, 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.

27. '크고 작은 모든' 서비스들

- 시스템 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.
- 시스템을 서비스들로 분리하면 얻게 되는 이점은 서비스 사이의 결합이 확실히 분리된다는 것
- 전담팀이 서비스를 소유하고 운영한다는 점
- 데브옵스 전략의 일환으로 전단팀에서 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 질 수 있다. 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.

28. 테스트 경계

- 테스트는 시스템의 일부이며, 아키텍처에도 관여한다.
- 테스트는 태생적으로 의존성 규칙을 따른다.
- 소프트웨어 설계의 첫 번째 규칙
- 변동성이 있는 것에 의존하지 말라. GUI는 변동성이 크다. GUI로 시스템을 조작하는 테스트 스위트는 분명 깨지기 쉽다.
- 따라서 시스템과 테스트를 설계할 때, GUI를 사용하지 않고 업무 규칙을 테스트할 수 있게 해야 한다.
- 이 목표를 달성하려면 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만들면 된다.
- 이 API는 사용자 인터페이스가 사용하는 인터랙터와 인터페이스 어댑터의 상위 집합이 될 것이다.
- 테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.
- 단순히 테스트를 UI에서 분리하는 것만이 아닌, 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는 게 목표다.
- 테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는 데 있다.
- 이렇게 만들면 상용 코드를 리팩토링하거나 진화시키더라도 테스트에는 전혀 영향을 주지 않는다.
- 또한 테스트를 리팩터링하거나 진화시킬 때도 상용 코드에는 전혀 영향을 주지 않는다.
- 이처럼 따로따로 진화할 수 있다는 점은 필수적인데, 시간이 지날수록
- 테스트는 계속해서 더 구체적이고 더 특화된 형태로 변할 것이고,
- 반대로 상용코드는 더 추상적이고 더 범용적인 형태로 변할 것이기 때문이다.

29. 클린 임베디드 아키텍처

- 소프트웨어를 구축하는 세 가지 활동
- 먼저 동작하게 만들어라 
- 그리고 올바르게 만들어라 (코드를 리팩토링해서 당신을 포함한 나머지 사람들이 이해할 수 있게 만들고, 요구가 변경되거나 요구를 더 잘 이해하게 되었을 때 코드를 개선할 수 있게 만들어라)
- 그리고 빠르게 만들어라 (코드를 리팩토링해서 '요구되는' 성능을 만족 시켜라)

30. 데이터베이스는 세부사항이다

- 데이터는 중요하다. 데이터베이스는 세부사항이다.

31. 웹은 세부사항이다

- 웹은 GUI다.
- 웹은 입출력 장치다.

32. 프레임워크는 세부사항이다

- 프레임워크와 결혼하지 말라
- 프레임워크가 핵심 코드 안으로 들어오지 못하게 하라. 대신 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고, 의존성 규칙을 준수하라
- 예를 들어 당신은 스프링을 좋아할 것이다.
- 스프링은 훌륭한 의존성 주입 프로그램이다.
- 아마도 의존성을 연결할 때 스프링의 auto-wiring 기능을 사용할 것이다.
- 이 방법도 괜찮지만, @authwired 어노테이션이 업무 객체 도처에 산재해서는 안 된다.
- 업무 객체는 절대로 스프링에 대해 알아서는 안 된다.
- 업무 객체보다는 메인 컴포넌트에서 스프링을 사용해서 의존성을 주입하는 편이 낫다.

33. 사례 연구: 비디오 판매

- 그림 33.2의 아키텍쳐 다이어그램은 두 가지 서로 다른 차원의 분리 개념을 포함하고 있다.
- 하나는 단일 책임 원칙에 기반한 액터의 분리이며, 두 번째는 의존성 규칙이다.
- 이 두 차원은 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있다.
- 서로 다른 이유라는 것은 액터와 관련이 있으며, 서로 다른 속도라는 것은 정책 수준과 관련이 있다.

34. 빠져 있는 장 

- 계층 기반 패키지
- 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다. (수평)
- 기능 기반 패키지
- 서로 연관된 기능, 도메인 개념에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다. (수직)
- 포트와 어댑터
- '내부'(도메인)와 '외부'(인프라)
- '내부' 영역은 도메인 개념을 모두 포함하는 반면, '외부' 영역은 외부세계와의 상호작용을 포함한다.
- 주요 규칙은 '외부'가 '내부'에 의존하며, 절대 그 반대로는 안 된다는 점이다.
- 컴포넌트 기반 패키지
- 컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경 내부에 존재한다.
- 컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직 한 곳, ordersComponent만 둘러보면 된다는 점이다.