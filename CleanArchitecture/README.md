# 클린 아키텍쳐

1. 설계와 아키텍쳐란?

- 설계 = 아키텍처
- 목표? 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화
- 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다
- 빨리 가는 유일한 방법은 제대로 가는 것이다.
- TDD를 사용할 때와 사용하지 않았을 때의 속도 차이는 TDD를 사용할 때가 더 빠르다

2. 두 가지 가치에 대한 이야기

- 행위와 구조
- 첫 번째 가치 : 행위 
- 두 번째 가치 : 소프트웨어(Soft + ware) -> 부드러운 제품
- 부드럽다 = 변경하기 쉽다 = 변경사항을 간단하고 쉽게 적용할 수 있어야 한다
- 이러한 변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야하며, 변경사항의 형태와는 관련이 없어야 한다.
- 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

3. 패러다임 개요

- 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체지향 프로그래밍 : 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍 : 할당문에 대해 규칙을 부과한다.
- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.
 

4. 구조적 프로그래밍

- 구조적 프로그래밍이 오늘까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.
- 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유기도 하다.
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.

5. 객체 지향 프로그래밍

- 객체 지향 프로그래밍이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.

6. 함수형 프로그래밍

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
- 소프트웨어의 핵심은 순차, 분기, 반복, 참조로 구성된다.

7. SRP: 단일 책임 원칙

- 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
- 해당 변경을 요청하는 한 명 이상의 사람들을 액터라고 한다.
- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 서로 다른 액터가 의존하는 코드를 서로 분리하라
- 원칙을 위반하는 징후 1: 우발정 중복, 2: 병합

8. OCP: 개방-폐쇄 원칙 *** 그림 많음 책 참조

- 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이 이 원칙의 요지다
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
- 변경되는 코드의 양이 가능한 한 최소화 되게 하려면?
- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙 SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙 DIP) 변경량을 최소화할 수 있다.
- P75 재무 데이터 -> 재무 분석기 -> 보고서용 재무 데이터를
- 보고서용 재무 데이터 1. 보고서를 웹에 표시, 2. 보고서를 프린터로 출력
- 여기서 얻을 수 있는 가장 중요한 영감은 보고서 생성이 두 개의 책임으로 분리된다는 사실이다.
- 하나는 보고서용 데이터를 계산하는 책임이며, 나머지 하나는 이 데이터를 웹으로 보여주거나 종이로 프린트하기에 적합한 형태로 표현하는 책임이다.
- 이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.
- 또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.
- 이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 컴포넌트 단위로 구분해야 한다.
- 컴포넌트는 컨트롤러, 인터랙트, 데이터베이스, 프레젠터, 뷰 등..
- <I>는 인터페이스이며 <DS>로 표시된 클래스는 데이터 구조다.
- 화살표가 열려 있다면 사용관계이며, 닫혀 있다면 구현(implements) 관계 또는 상속(inheritance) 관계다
- 여기에서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다.
- 예를 들어 화살표가 A 클래스에서 B 클래스로 향한다면, A 클래스에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다.
- 여기에서 주목해야 할 또 다른점은 이중선은 화살표와 오직 한 방향으로만 교차한다는 사실이다.
- 모든 컴포넌트 관계는 단 방향으로 이루어진다는 뜻이다. 이들 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.
- A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.
- 이 예제의 경우 Presenter에서 발생한 변경으로부터 Controller를 보호하고자 한다.
- 그리고 View에서 발생한 변경으로부터 Presenter를 보호하고자 한다.
- Interactor는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다.
- Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다.
- Database, controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.
- 왜 Interactor가 이처럼 특별한 위치를 차지해야만 하는가? 그 이유는 바로 Interator가 업무 규칙을 포함하기 때문이다.
- Interactor는 애플리케이션에서 가장 높은 수준의 정책을 포함한다.
- Interactor 이외의 컴포넌트는 모두 주변적인 문제를 처리한다. 가장 중요한 문제는 Interactor가 담당한다.
- Interactor 입장에서는 Controller가 부수적이지만, Controller는 Presenter와 View에 비해서는 중심적인 문제를 담당한다.
- 보호의 계층구조가 '수준(level)'이라는 개념을 바탕으로 어떻게 생성되는지 주목하자.
- Interactor는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다. View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다.
- 이것이 바로 OCP가 동작하는 방식이다.
- 아키텍트는 기능으 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 로직화한다.
- 컴포넌트 계층을 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- 방향성 제어
- 예를 들어 FinacialDataGateway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다.
- FinancialDataGateway 인터페이스가 없었다면, 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다.
- 정보 은닉
- FinancialReportRequests 인터페이스는 방향성 제어와는 다른 목적을 가진다.
- 이 인터페이스는 FinancialReportCcontorller가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.
- 만약 이 인터페이스가 없었다면, Controller는 FinancialEntities에 대해 추이 종속성을 가지게 된다.
- 추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.
- 이 원칙은 인터페이스 분리 원칙(ISP)과 공통 재사용 원칙(CRP)을 설명할 때 다시 한번 설명한다.
- 다시 말해서 Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만,
- 반대로 Interactor에서 발생한 변경으로부터 Controller가 보호되기를 바란다.
- 이를 위해 Interactor 내부를 은닉한다.
- OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.
- 추이 종속성 - 클래스 A가 클래스 B에 의존하고, 클래스 B가 클래스 C에 의존한다면 클래스 A는 클래스 C에 의존한다. 만약 클래스 의존성이 순환적이라면 모든 클래스가 서로 의존하게 되는 문제가 있다.

9. LSP: 리스코프 치환 원칙

- 하위 타입에 관한 유명한 원칙. 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.

10. ISP: 인터페이스 분리 법칙

- 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

11. DIP: 의존성 역전 원칙

- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

12. 컴포넌트

13. 컴포넌트 응집도

14. 컴포넌트 결합

15. 아키텍처란?

16. 독립성

17. 경계:선 긋기

18. 경계 해부학

19. 정책과 수준

20. 업무 규칙

21. 소리치는 아키텍처

22. 클린 아키텍처

23. 프레젠터와 험블 객체

24. 부분적 경계

25. 계층과 경계

26. 메인 컴포넌트

27. '크고 작은 모든' 서비스들

28. 테스트 경계

29. 클린 임베디드 아키텍처

30. 데이터베이스는 세부사항이다

31. 웹은 세부사항이다

32. 프레임워크는 세부사항이다

33. 사례 연구: 비디오 판매

34. 빠져 있는 장 