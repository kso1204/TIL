# 리팩토링

1. 리팩터링: 첫 번째 예시

- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.
- 리팩터링의 첫 단계는 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들 부터 마련해야 한다.
- 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.
- 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
- 리팩터링의 저자는 함수의 반환 값에 항상 result라는 이름을 썼다. 그러면 그 변수의 역할을 쉽게 알 수 있다고..
- 함수를 만들고 그 함수를 인라인해서 사용한다?
- P48
- volumeCredits 변수를 제거하는 작업의 단계
- 반복문 쪼개기로 변수 값을 누적시키는 부분을 분리한다.
- 문장 슬라이드하기로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다
- 함수 추출하기로 적립 포인트 계산 부분을 별도 함수로 추출한다.
- 변수 인라인하기로 volumeCredits 변수를 제거한다.
- 여기서 궁금한건? totalVolumeCredits()에 invoice를 넣어주지 않아도 되는가..?

```

let volumeCredits = 0;

for (let perf of invoice.perfomances) {
    volumeCredits += volumeCreditsFor(perf);
}

->

function totalVolumeCredits()
{
    let volumeCredits = 0;

    for (let perf of invoice.perfomances) {
        volumeCredits += volumeCreditsFor(perf);
    }

    return volumeCredits;
}

이게 돼?

```

- 복잡하게 얽힌 덩어리를 잘게 쪼개면서 골격을 개선하고 단계를 쪼갠다.
- 함수 추출하기
- 변수 인라인하기
- 함수 옮기기
- 조건부 로직을 다형성으로 바꾸기


2. 리팩터링 원칙

- 90%의 시간은 낭비
- 성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것

3. 코드에서 나는 악취

- 중복 코드
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우 - 함수 추출하기
- 완전히 똑같지는 않다면, 문장 슬라이드하기로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다
- 같은 부모로부터 파생된 서브 클래스들에 중복되어 있다면, 각자 따로 호출되지 않도록 메서드 올리기를 적용해 부모로 옮긴다.
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 함수를 짧게 만드는 직업의 99%는 함수 추출하기가 차지한다.
- 함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다.
- 이런 경우 임시 변수를 질의 함수로 바꾸기로 임시 변수의 수를, 매개변수 객체 만들기와 객체 통째로 넘기기로 매개변수의 수를 줄일 수 있다.
- 이 리팩터링을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 더 큰 수술이라 할 수 있는 함수를 명령으로 바꾸기를 고려해보자.

4. 테스트 구축하기

- 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다.
- 구현보다 인터페이스에 집중하게 된다는 장점도 있다 (무조건 좋은 일이다).
- 코딩이 완료되는 시점을 정확하게 판단할 수 있다.
- 테스트를 모두 통과한 시점이 바로 코드를 완성한 시점이다.

5. 리팩터링 카탈로그 보는법

6. 기본적인 리팩터링

- 함수 추출하기
- 유효범위를 벗어나는 변수가 없을 때
- 지역변수를 사용할 때
- 지역 변수의 값을 변경할 때
- 함수 인라인하기
- 다형 메서드인지 확인한다
- 인라인할 함수를 호출하는 곳을 모두 찾는다
- 각 호추룬을 함수 본문으로 교체한다
- 하나씩 교체할 때마다 테스트한다.
- 함수 정의를 삭제한다.
- 변수 추출하기
- 클래스 전체에 영향을 주는 변수는 메서드로 추출한다.
- 변수 인라인하기
- 간단한 절차
- 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다.
- 메서드 선언을 원하는 형태로 바꾼다
- 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다.
- 테스트한다.
- 마이그레이션 절차
- 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩토링한다.
- 함수 본문을 새로운 함수로 추출한다.
- 추출한 함수에 매개변수를 추가해야 한다면 '간단한 절차'를 따라 추가한다.
- 테스트한다.
- 기존 함수를 인라인한다.
- 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다.
- 테스트한다.
- 함수가 매개변수를 받도록 리팩토링 하면서 의존성을 제거하여 더 넓은 문맥에 활용하게 할 수도 있다.
- 변수 캡슐화하기
- 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
- 정적 검사를 수행한다.
- 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다.
- 하나씩 바꿀 때마다 테스트한다.
- 변수의 접근 범위를 제한한다.
- 테스트한다.
- 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.
- 변수 이름 바꾸기
- 매개변수 객체 만들기
- 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다. (클래스 or 객체)
- 테스트한다.
- 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
- 테스트한다.
- 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다.
- 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
- 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.
- 코드에 범위 개념이 필요함을 깨달았다면 최댓값과 최솟값 쌍을 사용하는 코드를 발견할 때마다 범위 객체로 바꾸자
- 여러 함수를 클래스로 묶기 **** P206

```

function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}

->

class Reading {
    base() {...}
    taxableCharge() {...}
    calculateBaseCharge() {...}
}

```

- 여러 함수를 변환함수로 묶기

```

function base(aReading) {...}
function taxableCharge(aReading) {...}

->

function enrichReading(argReading) {
    const aReading = _.cloneDeep(argReading);
    aReading.baseCharge = base(aReding);
    aReading.taxableCharge = taxableCharge(aReading);
    return aReading;
}

```

- 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다.
- 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문이다.
- 여러 함수를 한데 묶는 이유는 도출 로직이 중복되는 것을 피하기 위해서다.
- 이 로직을 함수로 추출하는 것만으로도 같은 효과를 볼 수 있지만, 데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수를 발견하기 어려울 때가 많다.
- 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다. (이 작업은 대체로 깊은 복사로 처리해야 한다. 변환 함수가 원본 레코드를 바꾸지 않는지 검사하는 테스트를 마련해두면 도움될 때가 많다.)
- 묶을 함수 중 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다.
- 단계 쪼개기 P226 ****

```

const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split("-")[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;

->

const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString) {
    const values = aString.split(/\s+/);
    return ({
        productID: values[0].split("-")[1],
        quantity: parseInt(values[1]),
    });
}

function price(order, priceList)
{
    return order.quantity * priceList[order.productID];
}

```


- 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다.
- 코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위함이다.
- 모듈이 잘 분리되어 있다면 다른 모듈의 상세 내용은 전혀 기억하지 못해도 원하는 대로 수정을 끝마칠 수도 있다.
- 이렇게 분리하는 가장 간편한 방법 하나는 동작을 연이은 두 단계로 쪼개는 것이다.
- 가장 대표적인 예는 컴파일러다.
- 컴파일러는 기본적으로 어떤 텍스트(프로그래밍 언어로 작성된 코드)를 입력받아서 실행 가능한 형태(특정 하드웨어에 맞는 목적 코드)로 ㅂ녀환한다.
- 텍스트를 토큰화하고,
- 토큰을 파싱해서 구문 트리를 만들고,
- 구문 트리를 변환하는 다양한 단계를 거친 다음,
- 목적 코드를 생성하는 식이다.
- 각 단계는 자신만의 문제에 집중하기 때문에 나머지 단계에 관해서는 자세히 몰라도 이해할 수 있다.
- 절차
- 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
- 테스트한다.
- 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
- 테스트한다.
- 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다.
- 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다.
- 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다.

7. 캡슐화

- 레코드 캡슐화하기

```

organization = {name: '애크미 구스베리', country: 'GB'};

class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }

    get name() { return this._name; }
    set name(arg) { this._name = arg; }
    get country() { return this._country; }
    set country(arg) { this._country = arg; }
}

```

- 가변데이터를 저장하는 용도로 레코드보다 객체를 선호한다.
- 값이 불변이면 단순히 '시작'과 '끝'의 길이를 모두 구해서 레코드에 저장한다.

- 기본형을 객체로 바꾸기
- 문장을 함수로 옮기기
- 반복문 쪼개기
- 반복문 쪼개기는 서로 다른 일들이 한 함수에서 이뤄지고 있다는 신호
- 반복문을 두 번 실행해야 하므로 이 리팩터링을 불편해하는 프로그래머도 많다.
- 다시 한번 이야기하지만, 리팩터링과 최적화를 구분하자.
- 반복문을 파이프라인으로 바꾸기 <-- foreach 문으로 작성된 구문들을 collect를 이용해 collection 형태로 수정한 다음 리팩토링을 시도해봤다.

```

foreach ($collection as $data) 
{
    if($this->isVaild($data)) {
        return $data;
    }
}

-->

return $collection->first(function($key, $data) {
    return $this->isVaild($data)
});

or Array

-->

return array_first($collection, function($key, $data) {
    return $this->isVaild($data);
});

function isVaild($data) {
    return $data == 1 ;
}

```

8. 기능 이동

9. 데이터 조직화

10. 조건부 로직 간소화

- 조건부 로직을 다형성으로 바꾸기 **** P366
- 본질은 같고 부가 정보만 덧붙이는 변환 함수의 이름을 enrich
- 형태가 변할 때만 transform
- 어서션 추가하기
- 특정 조건이 참일 때만 제대로 동작하는 코드 영역이 있을 수 있다.
- 테스트 코드가 있다면 어서션의 디버깅 용도로서의 효용은 줄어든다.
- 단위 테스트를 꾸준히 추가하여 사각을 좁히면 어서션보다 나을 때가 많다.
- 하지만 소통 측면에서는 어서션이 여전히 매력적이다.
- 참이라고 가정하는 조건이 보이면 그 조건을 명시하는 어서션을 추가한다.
- 이런 어서션은 오류의 출처를 특정하기 어려울 때 특히 제값을 한다.
- 제어 플래그를 탈출문으로 바꾸기

11. API 리팩터링

- 질의 함수와 변경 함수 분리하기

12. 상속 다루기

