# HTTP

1. HTTP 개관

- 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따른다.
- URL의 첫 번째 부분은 스킴이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술한다. 보통 HTTP 프로토콜(http://)이다.
- 두 번째 부분은 서버의 인터넷 주소를 제공한다. (예: www.joes-hardware.com)
- 마지막은 웹 서버의 리소스를 가리킨다 (예: /specials/saw-blade.gif)
- 오늘날 대부분의 URI는 URL이다.
- HTTP 트랜잭션은 요청 명령(클라이언트에서 서버로 보내는)과 응답 결과(서버가 클라이언트에게 돌려주는)로 구성되어 있다.
- HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않는다.
- 대신 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에게 맡긴다.
- TCP는 다음을 제공한다.
- 오류 없는 데이터 전송
- 순서에 맞는 전달(데이터는 언제나 보낸 순서대로 도착한다.)
- 조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다.)

```

HTTP - 애플리케이션 계층
TCP - 전송 계층
IP - 네트워크 계층
네트워크를 위한 링크 인터페이스 - 데이터 계층
물리적인 네트워크 하드웨어 - 물리 계층

HTTP 네트워크 프로토콜 스택

```

- URL 예:

```

http://207.200.83.29:80/index.html
http://www.netscape.com:80/index.html
http://www.netscape.com/index.html

첫 번째 URL은 IP 주소 '207.200.83.29' 와 포트번호 '80'을 갖고 있다.
두 번째 URL에는 숫자로 된 IP 주소가 없다. 대신 글자로 된 도메인 이름 혹은 호스트 명 ("www.netscape.com")을 갖고 있다.
호스트 명은 IP 주소에 대한 이해하기 쉬운 형태의 별명이다.
호스트 명은 도메인 이름 서비스(Domain Name Service, DNS)라 불리는 장치를 통해 쉽게 IP로 변환될 수 있다.

```


- HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜(Internet Protocol, IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다.
- 웹 브라우저가 어떻게 HTTP를 이용해서 멀리 떨어진 곳에 있는 서버의 단순한 HTML 리소스를 사용자에게 보여주는지? - 15Page

```

웹브라우저는 서버의 URL에서 호스트 명을 추출한다.
웹브라우저는 서버의 호스트 명을 IP로 변환한다.
웹브라우저는 URL에서 포트번호(있다면)를 추출한다.
웹브라우저는 웹 서버와 TCP 커넥션을 맺는다.
웹브라우저는 서버에 HTTP 요청을 보낸다.
서버는 웹브라우저에 HTTP 응답을 돌려준다.
커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

```

- 웹의 구성요소 
- 프락시 - 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 캐시 - 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
- 게이트웨이 - 다른 애플리케이션과 연결된 특별한 웹 서버
- 터널 - 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 에이전트 - 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트

2. URL과 리소스

- URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며, URL을 이용해 사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며 공유 할 수 있다.
- URL은 통합 자원 식별자 (Uniform Resource Identifter, URI) 라고 불리는 더 일반화된 부류의 부분집합이다.
- 대부분의 URL은 동일하게 '스킴://서버위치/경로' 구조로 이루어져 있다.
- 상대 참조 해석하기 P39
- 기저(base)URL 과 절대 URL

3. HTTP 메시지

- 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.
- 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.
- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.
- 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다.
- 이 줄바꿈 문자열은 'CRLF'라고 쓴다.
- HTTP 요청 메시지는 명령과 URL을 포함한다.
- HTTP 응답 메시지는 트랜잭션의 결과를 포함한다.
- 모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지 말해준다. 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.
- 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어있다.
- 메서드
- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다. P55 메서드

```

메서드 - 설명 - 메시지 본문이 있는가?

GET - 서버에서 어떤 문서를 가져온다 - 없음
HEAP - 서버에서 어떤 문서에 대한 헤더만 가져온다 - 없음
POST - 서버가 처리해야 할 데이터를 보낸다 - 있음
PUT - 서버에 요청 메시지의 본문을 저장한다 - 있음
TRACE - 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 - 없음
OPTIONS - 서버가 어떤 메서드를 수행할 수 있는지 확인한다 - 없음
DELETE - 서버에서 문서를 제거한다 - 없음

```

4. 커넥션 관리

- TCP 커넥션 P86
- 신뢰할 수 있는 데이터 전송 통로인 TCP
- TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
- TCP는 IP 패킷(혹은 IP 데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송한다.

```

1. HTTP

HTTP 애플리케이션 계층
TCP 전송 계층
IP 네트워크 계층
Network Interface 데이터 링크 계층

2. HTTPS

HTTP 애플리케이션 계층
TLS or SSL 보안 계층
TCP 전송 계층
IP 네트워크 계층
Network Interface 데이터 링크 계층

```

- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해 메시지 데이터의 내용을 순서대로 보낸다.
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다.
- 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.
- 이 IP 패킷들 각각은 다음을 포함한다.

```

IP 패킷 헤더 (보통 20바이트)
TCP 세그먼트 헤더 (보통 20바이트)
TCP 데이터 조각(0혹은 그 이상의 바이트)

```

- IP 헤더는 발신지와 목적지 IP 주소, 크기, 기타 플래그를 가진다.
- TCP 세그먼트 헤더는 TCP 포트번호, TCP 제어 플래그, 그리고 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값을 포함한다.
- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. TCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다.
- 포트 번호는 회사 직원의 내선전화와 같다.
- 회사의 대표전화번호는 안내 데스크로 연결되고 내선전화는 해당 직원으로 연결되듯이 IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결된다.
- TCP 커넥션은 네 가지 값으로 식별한다.
- <발신지IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>
- 이 네 가지 값으로 유일한 커넥션을 생성한다.
- 서로 다른 두 개의 TCP 커넥션은 네 가지 주소 구성요소의 값이 모두 같을 수 없다.
- TCP 소켓 프로그래밍
- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.

```

소켓 API 호출 - 설명

s = socket(<parameters>) - 연결이 되지 않은 익명의 새로운 소켓 생성
bind(s, <local IP:Port>) -  소켓에 로컬 포트 번호와 인터페이스 할당
connect(s, <remote IP:port>) - 로컬의 소켓과 원격의 호스트 및 포트 사이에 TCP 커넥션 생성
listen(s, ...) - 커넥션을 받아들이기 위해 로컬 소켓에 허용함을 표시
s2 = accept(s) - 누군가 로컬 포트에 커넥션을 맺기를 기다림
n = read(s, buffer, n) - 소켓으로부터 버퍼에 n바이트 읽기 시도
n = write(s, buffer, n) - 소켓으로부터 버퍼에 n바이트 쓰기 시도
close(s) - TCP 커넥션을 완전히 끊음
shutdown(s, <side>) - TCP 커넥션의 입출력만 닫음
getsockopt(s, ...) - 내부 소켓 설정 옵션값을 읽음
setsockopt(s, ...) - 내부 소켓 설정 옵션값을 변경

```

- TCP 커넥션 핸드셰이크 지연
- TCP 커넥션이 핸드 셰이크를 하는 순서

```

1. 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 서버에 보낸다.
그 패킷은 'SYN'라는 특별한 플래그를 가지는데, 이 요청이 커넥션 생성 요청이라는 뜻이다.

2. 서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 'SYN'과 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다.

3. 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인응답('ACK') 신호를 보낸다.

```

- 결국, 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.
- 이후에 이러한 TCP 구성으로 인한 지연을 제거하기 위해서 HTTP가 이미 존재하는 커넥션을 어떻게 재활용하는지 알아볼 것이다.
- 확인응답 지연
- 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에, TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다.
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다.
- TCP 느린 시작(slow start)
- TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나간다.
- 이렇게 조율하는 것은 TCP 느린시작이라고 부르며, 이는 인터넷의 급자스러운 부하와 혼잡을 방지하는 데 쓰인다.
- 네이글(Nagle) 알고리즘과 TCP_NODELAY
- 애플리케이션이 어떤 크기의 데이터든지(심지어 1바이트라도) TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공한다.
- 하지만 각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하기 때문에, TCP가 작은 크기의 데이터를 포함한 많은 수의 패킷을 전송한다면 네트워크 성능은 크게 떨어진다.
- 네이글 알고리즘은 세그먼트가 최대 크기(패킷의 최대 크기는 LAN상에서 1,500 바이트 정도, 인터넷상에서는 수백 바이트 정도다)가 되지 않으면 전송을 하지 않는다.
- 다만 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락한다.
- 네이글 알고리즘은 HTTP 성능 관련해 여러 문제를 발생시킨다. HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다.
- TIME_WAIT의 누적과 포트 고갈
- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓는다.
- 이 정보는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것으로, 보통 세그먼트의 최대 생명주기에 두 배 정도의 시간 동안만 유지된다.
- HTTP 커넥션 관리
- 멱등성 - 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등하다고 한다.
- GET, HEAD, PUT, DELETE, TRACE 그리고 OPTIONS 메서드들은 멱등하다고 이해하면 된다.
- 클라이언트는 POST와 같이 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안 된다.
- 전체 끊기(close), 입력과 출력 중 하나만 끊기(shutdown)

5. 웹 서버

```
 여러 종류의 소프트웨어 및 하드웨어 웹 서버에 대해 조사한다.
 HTTP 통신을 전달해주는 간단한 웹 서버를 펄(perl)로 작성해본다.
 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지 단계별로 설명한다.
```

- 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
- 웹 서버는 자신이 제공하는 리소스를 관리하고 웹 서버를 설정, 통제, 확장하기 위한 관리 기능을 제공한다.
- 웹 서버는 여러 가지 형태가 가능하다.
- 다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치하고 실행할 수 있다.
- 마이크로프로세서의 기적으로, 어떤 회사들은 사용자에게 판매할 전자기기 안에 몇 개의 컴퓨터 칩만으로 구현된 웹 서버를 내장시켜서 완전한 관리 콘솔로 제공한다.
- 2014년 기준 순위 마이크로소프트 IIS(37%), 아파치(35%), 엔진엑스(14%)
- 2017년 10월 기준으로 실질적으로 작동하는 웹 사이트(active site)들에서 쓰이는 웹 서버 소프트웨어 순위는 아파치(44.89%), 엔진엑스(20.65%), 구글 웹 서버(7.86%), 마이크로소프트 IIS(7.32%)순이다 
- 2021년 아파치 (41%), 엔진엑스 (27%), 마이크로소프트 (11%)
- 웹 서버가 하는일
- 커넥션을 맺는다 - 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
- 요청을 받는다 - HTTP 요청 메시지를 네트워크로부터 읽어 들인다
- 요청을 처리한다 - 요청 메시지를 해석하고 행동을 취한다
- 리소스에 접근한다 - 메시지에서 지정한 리소스에 접근한다.
- 응답을 만든다 - 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
- 응답을 보낸다 - 응답을 클라이언트에게 돌려준다.
- 트랜잭션을 로그로 남긴다 - 로그파일에 트랜잭션 완료에 대한 기록을 남긴다. P131
- 대부분의 웹 서버는 '역방향 DNS(reverse DNS)'를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환하도록 설정되어 있다.
- docroot의 활용
- DocumentRoot - 아파치 웹 서버의 문서 루트를 설정한다. 가상호스트에서 DocumentRoot를 이용해 웹 서버에서 두 웹 사이트를 분리할 수 있다.
- DirectoryIndex - 디렉터리 색인 파일로 사용될 모드 파일의 이름을 우선순위로 나열한다. 
- 사용자가 디렉터리 URI를 요청했을 때 기본 색인 파일이 없고 디렉터리 색인 기능이 꺼져있지 않다면, 많은 웹 서버는 자동으로 그 디렉터리의 파일들을 크기, 벼경일 및 그 파일에 대한 링크와 함께 열거한 HTML 파일을 반환한다
- 다음과 같은 아파치 지시자로 디렉터리 색인 파일 자동 생성을 끌 수 있다.
- Options -indexes

```
 아파치는 URI의 경로명이 실행 가능한 프로그램이 위치한 디렉터리로 매핑되도록 설정하는 기능을 제공한다.
 URL의 경로가 /cgi-bin/으로 시작한다면 /usr/local/etc/httpd/cgi-progrmas/에서 프로그램을 찾아 실행하라
 ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/ 
```

```
 특정 확장자의 파일만 실행다로고 설정할 수 있다.
 .cgi로 끝나는 모든 웹 리소스는 실행되어야 함
 AddHandler cgi-script .cgi
```
- 웹 초창기에 널리 쓰였던 CGI는 서버사이드 애플리케이션을 실행하기 위한 간단한 인터페이스다.
- 오늘날의 애플리케이션 서버는, 마이크로소프트의 액티브 서버 페이지와 자바 서블릿과 같은 한층 더 강력하고 효과적인 동적 컨텐츠 지원 기능을 갖고 있다.

6. 프락시

```

HTTP 프락시와 웹 게이트웨이를 비교하고 HTTP 프락시가 어떻게 배치되는지 그림으로 보여주면서 설명한다.

몇 가지 유용한 활용방법을 보여준다.

프락시가 실제 네트워크에 어떻게 배치되어 있는지 그리고 트래픽이 어떻게 프락시 서버로 가게 되는지 설명한다.

브라우저에서 프락시를 사용하려면 어떻게 설정해야 하는지 보여준다.

HTTP 프락시 요청이 서버 요청과 어떻게 다른지, 그리고 프락시가 어떻게 부라우저의 동작을 미묘하게 바꾸는지 보여준다.

일련의 프락시 서버들을 통과하는 메시지의 경로를, Via 헤더와 TRACE 메서드를 이용해 기록하는 방법을 설명한다.

프락시에 기반한 HTTP 접근 제어를 설명한다.

어떻게 프락시가 클라이언트와 서버 사이에서 각각의 다른 기능과 버전 들을 지원하면서 상호작용 할 수 있는지 설명한다.

```

- 웹 프락시 서버는 클라이언트의 입장에서 트랜잭션을 수행하는 중개인이다.
- 웹 프락시가 없다면, 클라이언트는 HTTP 서버와 직접 이야기한다.
- HTTP 프락시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 하다.
- 프락시는 HTTP 클라이언트의 요청을 받게 되므로, 반드시 웹 서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려줘야 한다.
- 동시에 프락시는 요청을 서버로 보내기도 하므로 요청을 보내고 응답을 받는 올바른 HTTP 클라이언트처럼 동작해야 한다.
- 엄밀하게 말하면, 프락시는 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결하고, 게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결한다.
- 왜 프락시를 사용하는가? 어린이필터 or 동시 접근 제어 or 보안 방화벽
- 프락시 서버 배치 네 가지
- 출구 프락시
- 접근(입구) 프락시
- 대리 프락시
- 네트워크 교환 프락시 
- 프락시 URI는 서버 URI와 다르다.
- 클라이언트가 프락시를 사용하지 않도록 설정되어 있다면, 부분 URI를 보낸다.
- 클라이언트가 프락시를 사용하도록 설정되어 있다면, 완전한 URI를 보낸다.
- Via 헤더 필드는 메시지가 지나는 각 중간 노드(프락시나 게이트웨이)의 정보를 나열한다.
- Via 문법 - Via 헤더 필드는 쉼표로 구분된 경유지의 목록이다.
- Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
- 프로토콜의 버전은 필수이다.
- 응답 Via 헤더는 보통 요청 Via의 반대다.
- HTTP/1.1의 TRACE 메서드는 요청 메시지를 프락시의 연쇄를 따라가면서 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적할 수 있도록 해준다.
- TRACE 요청이 목적지 서버에 도착했을 때, 서버는 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함시켜 송신자에게 그대로 돌려보낸다.
- TRACE 응답이 도착했을 때, 클라이언트는 서버가 받은 메시지와 그 메시지가 지나간 프락시들의 목록(Via 헤더 안에 있다)을 검사할 수 있다.

7. 캐시

```

캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.

캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.

캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.

페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

```

- 불필요한 데이터 전송 - 복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 된다.
- 똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동한다.
- 이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다.
- 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관된다.
- 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다.
- 대역폭 병목 - 캐시는 또한 네트워크 병목을 줄여준다.
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.
- 클라이언트들이 서버에 접근할 때의 속도는, 그 경로에 있는 가장 느린 네트워크의 속도와 같다.
- 만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것이다.
- EX) 죠의 하드웨어 주식회사의 샌프란시스코 지사에 있는 사용자는 애틀랜타의 본사로부터 5MB 크기의 물품 목록 파일을 받는데 30초가 걸릴 수 있다.
- 만약 문서가 샌프란시스코의 사무실에 캐시되어 있따면, 로컬 사용자는 같은 문서를 이더넷 접속을 통해 1초 미만의 시간에 가져올 수 있을 것이다.
- 재검사(Revalidation) - 원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.
- 이러한 '신선도 검사'를 HTTP 재검사라 부른다. 효과적인 재검사를 위해, HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사할 수 있는 특별한 요청을 정의했다.
- HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그중에서 가장 많이 쓰이는 것은 If-Modified-Since 헤더다.
- 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.
- 캐시 처리 단계 7 단계
- 요청받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
- 파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
- 검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다
- 신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.
- 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
- 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
- 로깅 - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.
- HTTP/1.1은 신선도를 관리하기 위해, 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러 가지 방법을 제공한다.
- no-store와 no-cache 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

```

Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache

```

- 'no-cache'가 표시된 응답은 캐시가 그 응답의 사본으 만드는 것을 금지한다.
- 캐시는 보통, 캐시가 아닌 프락시 서버가 그러는 것처럼, 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것이다.
- 이 헤더의 더 나은 이름은 "Do-Not-Servce-From-Cache-Without-Revalidation(재검사 없이 캐시에서 제공하지 마라)"일 것이다.

```

Cache-Control: max-age=3600

```

- Cache-Control:max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다.
- 서버는 최대 나이먹음(Maximum aging)을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.


- 캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정될 수 있다.
- 만약 캐시가 만료 ㅈ어보를 엄격하게 따르길 원한다면, 다음과 같은 Cache-Control을 붙일 수 있다.

```

Cache-Control - must-revalidate

```

- Cache-Control: must-revalidate 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨을 의미한다.
- 캐시는 자유롭게 신선한 사본을 제공할 수 있다.
- 아파치로 HTTP 헤더 제어하기
- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공한다.
- mod-headers 모듈은 개별 헤더들을 설정할 수 있게 해준다. 한번 이 모듈이 로드되면, 개별 HTTP 헤더를 설정할 수 있는 지시어를 이용해 아파티 설정 파일에 설정을 추가할 수 있다.

8. 통합점: 게이트웨이, 터널, 릴레이

9. 웹 로봇

10. HTTP/2.0

11. 클라이언트 식별과 쿠키

12. 기본 인증

13. 다이제스트 인증

14. 보안 HTTP

15. 엔터티와 인코딩

16. 국제화

17. 내용 협상과 트랜스코딩

18. 웹 호스팅

19. 배포 시스템

20. 리다이렉션과 부하 균형

21. 로깅과 사용 추적