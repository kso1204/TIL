# HTTP

1. HTTP 개관

- 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따른다.
- URL의 첫 번째 부분은 스킴이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술한다. 보통 HTTP 프로토콜(http://)이다.
- 두 번째 부분은 서버의 인터넷 주소를 제공한다. (예: www.joes-hardware.com)
- 마지막은 웹 서버의 리소스를 가리킨다 (예: /specials/saw-blade.gif)
- 오늘날 대부분의 URI는 URL이다.
- HTTP 트랜잭션은 요청 명령(클라이언트에서 서버로 보내는)과 응답 결과(서버가 클라이언트에게 돌려주는)로 구성되어 있다.
- HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않는다.
- 대신 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에게 맡긴다.
- TCP는 다음을 제공한다.
- 오류 없는 데이터 전송
- 순서에 맞는 전달(데이터는 언제나 보낸 순서대로 도착한다.)
- 조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다.)

```

HTTP - 애플리케이션 계층
TCP - 전송 계층
IP - 네트워크 계층
네트워크를 위한 링크 인터페이스 - 데이터 계층
물리적인 네트워크 하드웨어 - 물리 계층

HTTP 네트워크 프로토콜 스택

```

- URL 예:

```

http://207.200.83.29:80/index.html
http://www.netscape.com:80/index.html
http://www.netscape.com/index.html

첫 번째 URL은 IP 주소 '207.200.83.29' 와 포트번호 '80'을 갖고 있다.
두 번째 URL에는 숫자로 된 IP 주소가 없다. 대신 글자로 된 도메인 이름 혹은 호스트 명 ("www.netscape.com")을 갖고 있다.
호스트 명은 IP 주소에 대한 이해하기 쉬운 형태의 별명이다.
호스트 명은 도메인 이름 서비스(Domain Name Service, DNS)라 불리는 장치를 통해 쉽게 IP로 변환될 수 있다.

```


- HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜(Internet Protocol, IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다.
- 웹 브라우저가 어떻게 HTTP를 이용해서 멀리 떨어진 곳에 있는 서버의 단순한 HTML 리소스를 사용자에게 보여주는지? - 15Page

```

웹브라우저는 서버의 URL에서 호스트 명을 추출한다.
웹브라우저는 서버의 호스트 명을 IP로 변환한다.
웹브라우저는 URL에서 포트번호(있다면)를 추출한다.
웹브라우저는 웹 서버와 TCP 커넥션을 맺는다.
웹브라우저는 서버에 HTTP 요청을 보낸다.
서버는 웹브라우저에 HTTP 응답을 돌려준다.
커넥션이 닫히면, 웹브라우저는 문서를 보여준다.

```

- 웹의 구성요소 
- 프락시 - 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 캐시 - 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
- 게이트웨이 - 다른 애플리케이션과 연결된 특별한 웹 서버
- 터널 - 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 에이전트 - 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트

2. URL과 리소스

- URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며, URL을 이용해 사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며 공유 할 수 있다.
- URL은 통합 자원 식별자 (Uniform Resource Identifter, URI) 라고 불리는 더 일반화된 부류의 부분집합이다.
- 대부분의 URL은 동일하게 '스킴://서버위치/경로' 구조로 이루어져 있다.
- 상대 참조 해석하기 P39
- 기저(base)URL 과 절대 URL

3. HTTP 메시지

- 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.
- 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.
- 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.
- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.
- 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다.
- 이 줄바꿈 문자열은 'CRLF'라고 쓴다.
- HTTP 요청 메시지는 명령과 URL을 포함한다.
- HTTP 응답 메시지는 트랜잭션의 결과를 포함한다.
- 모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지 말해준다. 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.
- 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어있다.
- 메서드
- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다. P55 메서드

```

메서드 - 설명 - 메시지 본문이 있는가?

GET - 서버에서 어떤 문서를 가져온다 - 없음
HEAP - 서버에서 어떤 문서에 대한 헤더만 가져온다 - 없음
POST - 서버가 처리해야 할 데이터를 보낸다 - 있음
PUT - 서버에 요청 메시지의 본문을 저장한다 - 있음
TRACE - 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 - 없음
OPTIONS - 서버가 어떤 메서드를 수행할 수 있는지 확인한다 - 없음
DELETE - 서버에서 문서를 제거한다 - 없음

```

4. 커넥션 관리

- TCP 커넥션 P86
- 신뢰할 수 있는 데이터 전송 통로인 TCP
- TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
- TCP는 IP 패킷(혹은 IP 데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송한다.

```

1. HTTP

HTTP 애플리케이션 계층
TCP 전송 계층
IP 네트워크 계층
Network Interface 데이터 링크 계층

2. HTTPS

HTTP 애플리케이션 계층
TLS or SSL 보안 계층
TCP 전송 계층
IP 네트워크 계층
Network Interface 데이터 링크 계층

```

- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해 메시지 데이터의 내용을 순서대로 보낸다.
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다.
- 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.
- 이 IP 패킷들 각각은 다음을 포함한다.

```

IP 패킷 헤더 (보통 20바이트)
TCP 세그먼트 헤더 (보통 20바이트)
TCP 데이터 조각(0혹은 그 이상의 바이트)

```

- IP 헤더는 발신지와 목적지 IP 주소, 크기, 기타 플래그를 가진다.
- TCP 세그먼트 헤더는 TCP 포트번호, TCP 제어 플래그, 그리고 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값을 포함한다.
- 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. TCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다.
- 포트 번호는 회사 직원의 내선전화와 같다.
- 회사의 대표전화번호는 안내 데스크로 연결되고 내선전화는 해당 직원으로 연결되듯이 IP 주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결된다.
- TCP 커넥션은 네 가지 값으로 식별한다.
- <발신지IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>
- 이 네 가지 값으로 유일한 커넥션을 생성한다.
- 서로 다른 두 개의 TCP 커넥션은 네 가지 주소 구성요소의 값이 모두 같을 수 없다.
- TCP 소켓 프로그래밍
- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.

```

소켓 API 호출 - 설명

s = socket(<parameters>) - 연결이 되지 않은 익명의 새로운 소켓 생성
bind(s, <local IP:Port>) -  소켓에 로컬 포트 번호와 인터페이스 할당
connect(s, <remote IP:port>) - 로컬의 소켓과 원격의 호스트 및 포트 사이에 TCP 커넥션 생성
listen(s, ...) - 커넥션을 받아들이기 위해 로컬 소켓에 허용함을 표시
s2 = accept(s) - 누군가 로컬 포트에 커넥션을 맺기를 기다림
n = read(s, buffer, n) - 소켓으로부터 버퍼에 n바이트 읽기 시도
n = write(s, buffer, n) - 소켓으로부터 버퍼에 n바이트 쓰기 시도
close(s) - TCP 커넥션을 완전히 끊음
shutdown(s, <side>) - TCP 커넥션의 입출력만 닫음
getsockopt(s, ...) - 내부 소켓 설정 옵션값을 읽음
setsockopt(s, ...) - 내부 소켓 설정 옵션값을 변경

```

- TCP 커넥션 핸드셰이크 지연
- TCP 커넥션이 핸드 셰이크를 하는 순서

```

1. 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 서버에 보낸다.
그 패킷은 'SYN'라는 특별한 플래그를 가지는데, 이 요청이 커넥션 생성 요청이라는 뜻이다.

2. 서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 'SYN'과 'ACK' 플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다.

3. 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인응답('ACK') 신호를 보낸다.

```

- 결국, 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.
- 이후에 이러한 TCP 구성으로 인한 지연을 제거하기 위해서 HTTP가 이미 존재하는 커넥션을 어떻게 재활용하는지 알아볼 것이다.
- 확인응답 지연
- 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에, TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다.
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다.
- TCP 느린 시작(slow start)
- TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나간다.
- 이렇게 조율하는 것은 TCP 느린시작이라고 부르며, 이는 인터넷의 급자스러운 부하와 혼잡을 방지하는 데 쓰인다.
- 네이글(Nagle) 알고리즘과 TCP_NODELAY
- 애플리케이션이 어떤 크기의 데이터든지(심지어 1바이트라도) TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공한다.
- 하지만 각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하기 때문에, TCP가 작은 크기의 데이터를 포함한 많은 수의 패킷을 전송한다면 네트워크 성능은 크게 떨어진다.
- 네이글 알고리즘은 세그먼트가 최대 크기(패킷의 최대 크기는 LAN상에서 1,500 바이트 정도, 인터넷상에서는 수백 바이트 정도다)가 되지 않으면 전송을 하지 않는다.
- 다만 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락한다.
- 네이글 알고리즘은 HTTP 성능 관련해 여러 문제를 발생시킨다. HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다.
- TIME_WAIT의 누적과 포트 고갈
- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓는다.
- 이 정보는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않게 하기 위한 것으로, 보통 세그먼트의 최대 생명주기에 두 배 정도의 시간 동안만 유지된다.
- HTTP 커넥션 관리

5. 웹 서버

6. 프락시

7. 캐시

8. 통합점: 게이트웨이, 터널, 릴레이

9. 웹 로봇

10. HTTP/2.0

11. 클라이언트 식별과 쿠키

12. 기본 인증

13. 다이제스트 인증

14. 보안 HTTP

15. 엔터티와 인코딩

16. 국제화

17. 내용 협상과 트랜스코딩

18. 웹 호스팅

19. 배포 시스템

20. 리다이렉션과 부하 균형

21. 로깅과 사용 추적