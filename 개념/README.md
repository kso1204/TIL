# 한번 더 개념 정리

# 의존성 주입 (DI)

1. https://mangkyu.tistory.com/150

# 스프링에서 사용하는 Application Context

1. https://mangkyu.tistory.com/151

# 스프링 빈?

1. https://velog.io/@gillog/Spring-Bean-%EC%A0%95%EB%A6%AC

# static 변수와 static 메소드

1. https://mangkyu.tistory.com/47?category=872426

- static은 객체의 생성 없이 접근, static을 선언하지 않은 변수는 new를 통해 새로운 heap(메모리) 영역에 할당

- static은 모든 메모리가 공유하는 영역에 있다 (static영역)

# REST API

1. https://mangkyu.tistory.com/46?category=925341

- Resource

- Method

- Representation of Resource (json(자바스크립트 데이터 오브젝트))

# 서버 기반 인증시스템 VS 토큰 기반 인증 시스템

1. https://mangkyu.tistory.com/55?category=925341

# JWT

1. https://mangkyu.tistory.com/56

# SHA, RSA, AES

1. https://stage-loving-developers.tistory.com/23

- 암호화 - 공개키, 복호화 - 개인키

- SHA - 단방향 해싱, RSA - 비대칭키 암호화 방식 (공개키 != 개인키), AES - 대칭키 암호화 방식 (공개키 = 개인키)

# Cache

1. https://mangkyu.tistory.com/69?category=925341

- 캐시는 Cache Hit, Cache miss, Long Tail의 주요 키 포인트

- Long Tail이란 상위 20%의 요구가 리소스의 대부분을 사용하는 것

# SQL 고급 

1. https://mangkyu.tistory.com/25?category=761304

# 트랜잭션, 동시성 제어, 회복

1. https://mangkyu.tistory.com/25?category=761304

- 트랜잭션이란 DBMS에서 데이터를 다루는 논리적인 작업의 단위

- Commit이란 트랜잭션의 수행이 완료됨을 트랜잭션 관리자에게 알려 주는 연산

- 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다.(All or Nothing)
 
# Stream API

1. https://mangkyu.tistory.com/112

2. 람다식이란? 함수를 하나의 식으로 표현한 것 

3. 함수를 람다식으로 표현하면 메소드의 이름이 필요 없기 때문에, 람다식은 익명 함수의 한 종류라고 볼 수 있다.

4. 함수형 인터페이스의 인스턴스를 생성하여 함수를 변수처럼 사용하는 람다식  

5. 장점 -> 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.

6. 병렬프로그래밍이 용이하다.

7. 단점 -> 람다를 사용하면서 만든 익명함수는 재사용이 불가능하다.

8. 디버깅이 어렵다.

9. 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.

10. 함수형 인터페이스란? 함수를 1급 객체처럼 다룰 수 있는 어노테이션으로, 인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할

11. Java에서 제공하는 함수형 인터페이스 네 가지

- Supplier<\T>

- 매개변수 없이 반환값 만을 갖는 함수형 인터페이스이다.

- T get()을 추상메소드로 가지고 있다.

- Consumer<\T>

- Function<\T,R>

- Predicate<\T>

- 내용이 너무 어려워서 복습이 필요해보임; https://mangkyu.tistory.com/113

# 디자인 패턴

1. 생성 패턴

- 팩토리 패턴 - 객체를 생성하기 위한 디자인 패턴

- 추상 팩토리 패턴 - 객체를 생성하는 팩토리를 생성하기 위한 디자인 패턴

- 빌더 패턴 - 상황에 따라 동적인 인자를 필요로 하는 객체를 생성하기 위한 디자인 패턴

- 싱글톤 패턴 - 객체를 1개만 생성하여 항상 참조가능하도록 고안된 디자인 패턴

2. 구조 패턴

- 어댑터 패턴 - 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴

- 프록시 패턴 - 어떤 객체에 접근하기 위해 대리인을 사용하는 패턴

- 퍼사드 패턴 - 어떤 복합적인 기능에 대해 간략화된 인터페이스를 제공하는 디자인 패턴

3. 행위 패턴

- 전략 패턴 - 상황에 따라 다른 전략을 사용하기 위한 디자인 패턴

- 옵저버 패턴 - 값을 관찰하여 빠르게 반영하기 위한 디자인 패턴

- 커맨드 패턴 - 실행될 기능을 캡슐화하여 재사용성이 높은 클래스를 설계하기 위한 디자인 패턴

# 가상화

1. https://mangkyu.tistory.com/86

2. 가상화란 가상화를 관리하는 소프트웨어(주로 HyperVisor)를 사용하여 하나의 물리적 머신에서 가상 머신(VM)을 만드는 프로세스이다.

3. 가상 머신은 물리적 머신과 동일한 역할 및 성능을 수행하지만, cpu와 메모리 및 스토리지와 같은 물리적 머신의 컴퓨팅 리소스를 사용한다.

4. HyperVisor는 필요에 따라 각 가상 머신에 이러한 컴퓨팅 리소스를 할당한다.

5. 최근에는 Docker와 같은 컨테이너 가상화 기술이 등장하기도 하였다. 도커를 윈도우에서 사용하는 경우에는 HyperVisor를 사용하지만,

6. 리눅스에서 사용하는 상황에서는 커널의 특징을 이용하기 때문에 HyperVisor를 사용하지 않는다.

7. 가상화를 이용하면 서버를 통합하고 서버의 자원을 최대한으로 활용함으로써 서버 급증 문제를 해결할 수 있다.

# Nginx Vs Apache

1. Nginx는 동적인 페이지 구현이 어렵기 때문에, 동적인 페이지를 구현하기 위해 외부 프로그램의 도움을 받는다.

2. 웹서버에서 요청을 받아 그 요청을 외부 프로그램에 넘겨주면, 외부 프로그램은 프로그램 파일을 읽어 html로 반환하는 단계를 거치게 됩니다. 

3. 이 과정을 CGI라고 하는데, PHP-FPM(PHP FastCGI Process Manager)도 CGI에 해당 된다.

4. Apache의 경우에는 해당 역할을 하는 모듈이 내장되어 있다. 그럼에도 php-fpm 사용한다.

# 정규화

1. https://mangkyu.tistory.com/110?category=761304

2. 정규화의 기본 목표는 테이블간에 중복된 데이터를 허용하지 않는 것

3. 제 1정규화란 테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것

4. 제 2정규화란 제 1정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.

5. 여기서 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어선 안 된다는 것이다.

6. 제 3정규화란 제 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다.

7. 여기서 이행적 종속이라는 것은 A->B, B->C가 성립할 때 A->C가 성립되는 것을 의미한다.

8. BCNF 정규화란 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.

# 리플리케이션

1. https://mangkyu.tistory.com/97?category=761304

2. 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.

3. Master Node는 쓰기 작업만, Slave Node는 읽기 작업만 처리한다.

4. Master와 Slave간의 데이터 무결성 검사(데이터가 일치하는지)를 하지 않는 비동기방식으로 데이터를 동기화한다.

4. 장점 -> DB 요청의 60 ~ 80% 정도는 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.

5. 비동기 방식으로 운영되어 지연 시간이 거의 없다.

6. 단점 -> 노드들 간의 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.

7. Master 노드가 다운되면 복구 및 대처가 까다롭다.

# 클러스터링

1. 클러스트링이란 여러 개의 DB를 수평적인 구조로 구축하는 방식이다.

2. 클러스트링은 분산 환경을 구성하여 Single point of failure와 같은 문제를 해결할 수 있는 Fail Over 시스템을 구축하기 위해서 사용된다.

3. 클러스트링은 동기 방식으로 노드들 간의 데이터를 동기화 한다.

4. 장점 -> 노드들 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.

5. 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 계속 장애 없이 운영할 수 있다.

5. 단점 -> 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replication에 비해 쓰기 성능이 떨어진다.

6. 장애가 전파된 경우 처리가 까다로우며, 데이터 동기화에 의해 스케일링에 한계가 있다.

# IPC

1. https://mangkyu.tistory.com/9?category=761303

1. 내부 프로세스들 끼리 통신을 하는 것

2. 프로세스가 통신 가능하다는 것은 서로 다른 프로세스가 데이터를 주고 받을 수 있다는 것이며, 

3. 동시에 접근 가능한 메모리 즉, 프로세스들이 공유하는 메모리가 필요하다는 뜻입니다.

# 프로세스 Vs 쓰레드

1. 프로세스는 생성되면서 *PC(Program count - 다음에 수행해야 하는 명령어의 주소를 가리키는 레지스터)를 포함하여 메모리 공간등을 복사하여 자원을 할당하지만,

2. 쓰레드는 메모리 공간과 자원들을 공유한다.

3. 즉, 프로세스와 쓰레드를 생성하기 전에 a라는 변수를 선언해 놓았다고 하면 프로세스는 a를 각각 한 개씩, 쓰레드는 a를 공유한다.

4. 그래서 프로세스는 통신을 할 공간이 없기 때문에 별도의 공간을 만들어줘야 해서 프로세스 간의 통신이 쓰레드 간의 통신보다 더 어렵다.

5. 프로세스 -> 메모리에 올라와 실행되고 있는 프로그램의 인스턴스

6. 운영체제로부터 독립된 메모리 영역을 할당 받는다. (다른 프로세스의 자원에 접근 X)

7. 프로세스들은 독립적이기 때문에 IPC를 사용해야 한다.

8. 프로세스는 최소 한 개의 쓰레드를 가지고 있다.

9. 쓰레드 -> 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위

10. 쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다.

11. Stack을 분리한 이유는 Stack에는 함수의 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 하기 위함이다.

# 컨텍스트 스위칭

1. Context Switching 이란 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정입니다.

2. 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구합니다.

