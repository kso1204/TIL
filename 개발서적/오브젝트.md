# 오브젝트

1. 객체, 설계

2. 객체지향 프로그래밍

3. 역할, 책임, 협력

4. 설계 품질과 트레이드오프

5. 책임 할당하기

6. 메시지와 인터페이스

7. 객체 분해

8. 의존성 관리하기

9. 유연한 설계

10. 상속과 코드 재사용

11. 합성과 유연한 설계

12. 다형성

13. 서브클래싱과 서브타이핑

14. 일관성 있는 협력

15. 디자인 패턴과 프레임워크

# 클래스 다이어그램 or 커뮤니케이션 다이어그램

# 패러다임의 시대

1. 과학혁명의 구조 kuhn12

2. 절차형 패러다임에서 객체지향 패러다임으로의 변화

3. 프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

4. 프로그래밍 패러다임은 혁명적이 아니라 발전적이다.

# 객체, 설계

1. 로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.

2. 여기서 모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.

```

모든 소프트웨어 모듈에는 세 가지 목적이 있다.

첫 번째 목적은 실행 중에 제대로 동작하는 것이다.

두 번째 목적은 변경을 위해 존재하는 것이다.

세 번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다.

```

3. 마틴에 따르면 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다.

4. 의존성은 변경에 대한 영향을 암시한다.

5. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

6. 객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.

```

P20

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public TicketOffice getTicketOffice() {
        return ticketOffice;
    }

}


-> 

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }

}

TicketSeller에서 getTicketOffice 메서드가 제거 됐다.

tickeOffice의 가시성이 private이고 접근 가능한 퍼블릭 메서드가 더 이상 존재하지 않기 때문에 외부에서는 tciketOffice에 직접 접근할 수 없다.

결과적으로 ticketOffice에 대한 접근은 오직 TicketSeller 안에만 존재하게 된다.

따라서 TicketSeller는 tickerOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로 수행할 수밖에 없다.

이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다.

수정된 Theater 클래스 어디서도 ticketOffice에 접근하지 않는다는 사실에 주목하라.

Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.

Theater는 단지 ticketSeller가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

Theater는 오직 TicketSeller의 인터페이스(interface)에만 의존한다.

TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation)의 영역에 속한다.

```

7. 객체의 자율성을 높이는 방향으로 설계를 개선하자, 이해하기 쉽고 유연한 설계를 얻을 수 있었다.

8. 캡슐화와 응집도의 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

9. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

10. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.

11. 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.

12. 프로세스와 데이터가 동일한 모듈 내부에 위치시키는 방식을 객체지향 프로그래밍이라고 부른다.

13. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

14. 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다.

15. TicketSeller의 책임은 무엇인가? 티켓은 판매하는 것이다.

16. Audience의 책임은 무엇인가? 티켓을 사는 것이다.

17. Theater의 책임은 무엇인가? 관람객을 입장시키는 것이다.

18. 적절한 객체에 적절한 책임을 할당하면 이해하기 쉬운 구조와 읽기 쉬운 코드를 얻게 된다.

19. 설계를 어렵게 만드는 것은 의존성이라는 것을 기억하라.

20. 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.

21. 예제에서 결합도를 낮추기 위해 선택한 방법은 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하는 것이다.

22. 결과적으로 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다.

# 객체지향 프로그래밍

1. 