# 오브젝트

1. 객체, 설계

2. 객체지향 프로그래밍

3. 역할, 책임, 협력

4. 설계 품질과 트레이드오프

5. 책임 할당하기

6. 메시지와 인터페이스

7. 객체 분해

8. 의존성 관리하기

9. 유연한 설계

10. 상속과 코드 재사용

11. 합성과 유연한 설계

12. 다형성

13. 서브클래싱과 서브타이핑

14. 일관성 있는 협력

15. 디자인 패턴과 프레임워크

# 클래스 다이어그램 or 커뮤니케이션 다이어그램

# 패러다임의 시대

1. 과학혁명의 구조 kuhn12

2. 절차형 패러다임에서 객체지향 패러다임으로의 변화

3. 프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

4. 프로그래밍 패러다임은 혁명적이 아니라 발전적이다.

# 객체, 설계

1. 로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.

2. 여기서 모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.

```

모든 소프트웨어 모듈에는 세 가지 목적이 있다.

첫 번째 목적은 실행 중에 제대로 동작하는 것이다.

두 번째 목적은 변경을 위해 존재하는 것이다.

세 번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다.

```

3. 마틴에 따르면 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다.

4. 의존성은 변경에 대한 영향을 암시한다.

5. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

6. 객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.

```

P20

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public TicketOffice getTicketOffice() {
        return ticketOffice;
    }

}


-> 

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }

}

TicketSeller에서 getTicketOffice 메서드가 제거 됐다.

tickeOffice의 가시성이 private이고 접근 가능한 퍼블릭 메서드가 더 이상 존재하지 않기 때문에 외부에서는 tciketOffice에 직접 접근할 수 없다.

결과적으로 ticketOffice에 대한 접근은 오직 TicketSeller 안에만 존재하게 된다.

따라서 TicketSeller는 tickerOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로 수행할 수밖에 없다.

이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다.

수정된 Theater 클래스 어디서도 ticketOffice에 접근하지 않는다는 사실에 주목하라.

Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.

Theater는 단지 ticketSeller가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

Theater는 오직 TicketSeller의 인터페이스(interface)에만 의존한다.

TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation)의 영역에 속한다.

```

7. 객체의 자율성을 높이는 방향으로 설계를 개선하자, 이해하기 쉽고 유연한 설계를 얻을 수 있었다.

8. 캡슐화와 응집도의 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

9. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

10. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.

11. 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.

12. 프로세스와 데이터가 동일한 모듈 내부에 위치시키는 방식을 객체지향 프로그래밍이라고 부른다.

13. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

14. 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다.

15. TicketSeller의 책임은 무엇인가? 티켓은 판매하는 것이다.

16. Audience의 책임은 무엇인가? 티켓을 사는 것이다.

17. Theater의 책임은 무엇인가? 관람객을 입장시키는 것이다.

18. 적절한 객체에 적절한 책임을 할당하면 이해하기 쉬운 구조와 읽기 쉬운 코드를 얻게 된다.

19. 설계를 어렵게 만드는 것은 의존성이라는 것을 기억하라.

20. 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.

21. 예제에서 결합도를 낮추기 위해 선택한 방법은 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하는 것이다.

22. 결과적으로 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다.

# 객체지향 프로그래밍

1. 할인 조건(discount condition)과 할인 정책(discount policy)

2. 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

3. 첫째, 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.

4. 둘째, 객체를 독립전인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.

5. 소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다.

6. 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다.

6. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.

7. 도메인 개념들의 구조를 반영하는 적절한 클래스 구조를 만들기 (P72)

8. 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.

10. 두 가지 중요한 사실

9. 첫째, 객체가 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것

10. 둘째, 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것

11. 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다.

12. 대부분의 객체지향 프로그래밍 언어들은 상태와 행동을 캡슐화하는 것에서 한 걸음 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어(access control) 메커니즘도 함께 제공한다.

13. 많은 프로그래밍 언어들은 접근 제어를 위해 public, protected, private과 같은 접근 수정자(access modifier)를 제공한다.

14. 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.

15. 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다.

16. 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.

17. 캡슐화와 접근 제어를 객체를 두 부분으로 나눈다.

18. 하나는 외부에서 접근 가능한 부분으로 이를 퍼블릭 인터페이스(public interface)라고 부른다.

19. 다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 구현(implementation)이라고 부른다.

20. 인터페이스와 구현의 분리(separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

21. 프로그래머의 역할을 클래스 작성자(class creator)와 클라이언트 프로그래머(client programmer)로 구분하는 것이 유용하다.

22. 클래스 작성자는 새로운 데이터 타입을 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.

23. 클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것이다.

24. 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다.

25. 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

26. 이를 구현 은닉(implementation hiding)이라고 부른다.

27. 구현 은닉은 클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념이다.

28. 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.

29. 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

30. 다시 말해 public 영역을 변경하지 않는다면 코드를 자유롭게 수정할 수 있다는 것이다.

31. 객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.

32. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

33. 객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 한다.

34. 대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 허용한다.

35. 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(Request)할 수 있다. 

36. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.

37. 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.

38. 메시지와 메서드를 구분하는 것은 매우 중요하다.

39. 메시지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.

40. 객체지향에서 중요하다고 여겨지는 두 가지 개념

41. 하나는 상속(inheritance)이고 다른 하나는 다형성이다.

42. 그리고 그 기반에는 추상화(abstraction)라는 원리가 숨겨져 있다.

43. 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라고 부른다.

44. 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

45. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라.

45. 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하라.

46. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.

47. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부른다.

48. 업캐스팅이라고 부르는 이유는 일반적으로 클래스 다이어그램을 작성할 때 부모 클래스를 자식 클래스의 위에 위치시키기 때문이다.

49. 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

50. 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.

51. 다시 말해 인터페이스가 동일해야 한다는 것이다.

52. 다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

53. 다시 말해 메시지와 메서드를 실행시점에 바인딩한다는 것이다.

54. 이를 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다.

55. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early bidning) 또는 정적 바인딩(static binding)이라고 부른다.

56. 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다. 

57. 상속을 구현 상속(implementation inheritance)과 인터페이스 상속(interface inheritance)으로 분류할 수 있다.

58. 흔히 구현 상속을 서브클래싱(subclassing)이라고 부르고 인터페이스 상속을 서브타이핑(subtyping)이라고 부른다. 

59. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속이라고 부른다.

60. 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속이라고 부른다.

61. 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. 

62. 추상화를 사용할 경우의 두 가지 장점

63. 첫 번째 장점은 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것이다.

64. 두 번째 장점은 추상화를 이용하면 설계가 좀 더 유연해진다는 것이다.

# 역할, 책임, 협력

1. 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.

2. 객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 부른다.

3. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다.

4. 객체를 가장 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.

5. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.

6. 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.

7. 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다.

9. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.

8. 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.

9. 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)을 제공한다.

10. 객체의 책임은 객체가 '무엇을 알고 있는가' 와 '무엇을 할 수 있는가'로 구성된다.

11. 객체의 책임을 크게 '하는 것(doing)'과 '아는 것(knowing)'의 두 가지 범주로 나누어 세분화하고 있다.

```

하는 것

- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것

- 다른 객체의 행동을 시작시키는 것

- 다른 객체의 활동을 제어하고 조절하는 것

아는 것

- 사적인 정보에 관해 아는 것

- 관련된 객체에 관해 아는 것

- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것


영화 예매 시스템에서..

Screening의 책임은? 

하는 것 -> 영화를 예매하는 것

아는 것 -> 자신이 상영할 영화

Move의 책임은?

하는 것 -> 요금을 계산하는 것

아는 것 -> 가격과 어떤 할인 정책이 적용 됐는지

```

12. 역할과 책임에 대한 CRC 카드 (P108) **

13. 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.

14. 또한 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.

15. 어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있는 것이다.

16. 객체지향 설계에서 가장 중요한 것은 책임이다.

17. 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.

18. 이를 책임 할당을 위한 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.

19. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.

20. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.

21. 책임을 갖고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임 주도 설계 (Resposibility-Driven Design, RDD)라고 부른다.

```

시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.

시스템 책임을 더 작은 책임으로 분할한다.

분활된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.

객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.

해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

```

22. 협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다.

23. 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.

24. 메시지가 객체를 선택해야 하는 두 가지 중요한 이유

25. 첫째, 객체가 최소한의 인터페이스(minimal interface)를 가질 수 있게 된다.

26. 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있다.

27. 둘째, 객체는 충분히 추상적인 인터페이스(abstract interface)를 가질 수 있게 된다. 객체의 인터페이스는 무엇(what)을 하는지는 표현해야 하지만 어떻게(how) 수행하는지를 노출해서는 안 된다.

28. 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.

29. 영화 예매 시스템의 경우 예매하라라는 메시지를 선택하는 것으로 설계를 시작했다는 것을 기억하라

30. 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.

31. 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다.

33. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.

34. 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파된다.

35. 이와 같이 객체의 내부 구현에 초점을 맞춘 설계 방법을 데이터-주도 설계(Data-Driven Desgin)라고 부르기도 했다.

36. 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.

37. 중요한 것은 객체의 상태가 아니라 행동이다. 협력이 객체의 행동을 결정하고 행동이 상태를 결정한다.

38. 그리고 그 행동이 바로 객체의 책임이 된다.

39. 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.

40. 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋다.

41. 역할은 다른 것으로 교체할 수 있는 책임의 집합이다. (P118) *

42. 추상 클래스와 인터페이스 (P119) *

