# 오브젝트

1. 객체, 설계

2. 객체지향 프로그래밍

3. 역할, 책임, 협력

4. 설계 품질과 트레이드오프

5. 책임 할당하기

6. 메시지와 인터페이스

7. 객체 분해

8. 의존성 관리하기

9. 유연한 설계

10. 상속과 코드 재사용

11. 합성과 유연한 설계

12. 다형성

13. 서브클래싱과 서브타이핑

14. 일관성 있는 협력

15. 디자인 패턴과 프레임워크

# 클래스 다이어그램 or 커뮤니케이션 다이어그램

# 패러다임의 시대

1. 과학혁명의 구조 kuhn12

2. 절차형 패러다임에서 객체지향 패러다임으로의 변화

3. 프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

4. 프로그래밍 패러다임은 혁명적이 아니라 발전적이다.

# 객체, 설계

1. 로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.

2. 여기서 모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.

```

모든 소프트웨어 모듈에는 세 가지 목적이 있다.

첫 번째 목적은 실행 중에 제대로 동작하는 것이다.

두 번째 목적은 변경을 위해 존재하는 것이다.

세 번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다.

```

3. 마틴에 따르면 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다.

4. 의존성은 변경에 대한 영향을 암시한다.

5. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

6. 객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.

```

P20

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public TicketOffice getTicketOffice() {
        return ticketOffice;
    }

}


-> 

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }

}

TicketSeller에서 getTicketOffice 메서드가 제거 됐다.

tickeOffice의 가시성이 private이고 접근 가능한 퍼블릭 메서드가 더 이상 존재하지 않기 때문에 외부에서는 tciketOffice에 직접 접근할 수 없다.

결과적으로 ticketOffice에 대한 접근은 오직 TicketSeller 안에만 존재하게 된다.

따라서 TicketSeller는 tickerOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로 수행할 수밖에 없다.

이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다.

수정된 Theater 클래스 어디서도 ticketOffice에 접근하지 않는다는 사실에 주목하라.

Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.

Theater는 단지 ticketSeller가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

Theater는 오직 TicketSeller의 인터페이스(interface)에만 의존한다.

TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation)의 영역에 속한다.

```

7. 객체의 자율성을 높이는 방향으로 설계를 개선하자, 이해하기 쉽고 유연한 설계를 얻을 수 있었다.

8. 캡슐화와 응집도의 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

9. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

10. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.

11. 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.

12. 프로세스와 데이터가 동일한 모듈 내부에 위치시키는 방식을 객체지향 프로그래밍이라고 부른다.

13. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

14. 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다.

15. TicketSeller의 책임은 무엇인가? 티켓은 판매하는 것이다.

16. Audience의 책임은 무엇인가? 티켓을 사는 것이다.

17. Theater의 책임은 무엇인가? 관람객을 입장시키는 것이다.

18. 적절한 객체에 적절한 책임을 할당하면 이해하기 쉬운 구조와 읽기 쉬운 코드를 얻게 된다.

19. 설계를 어렵게 만드는 것은 의존성이라는 것을 기억하라.

20. 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.

21. 예제에서 결합도를 낮추기 위해 선택한 방법은 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하는 것이다.

22. 결과적으로 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다.

# 객체지향 프로그래밍

1. 할인 조건(discount condition)과 할인 정책(discount policy)

2. 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

3. 첫째, 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.

4. 둘째, 객체를 독립전인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.

5. 소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다.

6. 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다.

6. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.

7. 도메인 개념들의 구조를 반영하는 적절한 클래스 구조를 만들기 (P72)

8. 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.

10. 두 가지 중요한 사실

9. 첫째, 객체가 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것

10. 둘째, 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것

11. 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다.

12. 대부분의 객체지향 프로그래밍 언어들은 상태와 행동을 캡슐화하는 것에서 한 걸음 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어(access control) 메커니즘도 함께 제공한다.

13. 많은 프로그래밍 언어들은 접근 제어를 위해 public, protected, private과 같은 접근 수정자(access modifier)를 제공한다.

14. 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.

15. 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다.

16. 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.

17. 캡슐화와 접근 제어를 객체를 두 부분으로 나눈다.

18. 하나는 외부에서 접근 가능한 부분으로 이를 퍼블릭 인터페이스(public interface)라고 부른다.

19. 다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 구현(implementation)이라고 부른다.

20. 인터페이스와 구현의 분리(separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

21. 프로그래머의 역할을 클래스 작성자(class creator)와 클라이언트 프로그래머(client programmer)로 구분하는 것이 유용하다.

22. 클래스 작성자는 새로운 데이터 타입을 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.

23. 클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것이다.

24. 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다.

25. 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

26. 이를 구현 은닉(implementation hiding)이라고 부른다.

27. 구현 은닉은 클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념이다.

28. 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.

29. 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

30. 다시 말해 public 영역을 변경하지 않는다면 코드를 자유롭게 수정할 수 있다는 것이다.

31. 객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.

32. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

33. 객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 한다.

34. 대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 허용한다.

35. 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(Request)할 수 있다. 

36. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.

37. 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.

38. 메시지와 메서드를 구분하는 것은 매우 중요하다.

39. 메시지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.

40. 객체지향에서 중요하다고 여겨지는 두 가지 개념

41. 하나는 상속(inheritance)이고 다른 하나는 다형성이다.

42. 그리고 그 기반에는 추상화(abstraction)라는 원리가 숨겨져 있다.

43. 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라고 부른다.

44. 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

45. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라.

45. 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하라.

46. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.

47. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부른다.

48. 업캐스팅이라고 부르는 이유는 일반적으로 클래스 다이어그램을 작성할 때 부모 클래스를 자식 클래스의 위에 위치시키기 때문이다.

49. 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

50. 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.

51. 다시 말해 인터페이스가 동일해야 한다는 것이다.

52. 다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

53. 다시 말해 메시지와 메서드를 실행시점에 바인딩한다는 것이다.

54. 이를 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다.

55. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early bidning) 또는 정적 바인딩(static binding)이라고 부른다.

56. 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다. 

57. 상속을 구현 상속(implementation inheritance)과 인터페이스 상속(interface inheritance)으로 분류할 수 있다.

58. 흔히 구현 상속을 서브클래싱(subclassing)이라고 부르고 인터페이스 상속을 서브타이핑(subtyping)이라고 부른다. 

59. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속이라고 부른다.

60. 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속이라고 부른다.

61. 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. 

62. 추상화를 사용할 경우의 두 가지 장점

63. 첫 번째 장점은 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것이다.

64. 두 번째 장점은 추상화를 이용하면 설계가 좀 더 유연해진다는 것이다.

# 역할, 책임, 협력

1. 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.

2. 객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 부른다.

3. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다.

4. 객체를 가장 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.

5. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.

6. 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.

7. 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다.

9. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.

8. 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.

9. 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)을 제공한다.

10. 객체의 책임은 객체가 '무엇을 알고 있는가' 와 '무엇을 할 수 있는가'로 구성된다.

11. 객체의 책임을 크게 '하는 것(doing)'과 '아는 것(knowing)'의 두 가지 범주로 나누어 세분화하고 있다.

```

하는 것

- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것

- 다른 객체의 행동을 시작시키는 것

- 다른 객체의 활동을 제어하고 조절하는 것

아는 것

- 사적인 정보에 관해 아는 것

- 관련된 객체에 관해 아는 것

- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것


영화 예매 시스템에서..

Screening의 책임은? 

하는 것 -> 영화를 예매하는 것

아는 것 -> 자신이 상영할 영화

Move의 책임은?

하는 것 -> 요금을 계산하는 것

아는 것 -> 가격과 어떤 할인 정책이 적용 됐는지

```

12. 역할과 책임에 대한 CRC 카드 (P108) **

13. 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.

14. 또한 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.

15. 어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있는 것이다.

16. 객체지향 설계에서 가장 중요한 것은 책임이다.

17. 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.

18. 이를 책임 할당을 위한 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.

19. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.

20. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.

21. 책임을 갖고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임 주도 설계 (Resposibility-Driven Design, RDD)라고 부른다.

```

시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.

시스템 책임을 더 작은 책임으로 분할한다.

분활된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.

객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.

해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

```

22. 협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다.

23. 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.

24. 메시지가 객체를 선택해야 하는 두 가지 중요한 이유

25. 첫째, 객체가 최소한의 인터페이스(minimal interface)를 가질 수 있게 된다.

26. 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있다.

27. 둘째, 객체는 충분히 추상적인 인터페이스(abstract interface)를 가질 수 있게 된다. 객체의 인터페이스는 무엇(what)을 하는지는 표현해야 하지만 어떻게(how) 수행하는지를 노출해서는 안 된다.

28. 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.

29. 영화 예매 시스템의 경우 예매하라라는 메시지를 선택하는 것으로 설계를 시작했다는 것을 기억하라

30. 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.

31. 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다.

33. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.

34. 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파된다.

35. 이와 같이 객체의 내부 구현에 초점을 맞춘 설계 방법을 데이터-주도 설계(Data-Driven Desgin)라고 부르기도 했다.

36. 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.

37. 중요한 것은 객체의 상태가 아니라 행동이다. 협력이 객체의 행동을 결정하고 행동이 상태를 결정한다.

38. 그리고 그 행동이 바로 객체의 책임이 된다.

39. 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.

40. 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋다.

41. 역할은 다른 것으로 교체할 수 있는 책임의 집합이다. (P118) *

42. 추상 클래스와 인터페이스 (P119) *

```

역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것이다.

협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것이다.

추상클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓았다는 차이가 있지만 협력의 관점에서 둘 모두 역할을 정의할 수 있는 구현 방법이라는 공통점을 공유한다.

```

43. 객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행해야 하는가?'라고 자문하는 것이 도움이 된다.

44. 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.

45. 만약 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.

46. 협력은 역할들의 상호작용으로 구성되고, 협력을 구성하기 위해 역할에 적합한 객체가 선택되며, 객체는 클래스를 이용해 구현되고 생성된다.

47. 연극 안에서 배역을 연기하는 배우라는 은유는 협력 안에서 역할을 수행하는 객체라는 관점이 가진 입체적인 측면들을 훌륭하게 담아낸다.

# 설계 품질과 트레이드오프

1. 객체지향 설계의 핵심은 역할, 책임, 협력이다.

2. 협력은 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용이다.

3. 책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동이고, 역할은 대체 가능한 책임의 집합이다.

4. 책임 주도 설계라는 이름에서 알 수 있는 것처럼 역할, 책임, 협력 중에서 가장 중요한 것은 '책임'이다.

5. 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.

6. 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다.

7. 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다.

8. 객체의 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다. 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.

9. 결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 된다.

9. 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화, 응집도, 결합도를 사용해보자

10. 캡슐화

- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다.

- 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.

- 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다.

- 변경될 가능성이 높은 부분을 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다는 사실을 기억하라.

- 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.

- 지금까지 설명한 내용에서 알 수 있는 것처럼 객체지향에서 가장 중요한 원리는 캡슐화다.

- 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.

- 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.

- 객체 내부에 무엇을 캡슐화해야 하는가?

- 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.

11. 응집도와 결합도

- 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.

- 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.

- 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.

- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.

- 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다.

12. 일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.

13. 높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 단 한가지다. 그것이 설계를 변경하기 쉽게 만들기 때문이다.

14. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.

15. 변경과 응집도 사이의 관계 (P151) ***

16. 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 

17. 응집도가 낮은 설계에서는 하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시에 수정해야 한다.

17. 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.

18. 결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.

19. 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거다.

20. 단일 책임 원칙 (SRP)

- 클래스는 단 한가지의 변경 이유만 가져야 한다는 것

21. 캡슐화는 설계의 제 1원리다.

22. 데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 캡슐화의 원칙을 위반했기 때문이다.

23. 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.

24. 속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.

25. Rectangle을 변경하는 주체를 외부의 객체에서 Rectangle로 이동시킨다. 자신의 크기를 Rectangle 스스로 증가시키도록 '책임을 이동'시키다. (P149) *

26. 객체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?"라는 질문은 다음과 같은 두 개의 개별적인 질문으로 분리해야 한다.

- 이 객체가 어떤 데이터를 포함해야 하는가?

- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

27. 두 질문을 조합하면 객체의 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다.

28. 데이터 중심의 설계가 변경에 취약한 이유 두 가지

- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.

- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

29. 데이터 중심의 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

# 책임 할당하기

1. 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 두 가지 원칙을 따라야 한다.

- 데이터보다 행동을 먼저 결정하라

- 협력이라는 문맥 안에서 책임을 결정하라

2. 협력이라는 문맥에서 적절한 책임이란 곧 클라이언트의 관점에서 적절한 책임을 의미한다.

3. 올바른 객체지향 설계는 클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민하기 시작한다.

4. GRASP 패턴 (General Responsibility Assignment Software Pattern) 일반적인 책임 할당을 위한 소프트웨어 패턴의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

5. 도메인 개념에서 출발하기

6. 설계를 시작하기 전에 도메인 대한 개략적인 모습을 그려 보는 것이 유용하다.

7. 정보 전문가에게 책임을 할당하라

8. 책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.

9. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.

10. 메시지를 전송할 객체는 무엇을 원하는가?

11. 메시지를 수신할 적합한 객체는 누구인가?

12. 이 질문에 답하기 위해서는 객체가 상태와 행동을 통합한 캡슐화의 단위라는 사실에 집중해야 한다.

13. 따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.

14. 이를 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.

15. INFORMATION EXPERT 패턴은 객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행한다는 일반적인 직관을 표현한 것이다.

16. 여기서 이야기하는 정보는 데이터와 다르다는 사실에 주의하라.

17. 책임을 수행하는 객체가 정보를 '알고'있다고 해서 그 정보를 '저장'하고 있을 필요는 없다.

18. 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.

19. 다시 말해 두 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다는 것이다.

20. GRASP에서는 이를 LOW COUPLING(낮은 결합도)
 패턴과 HIGH COHESION(높은 응집도) 패턴이라고 부른다.

21. LOW COUPLING 패턴

- 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?

- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.

- 낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다.

22. HIGH COHESION 패턴

- 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?

- 높은 응집도를 유지할 수 있게 책임을 할당하라

- 낮은 결합도처럼 높은 응집도 역시 모든 설계 결정에서 염두에 둬야 할 원리다.

23. Screening의 가장 중요한 책임은 예매를 생성하는 것이다. (P174) **

```

만약 Screening이 DiscountCondition과 협력해야 한다면 Screnning은 영화 요금 계산과 관련된 책임 일부를 떠안아야 할 것이다.

이 경우 Screening은 DiscountCondition이 할인 여부를 판단할 수 있고 Movie가 이 할인 여부를 필요로 한다는 사실 역시 알고 있어야 한다.

다시 말해서 예매 요금을 계산하는 방식이 변경될 경우 Screening도 함께 변경해야 하는 것이다.

결과적으로 Screening과 DiscountCondition이 협력하게 되면 Screening은 서로 다른 이유로 변경되는 책임을 짊어지게 되므로 응집도가 낮아질 수밖에 없다.

반면 Movie의 주된 책임은 영화 요금을 계산하는 것이다.

따라서 영화 요금을 계산하는 데 필요한 할인 조건을 파단하기 위해 Movie가 DiscountCondition과 협력하는 것은 응집도에 아무런 해도 끼치지 않는다.

```

24. 창조자에게 객체 생성 책임을 할당하라

25. 영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것이다.

26. 이것은 협력에 참여하는 어떤 객체에게는 Reservation 인스턴스를 생성할 책임을 할당해야 한다는 것을 의미한다.

27. CREATOR(창조자) 패턴은 이 같은 경우에 사용할 수 있는 책임 할당 패턴으로서 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.

28. CREATOR 패턴

- 객체 A를 생성할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?

- 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라

```

B가 A객체를 포함하거나 참조한다.

B가 A 객체를 기록한다.

B가 A 객체를 긴밀하게 사용한다.

B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (이 경우 B는 A에 대한 정보 전문가다)

```

- CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.

- 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.

- 다시 말해서 두 객체는 서로 결합된다.

- 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.

29. 구현을 통한 검증 (P176) ****