# 지은이 웨스 맥키니

- 데이터 분석, 금융, 통계 계산 애플리케이션에서 파이썬 사용을 독려하고 있다.

- 모든 코드는 파이썬 3.6기반으로 수정

- pandas 라이브러리 버전을 2017년 버전

# 필수 라이브러리

1. Numpy

- 넘파이(Numerical Python, NumPy)는 파이썬 산술 계산의 주춧돌 같은 라이브러리다.

- 자료구조, 알고리즘 산술 데이터를 다루는 대부분의 과학 계산 애플리케이션에서 필요한 라이브러리를 제공한다.

- NumPy가 제공하는 기능

```

빠르고 효율적인 다차원 배열 객체 ndarray

배열 원소를 다루거나 배열 간의 수학 계산을 수행하는 함수

디스크로부터 배열 기반의 데이터를 읽거나 쓸 수 있는 도구

선형대수 계산, 푸리에 변환, 난수 생성기

파이썬 확장과 C, C++ 코드에서 NumpPy의 자료구조에 접근하고 계산 기능을 사용할 수 있도록 해주는 C API 

```

- 고속 배열 처리 외에도 NumPy는 데이터분석 알고리즘에 사용할 데이터 컨테이너의 역할을 한다.

- 수치 데이터라면 Numpy 배열은 파이썬 내장 자료구조보다 훨씬 효율적인 방법으로 데이터를 저장하고 다룰 수 있다.

2. pandas

- 팬더스(pandas)는 구조화된 데이터나 표 형식의 데이터를 빠르고 쉽고 표현적으로 다루도록 설계된 고수준의 자료구조와 함수를 제공한다.

- 2010년 처음 개발되어 파이썬으로 생산적이고 강력한 데이터 분석 환경을 구성하는 데 도움을 주고 있다.

- pandas의 주된 자료구조는 표형태의 로우와 컬럼 이름을 가지는 DataFrame(데이터프레임)과 1차원 배열 객체인 Series(시리즈)다.

- pands는 'NumPy의 고성능, 배열 연산 아이디어'에 스프레드시트와 관계형 데이터베이스(SQL 같은)의 유연한 데이터 처리 기능을 결합한 것이다.

- 세련된 색인 기능을 제공하여 데이터 변형, 자르기, 취합 그리고 데이터의 부분집합을 선택할 수 있도록 해준다.

- 데이터를 처리하고 준비하고 다듬는 과정은 데이터 분석에서 가장 중요한 부분이므로 pandas는 이 책에서 우선적으로 집중하는 라이브러리다.

- pandas의 많은 기능은 R 핵심 구현의 일부 또는 애드온 패키지에서 따왔다.

- pands라는 이름은 다차원으로 구조화된 데이터를 뜻하는 경제학 용어인 패널 데이터와 파이썬 데이터 분석에서 따온 이름이다.

3. matplotlib

- matplotlib(맷플롯립)은 그래프나 2차원 데이터 시각화를 생성하는 유명한 파이썬 라이브러리다.

- 존 D. 헌터가 만들었고 지금은 많은 개발 팀이 유지하고 있다.

- 출판물에 필요한 그래프를 만드는 데 맞춰 설계되었다.

- 기본 시각화 도구로 가장 안전한 선택이라고 생각한다.

4. IPython과 Jupyter

- IPython(아이파이썬, 인터랙티브 파이썬(Interactive Python))은 더 나은 대화형(인터랙티브) 파이썬 인터프리터를 만들 목적으로 2001년 페르난도 페레즈가 취미 프로젝트로 시작했다.

- IPython 자체는 계산이나 데이터 분석 도구로서의 기능을 제공하지는 않지만 대화형 컴퓨팅과 소프트웨어 개발 양쪽 모두에서 생산성을 극대화할 수 있도록 설계되었다.

- IPython은 많은 프로그래밍 언어들의 특징인 전통적인 편집-컴파일-실행 방식 대신에 실행-탐색 방식을 장려하며 파일시스템과 운영체제 셸에도 쉽게 접근할 수 있다.

- 2014년 페르난도와 IPython 팀은 언어에 상관없이 대화형 컴퓨팅 도구를 설계할 수 있는 주피터(Jupyter) 프로젝트를 발표했다.

- IPython 시스템은 이제 주피터에서 파이썬을 사용할 수 있게 해주는 커널(프로그래밍 언어 모드)로 역할을 변경했다.

- 주피터 노트북에서도 IPython 시스템을 여전히 사용할 수 있는데, '노트북'이라고 하는 웹 기반의 대화형 코드 작성 환경은 다양한 프로그래밍 언어를 지원한다.

- 주피터 노트북 시스템은 노트북 내용을 마크다운이나 HTML로 저장할 수 있게 한다.

- 이를 통해 코드와 텍스트를 포함하는 문서를 생성할 수 있다.

- 다른 프로그래밍 언어도 주피터 환경을 위한 커널이 구현되어 있다면 파이썬 대신 주피터 환경에서 사용할 수 있다.

- 개인적으로 파이썬 코드를 실행하거나 디버깅, 테스트 작업을 할 때는 거의 항상 IPython을 사용한다.

5. SciPy

- SciPy(사이파이)는 과학 계산 컴퓨팅 영역의 여러 기본 문제를 다루는 패키지 모음이다.

- 다음은 SciPy에 포함된 패키지 중 일부다.

```

scipy.integrate - 수치적분 루틴과 미분방적식 풀이법

scipy.linalg - numpy.linalg에서 제공하는 것보다 더 확장된 선형대수 루틴과 매트릭스 분해

scipy.optimize - 함수 최적화기와 방정식의 근을 구하는 알고리즘

scipy.signal - 시그널 프로세싱 도구

scipy.sparse - 희소 행렬과 희소 선형 시스템 풀이법

scipy.special - 감마 함수처럼 흔히 사용되는 수학 함수를 구현한 포트란 라이브러리인 SPECFUN 래퍼

scipy.stats - 표준 연속/이산 확률 분포(밀도 함수, 샘플러, 연속 분포 함수)와 다양한 통계 테스트 그리고 좀 더 기술적인 통계도구

```

- NumPy와 SciPy를 함께 사용하면 전통적인 과학 계산 애플리케이션에서 제공하는 거의 모든 기능을 대체할 수 있다.

6. scikit-learn

- scikit-leran(사이킷런)은 처음 개발되기 시작한 2010년부터 파이썬 개발자를 위한 범용 머신러닝 도구로 자리 잡기 시작했다.

- 다음과 같은 모델의 하위모듈을 포함한다.

```

분류: SVM, 최근접 이웃, 랜덤 포레스트, 로지스틱 회귀 등

회귀: 라소, 리지 회귀 등

클러스터링: K-평균, 스펙트럴 클러스터링 등

차원 축소: PCA, 특징 선택, 행렬 인수분해 등

모델 선택: 격자탐색, 교차검증, 행렬

전처리: 특징 추출, 정규화

```

7. statsmodels

- statsmodels은 다양한 R 언어용 회귀분석 모델을 구현한 스탠퍼드 대학의 통계학 교수인 조나단 테일러의 작업을 기반으로 만들어진 통계분석 패키지다.

- 스키퍼 시볼드와 죠세프 퍼크톨드가 2010년에 새로운 statsmodels 프로젝트를 시작한 이후 수많은 사용자와 오픈소스 기여자에게 빼놓을 수 없는 프로젝트로 성장했다.

- 나다니엘 스미스는 R 언어의 포뮬러 시스템에서 착안하여 statsmodels용 포뮬러 또는 모델 명세 프레임워크를 제공하는 Patsy(팻시) 프로젝트를 개발했다.

- scikit-learn과 비교하여 statsmodels는 전통적인 통계(주로 빈도주의적 접근)와 계량경제학 알고리즘을 포함하고 있다.

- 다음과 같은 하위모듈을 포함한다.

```

회귀 모델: 선형회귀, 일반화 선형 모델, 로버스트 선형 모델, 선형 혼합효과 모델 등

분산분석(ANOVA: analysis of variance)

시계열분석: AR, ARMA, ARIMA, VAR 및 기타 모델

비모수 기법: 커널밀도추정, 커널회귀

통계 모델 결과의 시각화

```

- statsmodels는 통계추론에 좀 더 초점을 맞추고 있다.

- 인자를 위한 불확실성 예측치와 p 값을 제공한다.

- 반면 scikit-learn은 좀 더 예측에 초점을 맞추고 있다.

# IPython

1. 탭 자동완성 

- an<탭키>

2. 자기관찰 ?

- add_numbers?, print?

- ??를 사용하면 가능한 경우 함수의 소스 코드도 보여준다. add_number??

- 와일드카드 기호와 함께 사용한 문자와 일치하는 모든 이름을 보여준다. np.*load*?

3. %run 명령어

- %run 명령어를 사용하면 IPython 세션 안에서 파이썬 프로그램 파일을 불러와서 실행할 수 있다.

4. 매직 명령어

- $quickref, $magic 등 사용 가능한 모든 특수 명령어를 살펴보는 것도 좋다.

# 시맨틱

- 파이썬은 가독성과 명료성 그리고 명백함을 강조한다.

- 한 줄에 여러 문장을 쓰는 것은 가독성을 해친다는 이유로 파이썬에서는 지양하는 습관이다.

- 파이썬 언어의 중요한 특징 중 하나는 객체 모델의 일관성이다.

- 파이썬에서 모든 객체는 특정한 자료형(또는 클래스)을 가지며 어떤 명백한 상황에서만 묵시적인 변환을 수행하는 자료형을 구분하는 강한 타입의 언어라고 한다.

- isinstance 함수를 이용해 어떤 객체가 무슨 자료형인지 검사할 수 있다.

- is와 is not은 변수가 None인지 검사하기 위해 흔히 사용한다.

- 뮤터블, 이뮤터블 객체

```

파이썬에서 리스트, 사전, NumPy 배열 또는 사용자 정의 클래스 같은 대부분의 객체는 변경 가능하다(뮤터블)

문자열이나 튜플은 변경 불가능하다(이뮤터블)

```

# 스칼라형

- 파이썬은 숫자 데잍어ㅘ 문자열, 불리언값(True or False) 그리고 날짜와 시간을 다룰 수있는 몇몇 내장 자료형을 제공한다.

- 이런 '단일 값'을 담는 자료형을 스칼라 타입이라고 한다.

```

None - 파이썬의 'Null' 값 (하나의 유일한 None 인스턴스만 존재한다.)

str - 문자열 자료형. 유니코드(UTF-8 인코딩) 문자열

bytes - Raw ASCII 바이트(또는 바이트로 인코딩된 유니코드)

float - 배정밀도(64비트) 부동소수점수. double 형은 따로 존재하지 않는다

bool - True or False

int - 부호가 있는(음수 표현이 가능한) 정수. 값의 범위는 플랫폼에 의존적

```

# 자료구조와 순차 자료형

# 튜플

1. 튜플은 1차원의 고정된 크기를 가지는 변경 불가능한 순차 자료형이다.

2. 튜플을 생성하는 가장 쉬운 방법은 쉼표로 구분된 값을 대입하는 것이다.

- tup = 1, 2, 3 => (1, 2, 3)

3. 괄호를 사용해서 값을 묶어줌으로써 중첩된 튜플을 정의할 수 있다. tup = (4, 5, 6), (7, 8) => ((4, 5, 6), (7, 8))

4. + 연산자를 이용해서 튜플을 이어붙일 수 있다. (4, None, 'foo') + (6, 0) + ('bar', ) => (4, None, 'foo', 6, 0, 'bar')

# 튜플에서 값 분리하기

1. 튜플과 같은 표현의 변수에 튜플을 대입하면 파이썬은 등호(=) 오른쪽에 있는 변수에서 값을 분리한다.

```

tup = 4, 5, 6

a, b, c = tup

a = 4, b = 5, c = 6

파이썬에서는 다음과 같이 하여 두 변수의 값을 쉽게 바꿀 수 있다.

b, a = a, b

튜플이나 리스트를 순회할 때도 흔히 이 기능을 활용한다

seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]

for a, b, c in seq:
    print('a={0}, b={1}, c={2}'.format(a, b, c))


a=1, b=2, c=3
a=4, b=5, c=6
a=7, b=8, c=9



```

# 리스트

1. 정렬

```

sort 함수를 이용해서 새로운 리스트를 생성하지 않고 있는 그대로 리스트를 정렬할 수 있다.

sort는 편의를 위해 몇 가지 옵션을 제공한다.

b = ['saw', 'small', 'he', 'foxes', 'six']

b.sort(key=len)

['he', 'saw', 'six', 'small', 'foxes']

```

2. 슬라이싱

```

HELLO!

string[2:4]

LL

string[-5:-2]

ELL

두 번째 콜론 다음에 간격(step)을 지정할 수 있는데, 하나 걸러 다음 원소를 선택하려면 다음과 같이 표현된다.

seq = [7, 2, 3, 6, 3, 5, 6, 0, 1]

seq[::2]

[7, 3, 3, 6, 1]

간격 값으로 -1을 사용하면 리스트나 튜플을 역순으로 반환한다.

seq[::-1]

[1, 0, 6, 5, 3, 6, 3, 2, 7]

```

# 내장 순차 자료형 함수

1. enumerate

- 순차 자료형에서 현재 아이템의 색인을 함께 처리하고자 할 때 흔히 사용한다.

```

i = 0

for value in collection:
    # value를 사용하는 코드
    i += 1

for i, value in enumerate(collection):
    # value를 사용하는 코드 작성

색인을 통해 데이터에 접근할 때 enumerate를 사용하는 유용한 패턴은 순차 자료형에서의 값과 그 위치를 dict에 넘겨주는 것이다.

```

2. zip

```

zip 함수는 여러 개의 리스트나 튜플 또는 다른 순차 자료형을 서로 짝지어서 튜플의 리스트를 생성한다.

seq1 = ['foo', 'bar', 'baz']

seq2 = ['one', 'two', 'three']

zipped = zip(seq1, seq2)

list(zipped)

[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]

zip 함수의 아주 흔한 사용 예는 여러 개의 순차 자료형을 동시에 순회하는 경우인데 enumerate와 함께 사용되기도 한다.

for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))

0: foo, one
1: bar, two
2: baz, three

```

# 사전

```

dict(사전)는 파이썬 내장 자료구조 중에서 가장 중요하다.

일반적으로 해시맵 또는 연관 배열이라고도 널리 알려져 있다.

사전은 유연한 크기를 가지는 키-값 쌍으로, 키와 값은 모두 파이썬 객체다.

사전을 생성하는 방법은 중괄호 {}를 사용하여 콜론으로 구분된 키와 값을 둘러싸는 것이다.

empty_dict = {}

d1 = {'a' : 'some value', 'b' : [1, 2, 3, 4]}

d1[7] = 'an integer'

d1 = {'a' : 'some value', 'b' : [1, 2, 3, 4], 7 : 'an integer'}

del 예약어나 pop 메서드(값을 반환함과 동시에 해당 키를 삭제한다)를 사용해서 사전의 값을 삭제할 수 있다.

keys와 values 메서드는 각각 키와 값이 담긴 이터레이터를 반환한다.

키-값 쌍은 일정한 기준으로 정렬되어 있진 않지만 keys 메서드와 values 메서드에서 반환하는 리스트는 같은 순서를 가진다.

update 메서드를 사용해서 하나의 사전을 다른 사전과 합칠 수 있다.

update 메서드는 사전 값을 그 자리에서 바꾸므로 이미 존재하는 키에 대해 update를 호출하면 이전 값을 사라진다.

mapping = {}

for key, value in zip(key_list, value_list):
    mapping[key] = value

mapping = dict(zip(range(5), reversed(range(5))))

get 메서드는 기본적으로 해당 키가 존재하지 않을 경우 None을 반환하며, pop 메서드는 예외를 발생시킨다.

보통 사전에 값을 대입할 때는 리스트 같은 다른 컬렉션에 있는 값을 이용하는데, 예를 들어 여러 단어를 시작 글자에 따라 사전에 리스트로 저장하고 싶다면 다음처럼 할 수 있다.

words = ['apple', 'bat', 'bar', 'atom', 'book']

by_letter = {}

for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].attend(word)
    
by_letter
{'a' : ['apple', 'atom'], 'b' : ['bat', 'bar', 'book']}

사전의 setdefault 메서드를 바로 이 목적으로 사용한다. 위 코드에서 if-else 블록은 다음처럼 작성할 수 있다.

for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)

내장 collections 모듈은 defaultdict라는 유용한 클래스를 담고 있는데, 이 클래스를 사용하면 위 과정을 좀 더 쉽게 할 수 있다.

자료형, 혹은 사전의 각 슬롯에 담길 기본값을 생성하는 함수를 넘겨서 사전을 생성하는 것이다.

from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)

유효한 사전 키

사전의 값으로 어떤 파이썬 객체라도 가능하지만 키는 스칼라형(정수, 실수, 문자열)이나 튜플(튜플에 저장된 값 역시 값이 바뀌지 않는 객체여야 한다)처럼 값이 바뀌지 않는 객체만 가능하다.

기술적으로는 해시 가능해야 한다는 뜻이다.

어떤 객체가 해시 가능한지(즉, 사전의 키로 사용할 수 있는지)는 hash 함수를 사용해서 검사할 수 있다.

hash('string')
50~..

hash((1, 2, (2, 3)))
10~..

hash((1, 2, [2, 3]))
Error -> 리스트는 변경이 가능하기 때문에, 리스트를 키로 하기 위해서는 tuple로 변환해야 한다.

```

# 집합

```

set(집합)은 유일한 원소만 담는 정렬되지 않은 자료형이다.

사전과 유사하지만 값은 없고 키만 가지고 있다고 생각하면 된다.

집합은 두 가지 방법으로 생성할 수 있는데 set 함수를 이용하거나 중괄호를 이용해서 생성할 수 있다.

집합은 합집합, 교집합, 차집합, 대칭차집합 같은 산술 집합 연산을 제공한다.

어떤 집합이 다른 집합의 부분집합인지 확대집합인지 검사할 수도 있다.

a_set = {1, 2, 3, 4, 5}

{1, 2, 3}.issubset(a_set)
True

a_set.issuperset({1, 2, 3})
True

{1, 2, 3} == {3, 2, 1}
True

```

# 리스트, 집합, 사전 표기법

```

리스트 표기법은 파이썬 언어에서 가장 사랑받는 기능 중 하나다.

이를 이용하면 간결한 표현으로 새로운 리스트를 만들 수 있다.

[expr for val in collection if condition]

이를 반복문으로 구현하면 다음과 같다.

result = []

for val in collection:
    if condition:
        result.append(expr)

필터 조건은 생략 가능하다.

예를 들어 문자열 리스트가 있다면 아래처럼 문자열의 길이가 2 이하인 문자열은 제외하고 나머지를 대문자로 바꾸는 게 가능하다.

strings = ['a', 'as', 'bat', 'car', 'dove', 'python']

[x.upper() for x in strings if len(x) > 2]
['BAT', 'CAR', 'DOVE', 'PYTHON']

집합과 사전에 대해서도 리스트 표기법과 같은 방식으로 적용할 수 있다.

사전 표기법은 다음과 같다.

dict_comp = {key-expr : value-expr for value in collection if condition}

집합 표기법은 대괄호 대신 중괄호를 쓴다는 점만 빼면 리스트 표기법과 동일하다.

set_comp = {expr for value in collection if condition}

리스트 내의 문자열들의 길이를 담고 있는 집합을 생성하려면 집합 표기법을 이용하여 다음과 같이 처리할 수 있다.

unique_lengths = {len(x) for x in strings}

map 함수를 이용해서 함수적으로 표현할 수도 있다.

set(map(len, strings))

사전 표기법의 예제로, 리스트에서 문자열의 위치를 담고 있는 사전을 생성하보자

loc_mapping = {val : index for index, val in enumerate(strings)}

loc_mapping
{'a': 0, 'as': 1, 'bat' : 2, 'car' : 3, 'dove' : 4, 'python' : 5}

중첩된 리스트 표기법

다음과 같이 영어 이름과 스페인어 이름을 담고 있는 리스트의 리스트가 있다고 하자.

all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'], ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]

몇몇 파일에서 이들 이름을 읽어 와서 영어와 스페인어 이름을 따로 저장했으며 각 이름에서 알파벳 e가 2개 이상 포함된 이름의 목록을 구한다고 가정하자.

리스트는 for 문을 사용해서 다음처럼 구할 수 있다.

names_of_interest = []

for names in all_data:
    enough_es = [name for name in names if name.count('e') >= 2]
    names_of_interest.extends(enough_es)

위 코드 전체를 중첩된 리스트 표기법을 이용해서 다음처럼 한 번에 구현할 수 있다.

result = [name for names in all_data for name in names if name.count('e') >= 2]

```

# 네임스페이스, 스코프, 지역 함수

```

함수는 전역과 지역, 두 가지 스코프(영역)에서 변수를 참조한다.

변수의 스코프를 설명하는 다른 용어로 네임스페이스가 있다.

함수 내에서 선언된 변수는 기본적으로 모두 지역 네임스페이스에 속한다.

지역 네임스페이스는 함수가 호출될 때 생성되며 함수의 인자를 통해 즉시 생성된다.

함수의 실행이 끝나면 지역 네임스페이스는 사라진다

def func():
    a = []
    for i in range(5):
        a.append(i)

```

# 여러 값 반환하기

```

하나의 함수에서 여러 개의 값을 반환할 수 있다.

def f():
    a = 5
    b = 6
    c = 7
    return a, b, c

a, b, c = f()

데이터 분석과 과학 계산 애플리케이션에서는 많은 함수가 여러 개의 값을 반환하는 일이 잦다는 사실을 깨닫게 될 것이다.

앞서 살펴본 튜플을 생각해보면 이 함수는 하나의 객체, 말하자면 튜플을 반환한다고 생각할 수 있다.

return_value = f()

여기서 return_value는 짐작한 대로 반환된 세 개의 값을 가지고 있는 튜플이 된다.

다른 매력적인 대안으로는 여러 값을 반환하는 대신 사전 형태로 반환하는 것이다.

def f():
    a = 5
    b = 6
    c = 7
    return {'a' : a, 'b' : b, 'c' : c}

```

# 익명 함수

```

파이썬은 익명(anonymous)함수 혹은 람다(lambda)함수라고 하는 값을 반환하는 단순한 한 문장으로 이루어진 함수를 지원한다.

lambda 예약어로 정의하며, 이는 '익명 함수를 선언한다'라는 의미다.

def short_function(x):
    return x * 2

equiv_anon = lambda x: x * 2

람다 함수는 데이터 분석에서 특히 편리한데, 이는 앞으로 알게 되겠지만 데이터를 변형하는 함수에서 인자로 함수를 받아야 하는 경우가 매우 많기 때문이다.

즉, 람다 함수를 사용하면 실제 함수를 선언하거나 람다 함수를 지역 변수에 대입하는 것보다 코드를 적게 쓰고 더 간결해지기 때문이다.

def apply_to_list(some_list, f):
    return [f(x) for x in some_list]

ints = [4, 0, 1, 5, 6]
apply_to_list(ints, lambda x: x * 2)

물론 [x * 2 for x in ints]라고 해도 되지만 이렇게 하면 apply_to_list 함수에 사용자 연산을 간결하게 전달할 수 있다.

다른 예제로, 다음 문자열 리스트를 각 문자열에서 다양한 문자가 포함된 순서로 정렬한다고 가정하자

strings = ['foo', 'card', 'bar', 'aaaa', 'abab']

strings.sort(key=lambda x: len(set(list(x))))

strings
['aaaa', 'foo', 'abab', 'bar', 'card']

```

# 제너레이터

```

파이썬은 리스트 내의 객체나 파일의 각 로우 같은 순차적인 자료를 순회하는 일반적인 방법을 제공한다.

이터레이터 프로토콜을 이용해 순회 가능한 객체를 만들 수 있다.

예를 들어 사전을 순회하면 사전의 키가 반환된다.

some_dict = {'a' : 1, 'b': 2, 'c': 3}

dict_iterator = iter(some_dict)

list(dict_iterator)

['a', 'b', 'c']

제너레이터를 생성하는 더 간단한 방법은 제너레이터 표현식을 사용하는 것이다.

다음은 리스트, 사전, 집합 표현식과 유사한 방식으로 제너레이터를 생성한다.

리스트 표현식에서 대괄호를 사용하듯이 괄호를 사용해서 제너레이터를 생성할 수 있다.

gen = (x ** 2 for x in range(100))

dict((i, i**2) for i in range(5))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

```


# NumPy 기본: 배열과 벡터 ㅕㅇㄴ산

1. NumPy에서 제공하는 것들

```

효율적인 다차원 배열인 ndarray는 빠른 배열 계산과 유연한 브로드캐스팅 기능을 제공한다.

반복문을 작성할 필요 없이 전체 데이터 배열을 빠르게 계산할 수 있는 표준 수학 함수

배열 데이터를 디스크에 쓰거나 읽을 수 있는 도구와 메모리에 적재된 파일을 다루는 도구

선형대수, 난수 생성기, 푸리에 변환 기능

C, C++, 포트란으로 작성한 코드를 연결할 수 있는 C API

```

2. 대부분의 데이터 분석 애플리케이션에서 필자가 중요하게 생각하는 기능

```

벡터 배열 상에서 데이터 가공(데이터 먼징 또는 데이터 랭글링), 정제, 부분집합, 필터링, 변형 그리고 다른 여러 종류의 연산을 빠르게 수행

정렬, 유일 원소 찾기, 집합 연산 같은 일반적인 배열 처리 알고리즘

통계의 효과적인 표현과 데이터를 수집 요약하기

다양한 종류의 데이터를 병합하고 엮기 위한 데이터 정렬과 데이터 간의 관계 조작

내부에서 if - elif - else를 사용하는 반복문 대신 사용할 수 있는 조건절 표현을 허용하는 배열 처리

데이터 묶음 전체에 적용할 수 있는 수집, 변형, 함수 적용 같은 데이터 처리

```

3. NumPy는 일반적인 산술 데이터 처리를 위한 기반 라이브러리를 제공하기 때문에 많은 독자가 통계나 분석, 특히 표 형식의 데이터를 처리하기 위해 pandas를 사용하기 원할 것이다.

4. NumPy가 파이썬 산술 계산 영역에서 중요한 위치를 차지하는 이유 중 하나는 대용량 데이터 배열을 효율적으로 다룰 수 있도록 설계되었다는 점이다.

```

NumPy는 내부적으로 데이터를 다른 내장 파이썬 객체와 구분된 연속된 메모리 블록에 저장한다.

NumPy의 각종 알고리즘은 모두 C로 작성되어 타입 검사나 다른 오버헤드 없이 메모리를 직접 조작할 수 있다.

NumPy 배열은 또한 내장 파이썬의 연속된 자료형들보다 훨씬 더 적은 메모리를 사용한다.

NumPy 연산은 파이썬 반복문을 사용하지 않고 전체 배열에 대한 복잡한 계산을 수행할 수 있다.

```

# ndarray 생성하기

```

배열을 생성하는 가장 쉬운 방법은 array 함수를 이용하는 것이다.

순차적인 객체(다른 배열도 포함하여)를 넘겨받고, 넘겨받은 데이터가 들어 있는 새로운 NumPy 배열을 생성한다.

예를 들어 파이썬의 리스트는 변환하기 좋은 예다.

data1 = [6, 7.5, 8, 0, 1]

arr1 = np.array(data1)

arr1

array([6 ,7.5 , 8. , 0. , 1.])

배열 생성 함수 표 4.1 (139P)

```

# ndarray의 dtype

1. dtype은 ndarray가 메모리에 있는 특정 데이터를 해석하기 위해 필요한 정보(또는 메타데이터)를 담고 있는 특수한 객체다.

```

arr1 = np.array([1, 2, 3], dtype=np.float64)

arr1.dtype
dtype('float64')

ndarray의 astype 메서드를 사용해서 배열의 dtype을 다른 형으로 명시적으로 변환(또는 캐스팅) 가능하다.

arr = np.array([1, 2, 3, 4, 5])

arr.dtype
dtype('int64')

float_arr = arr.astype(np.float64)

float_arr.dtype
dtye('float64')

```

# NumPy 배열의 산술 연산

1. 배열의 중요한 특징은 for 문을 작성하지 않고 데이터를 일괄 처리할 수 있다는 것이다.

2. 이를 벡터화라고 하는데, 같은 크기의 배열 간의 산술 연산은 배열의 각 원소 단위로 적용된다.

# 색인과 슬라이싱 기초

1. NumPy 배열 색인에 대해서는 다룰 주제가 많다.

2. 데이터의 부분집합이나 개별 요소를 선택하기 위한 수많은 방법이 존재한다.

3. 1차원 배열은 단순한데, 표면적으로는 파이썬의 리스트와 유사하게 동작한다.

```

arr = np.arange(10)

arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

arr[5]
5

arr[5:8]
array([5, 6, 7])

arr[5:8] = 12

arr
array([0, 1, 2, 3, 4, 12, 12, 12, 8, 9])

배열 조각에 스칼라 값을 대입하면 12가 선택 영연 전체로 전파(또는 브로드캐스팅)된다.

리스트와의 중요한 차이점은 배열 조각은 원본 배열의 뷰라는 점이다.

즉, 데이터는 복사되지 않고 뷰에 대한 변경은 그대로 원본 배열에 반영된다.

arr_slice = arr[5:8]

arr_slice
array([12, 12, 12])

arr_slice[1] = 12345

arr
array([0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])

arr_slice[:] = 64

arr
array([0, 1, 2, 3, 4, 64, 64, 64, 8, 9])

NumPy를 처음 접한다면, 특히 데이터 복사가 자주 일어나는 다른 배열 프로그래밍 언어를 사용해본 적이 있다면 데이터가 복사되지 않는다는 점은 놀랄 만한 사실이다.

NumPy는 대용량의 데이터 처리를 염두에 두고 설계되었기 때문에 만약 NumPy가 데이터 복사를 남발한다면 

```