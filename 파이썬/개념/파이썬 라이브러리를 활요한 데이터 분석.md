# 지은이 웨스 맥키니

- 데이터 분석, 금융, 통계 계산 애플리케이션에서 파이썬 사용을 독려하고 있다.

- 모든 코드는 파이썬 3.6기반으로 수정

- pandas 라이브러리 버전을 2017년 버전

# 필수 라이브러리

1. Numpy

- 넘파이(Numerical Python, NumPy)는 파이썬 산술 계산의 주춧돌 같은 라이브러리다.

- 자료구조, 알고리즘 산술 데이터를 다루는 대부분의 과학 계산 애플리케이션에서 필요한 라이브러리를 제공한다.

- NumPy가 제공하는 기능

```

빠르고 효율적인 다차원 배열 객체 ndarray

배열 원소를 다루거나 배열 간의 수학 계산을 수행하는 함수

디스크로부터 배열 기반의 데이터를 읽거나 쓸 수 있는 도구

선형대수 계산, 푸리에 변환, 난수 생성기

파이썬 확장과 C, C++ 코드에서 NumpPy의 자료구조에 접근하고 계산 기능을 사용할 수 있도록 해주는 C API 

```

- 고속 배열 처리 외에도 NumPy는 데이터분석 알고리즘에 사용할 데이터 컨테이너의 역할을 한다.

- 수치 데이터라면 Numpy 배열은 파이썬 내장 자료구조보다 훨씬 효율적인 방법으로 데이터를 저장하고 다룰 수 있다.

2. pandas

- 팬더스(pandas)는 구조화된 데이터나 표 형식의 데이터를 빠르고 쉽고 표현적으로 다루도록 설계된 고수준의 자료구조와 함수를 제공한다.

- 2010년 처음 개발되어 파이썬으로 생산적이고 강력한 데이터 분석 환경을 구성하는 데 도움을 주고 있다.

- pandas의 주된 자료구조는 표형태의 로우와 컬럼 이름을 가지는 DataFrame(데이터프레임)과 1차원 배열 객체인 Series(시리즈)다.

- pands는 'NumPy의 고성능, 배열 연산 아이디어'에 스프레드시트와 관계형 데이터베이스(SQL 같은)의 유연한 데이터 처리 기능을 결합한 것이다.

- 세련된 색인 기능을 제공하여 데이터 변형, 자르기, 취합 그리고 데이터의 부분집합을 선택할 수 있도록 해준다.

- 데이터를 처리하고 준비하고 다듬는 과정은 데이터 분석에서 가장 중요한 부분이므로 pandas는 이 책에서 우선적으로 집중하는 라이브러리다.

- pandas의 많은 기능은 R 핵심 구현의 일부 또는 애드온 패키지에서 따왔다.

- pands라는 이름은 다차원으로 구조화된 데이터를 뜻하는 경제학 용어인 패널 데이터와 파이썬 데이터 분석에서 따온 이름이다.

3. matplotlib

- matplotlib(맷플롯립)은 그래프나 2차원 데이터 시각화를 생성하는 유명한 파이썬 라이브러리다.

- 존 D. 헌터가 만들었고 지금은 많은 개발 팀이 유지하고 있다.

- 출판물에 필요한 그래프를 만드는 데 맞춰 설계되었다.

- 기본 시각화 도구로 가장 안전한 선택이라고 생각한다.

4. IPython과 Jupyter

- IPython(아이파이썬, 인터랙티브 파이썬(Interactive Python))은 더 나은 대화형(인터랙티브) 파이썬 인터프리터를 만들 목적으로 2001년 페르난도 페레즈가 취미 프로젝트로 시작했다.

- IPython 자체는 계산이나 데이터 분석 도구로서의 기능을 제공하지는 않지만 대화형 컴퓨팅과 소프트웨어 개발 양쪽 모두에서 생산성을 극대화할 수 있도록 설계되었다.

- IPython은 많은 프로그래밍 언어들의 특징인 전통적인 편집-컴파일-실행 방식 대신에 실행-탐색 방식을 장려하며 파일시스템과 운영체제 셸에도 쉽게 접근할 수 있다.

- 2014년 페르난도와 IPython 팀은 언어에 상관없이 대화형 컴퓨팅 도구를 설계할 수 있는 주피터(Jupyter) 프로젝트를 발표했다.

- IPython 시스템은 이제 주피터에서 파이썬을 사용할 수 있게 해주는 커널(프로그래밍 언어 모드)로 역할을 변경했다.

- 주피터 노트북에서도 IPython 시스템을 여전히 사용할 수 있는데, '노트북'이라고 하는 웹 기반의 대화형 코드 작성 환경은 다양한 프로그래밍 언어를 지원한다.

- 주피터 노트북 시스템은 노트북 내용을 마크다운이나 HTML로 저장할 수 있게 한다.

- 이를 통해 코드와 텍스트를 포함하는 문서를 생성할 수 있다.

- 다른 프로그래밍 언어도 주피터 환경을 위한 커널이 구현되어 있다면 파이썬 대신 주피터 환경에서 사용할 수 있다.

- 개인적으로 파이썬 코드를 실행하거나 디버깅, 테스트 작업을 할 때는 거의 항상 IPython을 사용한다.

5. SciPy

- SciPy(사이파이)는 과학 계산 컴퓨팅 영역의 여러 기본 문제를 다루는 패키지 모음이다.

- 다음은 SciPy에 포함된 패키지 중 일부다.

```

scipy.integrate - 수치적분 루틴과 미분방적식 풀이법

scipy.linalg - numpy.linalg에서 제공하는 것보다 더 확장된 선형대수 루틴과 매트릭스 분해

scipy.optimize - 함수 최적화기와 방정식의 근을 구하는 알고리즘

scipy.signal - 시그널 프로세싱 도구

scipy.sparse - 희소 행렬과 희소 선형 시스템 풀이법

scipy.special - 감마 함수처럼 흔히 사용되는 수학 함수를 구현한 포트란 라이브러리인 SPECFUN 래퍼

scipy.stats - 표준 연속/이산 확률 분포(밀도 함수, 샘플러, 연속 분포 함수)와 다양한 통계 테스트 그리고 좀 더 기술적인 통계도구

```

- NumPy와 SciPy를 함께 사용하면 전통적인 과학 계산 애플리케이션에서 제공하는 거의 모든 기능을 대체할 수 있다.

6. scikit-learn

- scikit-leran(사이킷런)은 처음 개발되기 시작한 2010년부터 파이썬 개발자를 위한 범용 머신러닝 도구로 자리 잡기 시작했다.

- 다음과 같은 모델의 하위모듈을 포함한다.

```

분류: SVM, 최근접 이웃, 랜덤 포레스트, 로지스틱 회귀 등

회귀: 라소, 리지 회귀 등

클러스터링: K-평균, 스펙트럴 클러스터링 등

차원 축소: PCA, 특징 선택, 행렬 인수분해 등

모델 선택: 격자탐색, 교차검증, 행렬

전처리: 특징 추출, 정규화

```

7. statsmodels

- statsmodels은 다양한 R 언어용 회귀분석 모델을 구현한 스탠퍼드 대학의 통계학 교수인 조나단 테일러의 작업을 기반으로 만들어진 통계분석 패키지다.

- 스키퍼 시볼드와 죠세프 퍼크톨드가 2010년에 새로운 statsmodels 프로젝트를 시작한 이후 수많은 사용자와 오픈소스 기여자에게 빼놓을 수 없는 프로젝트로 성장했다.

- 나다니엘 스미스는 R 언어의 포뮬러 시스템에서 착안하여 statsmodels용 포뮬러 또는 모델 명세 프레임워크를 제공하는 Patsy(팻시) 프로젝트를 개발했다.

- scikit-learn과 비교하여 statsmodels는 전통적인 통계(주로 빈도주의적 접근)와 계량경제학 알고리즘을 포함하고 있다.

- 다음과 같은 하위모듈을 포함한다.

```

회귀 모델: 선형회귀, 일반화 선형 모델, 로버스트 선형 모델, 선형 혼합효과 모델 등

분산분석(ANOVA: analysis of variance)

시계열분석: AR, ARMA, ARIMA, VAR 및 기타 모델

비모수 기법: 커널밀도추정, 커널회귀

통계 모델 결과의 시각화

```

- statsmodels는 통계추론에 좀 더 초점을 맞추고 있다.

- 인자를 위한 불확실성 예측치와 p 값을 제공한다.

- 반면 scikit-learn은 좀 더 예측에 초점을 맞추고 있다.

# IPython

1. 탭 자동완성 

- an<탭키>

2. 자기관찰 ?

- add_numbers?, print?

- ??를 사용하면 가능한 경우 함수의 소스 코드도 보여준다. add_number??

- 와일드카드 기호와 함께 사용한 문자와 일치하는 모든 이름을 보여준다. np.*load*?

3. %run 명령어

- %run 명령어를 사용하면 IPython 세션 안에서 파이썬 프로그램 파일을 불러와서 실행할 수 있다.

4. 매직 명령어

- $quickref, $magic 등 사용 가능한 모든 특수 명령어를 살펴보는 것도 좋다.

# 시맨틱

- 파이썬은 가독성과 명료성 그리고 명백함을 강조한다.

- 한 줄에 여러 문장을 쓰는 것은 가독성을 해친다는 이유로 파이썬에서는 지양하는 습관이다.

- 파이썬 언어의 중요한 특징 중 하나는 객체 모델의 일관성이다.

- 파이썬에서 모든 객체는 특정한 자료형(또는 클래스)을 가지며 어떤 명백한 상황에서만 묵시적인 변환을 수행하는 자료형을 구분하는 강한 타입의 언어라고 한다.

- isinstance 함수를 이용해 어떤 객체가 무슨 자료형인지 검사할 수 있다.

- is와 is not은 변수가 None인지 검사하기 위해 흔히 사용한다.

- 뮤터블, 이뮤터블 객체

```

파이썬에서 리스트, 사전, NumPy 배열 또는 사용자 정의 클래스 같은 대부분의 객체는 변경 가능하다(뮤터블)

문자열이나 튜플은 변경 불가능하다(이뮤터블)

```

# 스칼라형

- 파이썬은 숫자 데잍어ㅘ 문자열, 불리언값(True or False) 그리고 날짜와 시간을 다룰 수있는 몇몇 내장 자료형을 제공한다.

- 이런 '단일 값'을 담는 자료형을 스칼라 타입이라고 한다.

```

None - 파이썬의 'Null' 값 (하나의 유일한 None 인스턴스만 존재한다.)

str - 문자열 자료형. 유니코드(UTF-8 인코딩) 문자열

bytes - Raw ASCII 바이트(또는 바이트로 인코딩된 유니코드)

float - 배정밀도(64비트) 부동소수점수. double 형은 따로 존재하지 않는다

bool - True or False

int - 부호가 있는(음수 표현이 가능한) 정수. 값의 범위는 플랫폼에 의존적

```

# 자료구조와 순차 자료형

# 튜플

1. 튜플은 1차원의 고정된 크기를 가지는 변경 불가능한 순차 자료형이다.

2. 튜플을 생성하는 가장 쉬운 방법은 쉼표로 구분된 값을 대입하는 것이다.

- tup = 1, 2, 3 => (1, 2, 3)

3. 괄호를 사용해서 값을 묶어줌으로써 중첩된 튜플을 정의할 수 있다. tup = (4, 5, 6), (7, 8) => ((4, 5, 6), (7, 8))

4. + 연산자를 이용해서 튜플을 이어붙일 수 있다. (4, None, 'foo') + (6, 0) + ('bar', ) => (4, None, 'foo', 6, 0, 'bar')

# 튜플에서 값 분리하기

1. 튜플과 같은 표현의 변수에 튜플을 대입하면 파이썬은 등호(=) 오른쪽에 있는 변수에서 값을 분리한다.

```

tup = 4, 5, 6

a, b, c = tup

a = 4, b = 5, c = 6

파이썬에서는 다음과 같이 하여 두 변수의 값을 쉽게 바꿀 수 있다.

b, a = a, b

튜플이나 리스트를 순회할 때도 흔히 이 기능을 활용한다

seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]

for a, b, c in seq:
    print('a={0}, b={1}, c={2}'.format(a, b, c))


a=1, b=2, c=3
a=4, b=5, c=6
a=7, b=8, c=9



```

# 리스트

1. 정렬

```

sort 함수를 이용해서 새로운 리스트를 생성하지 않고 있는 그대로 리스트를 정렬할 수 있다.

sort는 편의를 위해 몇 가지 옵션을 제공한다.

b = ['saw', 'small', 'he', 'foxes', 'six']

b.sort(key=len)

['he', 'saw', 'six', 'small', 'foxes']

```

2. 슬라이싱

```

HELLO!

string[2:4]

LL

string[-5:-2]

ELL

두 번째 콜론 다음에 간격(step)을 지정할 수 있는데, 하나 걸러 다음 원소를 선택하려면 다음과 같이 표현된다.

seq = [7, 2, 3, 6, 3, 5, 6, 0, 1]

seq[::2]

[7, 3, 3, 6, 1]

간격 값으로 -1을 사용하면 리스트나 튜플을 역순으로 반환한다.

seq[::-1]

[1, 0, 6, 5, 3, 6, 3, 2, 7]

```

# 내장 순차 자료형 함수

1. enumerate

- 순차 자료형에서 현재 아이템의 색인을 함께 처리하고자 할 때 흔히 사용한다.

```

i = 0

for value in collection:
    # value를 사용하는 코드
    i += 1

for i, value in enumerate(collection):
    # value를 사용하는 코드 작성

색인을 통해 데이터에 접근할 때 enumerate를 사용하는 유용한 패턴은 순차 자료형에서의 값과 그 위치를 dict에 넘겨주는 것이다.

```

2. zip

```

zip 함수는 여러 개의 리스트나 튜플 또는 다른 순차 자료형을 서로 짝지어서 튜플의 리스트를 생성한다.

seq1 = ['foo', 'bar', 'baz']

seq2 = ['one', 'two', 'three']

zipped = zip(seq1, seq2)

list(zipped)

[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]

zip 함수의 아주 흔한 사용 예는 여러 개의 순차 자료형을 동시에 순회하는 경우인데 enumerate와 함께 사용되기도 한다.

for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))

0: foo, one
1: bar, two
2: baz, three

```

# 사전

```

dict(사전)는 파이썬 내장 자료구조 중에서 가장 중요하다.

일반적으로 해시맵 또는 연관 배열이라고도 널리 알려져 있다.

사전은 유연한 크기를 가지는 키-값 쌍으로, 키와 값은 모두 파이썬 객체다.

사전을 생성하는 방법은 중괄호 {}를 사용하여 콜론으로 구분된 키와 값을 둘러싸는 것이다.

empty_dict = {}

d1 = {'a' : 'some value', 'b' : [1, 2, 3, 4]}

d1[7] = 'an integer'

d1 = {'a' : 'some value', 'b' : [1, 2, 3, 4], 7 : 'an integer'}

del 예약어나 pop 메서드(값을 반환함과 동시에 해당 키를 삭제한다)를 사용해서 사전의 값을 삭제할 수 있다.

keys와 values 메서드는 각각 키와 값이 담긴 이터레이터를 반환한다.

키-값 쌍은 일정한 기준으로 정렬되어 있진 않지만 keys 메서드와 values 메서드에서 반환하는 리스트는 같은 순서를 가진다.

update 메서드를 사용해서 하나의 사전을 다른 사전과 합칠 수 있다.

update 메서드는 사전 값을 그 자리에서 바꾸므로 이미 존재하는 키에 대해 update를 호출하면 이전 값을 사라진다.

mapping = {}

for key, value in zip(key_list, value_list):
    mapping[key] = value

mapping = dict(zip(range(5), reversed(range(5))))

get 메서드는 기본적으로 해당 키가 존재하지 않을 경우 None을 반환하며, pop 메서드는 예외를 발생시킨다.

보통 사전에 값을 대입할 때는 리스트 같은 다른 컬렉션에 있는 값을 이용하는데, 예를 들어 여러 단어를 시작 글자에 따라 사전에 리스트로 저장하고 싶다면 다음처럼 할 수 있다.

words = ['apple', 'bat', 'bar', 'atom', 'book']

by_letter = {}

for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].attend(word)
    
by_letter
{'a' : ['apple', 'atom'], 'b' : ['bat', 'bar', 'book']}

사전의 setdefault 메서드를 바로 이 목적으로 사용한다. 위 코드에서 if-else 블록은 다음처럼 작성할 수 있다.

for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)

내장 collections 모듈은 defaultdict라는 유용한 클래스를 담고 있는데, 이 클래스를 사용하면 위 과정을 좀 더 쉽게 할 수 있다.

자료형, 혹은 사전의 각 슬롯에 담길 기본값을 생성하는 함수를 넘겨서 사전을 생성하는 것이다.

from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)

유효한 사전 키

사전의 값으로 어떤 파이썬 객체라도 가능하지만 키는 스칼라형(정수, 실수, 문자열)이나 튜플(튜플에 저장된 값 역시 값이 바뀌지 않는 객체여야 한다)처럼 값이 바뀌지 않는 객체만 가능하다.

기술적으로는 해시 가능해야 한다는 뜻이다.

어떤 객체가 해시 가능한지(즉, 사전의 키로 사용할 수 있는지)는 hash 함수를 사용해서 검사할 수 있다.

hash('string')
50~..

hash((1, 2, (2, 3)))
10~..

hash((1, 2, [2, 3]))
Error -> 리스트는 변경이 가능하기 때문에, 리스트를 키로 하기 위해서는 tuple로 변환해야 한다.

```

# 집합

```

set(집합)은 유일한 원소만 담는 정렬되지 않은 자료형이다.

사전과 유사하지만 값은 없고 키만 가지고 있다고 생각하면 된다.

집합은 두 가지 방법으로 생성할 수 있는데 set 함수를 이용하거나 중괄호를 이용해서 생성할 수 있다.

집합은 합집합, 교집합, 차집합, 대칭차집합 같은 산술 집합 연산을 제공한다.

어떤 집합이 다른 집합의 부분집합인지 확대집합인지 검사할 수도 있다.

a_set = {1, 2, 3, 4, 5}

{1, 2, 3}.issubset(a_set)
True

a_set.issuperset({1, 2, 3})
True

{1, 2, 3} == {3, 2, 1}
True

```

# 리스트, 집합, 사전 표기법

```

리스트 표기법은 파이썬 언어에서 가장 사랑받는 기능 중 하나다.

이를 이용하면 간결한 표현으로 새로운 리스트를 만들 수 있다.

[expr for val in collection if condition]

이를 반복문으로 구현하면 다음과 같다.

result = []

for val in collection:
    if condition:
        result.append(expr)

필터 조건은 생략 가능하다.

예를 들어 문자열 리스트가 있다면 아래처럼 문자열의 길이가 2 이하인 문자열은 제외하고 나머지를 대문자로 바꾸는 게 가능하다.

strings = ['a', 'as', 'bat', 'car', 'dove', 'python']

[x.upper() for x in strings if len(x) > 2]
['BAT', 'CAR', 'DOVE', 'PYTHON']

집합과 사전에 대해서도 리스트 표기법과 같은 방식으로 적용할 수 있다.

사전 표기법은 다음과 같다.

dict_comp = {key-expr : value-expr for value in collection if condition}

집합 표기법은 대괄호 대신 중괄호를 쓴다는 점만 빼면 리스트 표기법과 동일하다.

set_comp = {expr for value in collection if condition}

리스트 내의 문자열들의 길이를 담고 있는 집합을 생성하려면 집합 표기법을 이용하여 다음과 같이 처리할 수 있다.

unique_lengths = {len(x) for x in strings}

map 함수를 이용해서 함수적으로 표현할 수도 있다.

set(map(len, strings))

사전 표기법의 예제로, 리스트에서 문자열의 위치를 담고 있는 사전을 생성하보자

loc_mapping = {val : index for index, val in enumerate(strings)}

loc_mapping
{'a': 0, 'as': 1, 'bat' : 2, 'car' : 3, 'dove' : 4, 'python' : 5}

중첩된 리스트 표기법

다음과 같이 영어 이름과 스페인어 이름을 담고 있는 리스트의 리스트가 있다고 하자.

all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'], ['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]

몇몇 파일에서 이들 이름을 읽어 와서 영어와 스페인어 이름을 따로 저장했으며 각 이름에서 알파벳 e가 2개 이상 포함된 이름의 목록을 구한다고 가정하자.

리스트는 for 문을 사용해서 다음처럼 구할 수 있다.

names_of_interest = []

for names in all_data:
    enough_es = [name for name in names if name.count('e') >= 2]
    names_of_interest.extends(enough_es)

위 코드 전체를 중첩된 리스트 표기법을 이용해서 다음처럼 한 번에 구현할 수 있다.

result = [name for names in all_data for name in names if name.count('e') >= 2]

```

# 네임스페이스, 스코프, 지역 함수

```

함수는 전역과 지역, 두 가지 스코프(영역)에서 변수를 참조한다.

변수의 스코프를 설명하는 다른 용어로 네임스페이스가 있다.

함수 내에서 선언된 변수는 기본적으로 모두 지역 네임스페이스에 속한다.

지역 네임스페이스는 함수가 호출될 때 생성되며 함수의 인자를 통해 즉시 생성된다.

함수의 실행이 끝나면 지역 네임스페이스는 사라진다

def func():
    a = []
    for i in range(5):
        a.append(i)

```

# 여러 값 반환하기

```

하나의 함수에서 여러 개의 값을 반환할 수 있다.

def f():
    a = 5
    b = 6
    c = 7
    return a, b, c

a, b, c = f()

데이터 분석과 과학 계산 애플리케이션에서는 많은 함수가 여러 개의 값을 반환하는 일이 잦다는 사실을 깨닫게 될 것이다.

앞서 살펴본 튜플을 생각해보면 이 함수는 하나의 객체, 말하자면 튜플을 반환한다고 생각할 수 있다.

return_value = f()

여기서 return_value는 짐작한 대로 반환된 세 개의 값을 가지고 있는 튜플이 된다.

다른 매력적인 대안으로는 여러 값을 반환하는 대신 사전 형태로 반환하는 것이다.

def f():
    a = 5
    b = 6
    c = 7
    return {'a' : a, 'b' : b, 'c' : c}

```

# 익명 함수

```

파이썬은 익명(anonymous)함수 혹은 람다(lambda)함수라고 하는 값을 반환하는 단순한 한 문장으로 이루어진 함수를 지원한다.

lambda 예약어로 정의하며, 이는 '익명 함수를 선언한다'라는 의미다.

def short_function(x):
    return x * 2

equiv_anon = lambda x: x * 2

람다 함수는 데이터 분석에서 특히 편리한데, 이는 앞으로 알게 되겠지만 데이터를 변형하는 함수에서 인자로 함수를 받아야 하는 경우가 매우 많기 때문이다.

즉, 람다 함수를 사용하면 실제 함수를 선언하거나 람다 함수를 지역 변수에 대입하는 것보다 코드를 적게 쓰고 더 간결해지기 때문이다.

def apply_to_list(some_list, f):
    return [f(x) for x in some_list]

ints = [4, 0, 1, 5, 6]
apply_to_list(ints, lambda x: x * 2)

물론 [x * 2 for x in ints]라고 해도 되지만 이렇게 하면 apply_to_list 함수에 사용자 연산을 간결하게 전달할 수 있다.

다른 예제로, 다음 문자열 리스트를 각 문자열에서 다양한 문자가 포함된 순서로 정렬한다고 가정하자

strings = ['foo', 'card', 'bar', 'aaaa', 'abab']

strings.sort(key=lambda x: len(set(list(x))))

strings
['aaaa', 'foo', 'abab', 'bar', 'card']

```

# 제너레이터

```

파이썬은 리스트 내의 객체나 파일의 각 로우 같은 순차적인 자료를 순회하는 일반적인 방법을 제공한다.

이터레이터 프로토콜을 이용해 순회 가능한 객체를 만들 수 있다.

예를 들어 사전을 순회하면 사전의 키가 반환된다.

some_dict = {'a' : 1, 'b': 2, 'c': 3}

dict_iterator = iter(some_dict)

list(dict_iterator)

['a', 'b', 'c']

제너레이터를 생성하는 더 간단한 방법은 제너레이터 표현식을 사용하는 것이다.

다음은 리스트, 사전, 집합 표현식과 유사한 방식으로 제너레이터를 생성한다.

리스트 표현식에서 대괄호를 사용하듯이 괄호를 사용해서 제너레이터를 생성할 수 있다.

gen = (x ** 2 for x in range(100))

dict((i, i**2) for i in range(5))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

```


# NumPy 기본: 배열과 벡터 ㅕㅇㄴ산

1. NumPy에서 제공하는 것들

```

효율적인 다차원 배열인 ndarray는 빠른 배열 계산과 유연한 브로드캐스팅 기능을 제공한다.

반복문을 작성할 필요 없이 전체 데이터 배열을 빠르게 계산할 수 있는 표준 수학 함수

배열 데이터를 디스크에 쓰거나 읽을 수 있는 도구와 메모리에 적재된 파일을 다루는 도구

선형대수, 난수 생성기, 푸리에 변환 기능

C, C++, 포트란으로 작성한 코드를 연결할 수 있는 C API

```

2. 대부분의 데이터 분석 애플리케이션에서 필자가 중요하게 생각하는 기능

```

벡터 배열 상에서 데이터 가공(데이터 먼징 또는 데이터 랭글링), 정제, 부분집합, 필터링, 변형 그리고 다른 여러 종류의 연산을 빠르게 수행

정렬, 유일 원소 찾기, 집합 연산 같은 일반적인 배열 처리 알고리즘

통계의 효과적인 표현과 데이터를 수집 요약하기

다양한 종류의 데이터를 병합하고 엮기 위한 데이터 정렬과 데이터 간의 관계 조작

내부에서 if - elif - else를 사용하는 반복문 대신 사용할 수 있는 조건절 표현을 허용하는 배열 처리

데이터 묶음 전체에 적용할 수 있는 수집, 변형, 함수 적용 같은 데이터 처리

```

3. NumPy는 일반적인 산술 데이터 처리를 위한 기반 라이브러리를 제공하기 때문에 많은 독자가 통계나 분석, 특히 표 형식의 데이터를 처리하기 위해 pandas를 사용하기 원할 것이다.

4. NumPy가 파이썬 산술 계산 영역에서 중요한 위치를 차지하는 이유 중 하나는 대용량 데이터 배열을 효율적으로 다룰 수 있도록 설계되었다는 점이다.

```

NumPy는 내부적으로 데이터를 다른 내장 파이썬 객체와 구분된 연속된 메모리 블록에 저장한다.

NumPy의 각종 알고리즘은 모두 C로 작성되어 타입 검사나 다른 오버헤드 없이 메모리를 직접 조작할 수 있다.

NumPy 배열은 또한 내장 파이썬의 연속된 자료형들보다 훨씬 더 적은 메모리를 사용한다.

NumPy 연산은 파이썬 반복문을 사용하지 않고 전체 배열에 대한 복잡한 계산을 수행할 수 있다.

```

# ndarray 생성하기

```

배열을 생성하는 가장 쉬운 방법은 array 함수를 이용하는 것이다.

순차적인 객체(다른 배열도 포함하여)를 넘겨받고, 넘겨받은 데이터가 들어 있는 새로운 NumPy 배열을 생성한다.

예를 들어 파이썬의 리스트는 변환하기 좋은 예다.

data1 = [6, 7.5, 8, 0, 1]

arr1 = np.array(data1)

arr1

array([6 ,7.5 , 8. , 0. , 1.])

배열 생성 함수 표 4.1 (139P)

```

# ndarray의 dtype

1. dtype은 ndarray가 메모리에 있는 특정 데이터를 해석하기 위해 필요한 정보(또는 메타데이터)를 담고 있는 특수한 객체다.

```

arr1 = np.array([1, 2, 3], dtype=np.float64)

arr1.dtype
dtype('float64')

ndarray의 astype 메서드를 사용해서 배열의 dtype을 다른 형으로 명시적으로 변환(또는 캐스팅) 가능하다.

arr = np.array([1, 2, 3, 4, 5])

arr.dtype
dtype('int64')

float_arr = arr.astype(np.float64)

float_arr.dtype
dtye('float64')

```

# NumPy 배열의 산술 연산

1. 배열의 중요한 특징은 for 문을 작성하지 않고 데이터를 일괄 처리할 수 있다는 것이다.

2. 이를 벡터화라고 하는데, 같은 크기의 배열 간의 산술 연산은 배열의 각 원소 단위로 적용된다.

# 색인과 슬라이싱 기초

1. NumPy 배열 색인에 대해서는 다룰 주제가 많다.

2. 데이터의 부분집합이나 개별 요소를 선택하기 위한 수많은 방법이 존재한다.

3. 1차원 배열은 단순한데, 표면적으로는 파이썬의 리스트와 유사하게 동작한다.

```

arr = np.arange(10)

arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

arr[5]
5

arr[5:8]
array([5, 6, 7])

arr[5:8] = 12

arr
array([0, 1, 2, 3, 4, 12, 12, 12, 8, 9])

배열 조각에 스칼라 값을 대입하면 12가 선택 영연 전체로 전파(또는 브로드캐스팅)된다.

리스트와의 중요한 차이점은 배열 조각은 원본 배열의 뷰라는 점이다.

즉, 데이터는 복사되지 않고 뷰에 대한 변경은 그대로 원본 배열에 반영된다.

arr_slice = arr[5:8]

arr_slice
array([12, 12, 12])

arr_slice[1] = 12345

arr
array([0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])

arr_slice[:] = 64

arr
array([0, 1, 2, 3, 4, 64, 64, 64, 8, 9])

NumPy를 처음 접한다면, 특히 데이터 복사가 자주 일어나는 다른 배열 프로그래밍 언어를 사용해본 적이 있다면 데이터가 복사되지 않는다는 점은 놀랄 만한 사실이다.

NumPy는 대용량의 데이터 처리를 염두에 두고 설계되었기 때문에 만약 NumPy가 데이터 복사를 남발한다면 성능과 메모리 문제에 마주치게 될 것이다.

다차원 배열을 다룰 때는 좀 더 많은 옵션이 있다.

2차원 배열에서 각 색인에 해당하는 요소는 스칼라값이 아니라 1차원 배열이다.

arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

arr2d[2]
array([7, 8, 9]

개별 요소는 재귀적으로 접근하거나 콤마로 구분된 색인 리스트를 넘기면된다.

arr2d[0][2]
3

arr2d[0, 2]
3




```

# 배열 전치와 축 바꾸기

1. 배열 전치는 데이터를 복사하지 않고 데이터의 모양이 바뀐 뷰를 반환하는 특별한 기능이다.

2. ndarray는 transpose 메서드와 T라는 이름의 특수한 속성을 가지고 있다.

```

arr = np.arange(15).reshape((3, 5))

arr.T = 5, 3 쉐입으로 보여줌

```

# 유니버설 함수: 배열의 각 원소를 빠르게 처리하는 함수

1. ufunc라고 불리기도 하는 유니버설 함수는 ndarray 안에 있는 데이터 원소별로 연산을 수행하는 함수다.

2. 유니버설 함수는 하나 이상의 스칼라값을 받아서 하나 이상의 스칼라 결괏값을 반환하는 간단한 함수를 고속으로 수행할 수 있는 벡터화된 래퍼 함수라고 생각하면 된다.

3. 많은 ufunc는 sqrt나 exp같은 간단한 변형을 전체 원소에 적용할 수 있다.

```

arr = np.arange(10)

arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

단항 유니버설 함수

np.sqrt(arr)
array([0, 1, 1.4142, 1.7321, 2. , 2.2361, 2.4495, 2.6458, 2.8284, 3. ])


표 4-3 단항 유니버설 함수, 표 4-4 이항 유니버설 함수 (160P)


```

# 배열을 이용한 배열지향 프로그래밍 

1. NumPy 배열을 사용하면 반복문을 작성하지 않고 간결한 배열 연상을 사용해 많은 종류의 데이터 처리 작업을 할 수 있다.

2. 배열 연산을 사용해서 반복문을 명시적으로 제거하는 기법을 흔히 벡터화라고 부르는데, 일반적으로 벡터화된 배열에 대한 산술 연산은 순수 파이썬 연산에 비해 2~3배에서 많게는 수십, 수백 배까지 빠르다.

3. 간단한 예로 값이 놓여 있는 그리드에서 sqrt(x^2 + y^2)을 계산한다고 하자.

4. np.meshgrid 함수는 두 개의 1차원 배열을 받아서 가능한 모든 (x, y) 짝을 만들 수 있는 2차원 배열 두 개를 반환한다.

```

points = np.arange(-5, 0, 0.01) # -5부터 4.99까지 0.01씩 증가하는 값들의 배열

xs, ys = np.meshgrid(points, points)

ys = ...

z = np.sqrt(xs ** 2 + ys ** 2)

여기서 matplotlib을 이용해서 이 2차원 배열을 시각화할 수 있다.

import matploilib.pyplot as pit

pit.imshow(z, cmap=pit.cm.gray); pit.colorbar()

pit.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")

```

# 배열 연산으로 조건절 표현하기

```

numpy.where 함수는 x if 조건 else y 같은 삼항식의 벡터화된 버전이다.

다음과 같은 불리언 배열 하나와 같이 들어있는 두 개의 배열이 있다고 하자

xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])

yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])

cond = np.array([True, False, True, True, False])

cond의 값이 True일 때는 xarr의 값을 취하고 아니면 yarr의 값을 취하고 싶을 때 리스트 표기법을 이용해서 다음처럼 작성할 수 있다.

result = [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]

이 부분을 

result = np.where(cond, xarr, yarr)

result
array([1.1, 2.2, 1.3, 1.4, 2.5])

```

# 수학 메서드와 통계 메서드

```

배열 전체 혹은 배열에서 한 축을 따르는 자료에 대한 통계를 계산하는 수학 함수는 배열 메서드로 사용할 수 있다.

전체의 합(sum)이나 평균(mean), 표준편차(std)는 NumPy의 최상위 함수를 이용하거나 배열의 인스턴스 메서드를 사용해서 구할 수 있다.

임의의 정규 분포 데이터를 생성하고 집계해보자.

arr = np.random.randn(5, 4)

arr.mean()

np.mean(arr)

arr.sum()

```

# 불리언 배열을 위한 메서드

```

이전 메서드의 불리언 값을 True 또는 False 으로 강제할 수 있다.

따라서 sum 메서드를 실행하면 불리언 배열에서 True인 원소의 개수를 셀 수 있다.

arr = np.random.randn(100)

(arr > 0).sum() # 양수인 원소의 개수

any와 all 메서드는 불리언 배열에 특히 유용하다.

any 메서드는 하나 이상의 값이 True인지 검사하고, all 메서드는 모든 원소가 True인지 검사한다.

bools = np.array([False, False, True, False])

bools.any()
True

bools.all()
False

```

# 정렬

```

파이썬의 내장 리스트형처럼 NumPy 배열 역시 sort 메서드를 이용해서 정렬할 수 있다.

arr = np.random.randn(6)

arr.sort()

```

# 집합 관련 함수

```

NumPy는 1차원 ndarray를 위한 몇 가지 기본적인 집합 연산을 제공한다.

아마도 가장 자주 사용하는 함수는 배열 내에서 중복된 원소를 제거하고 남은 원소를 정렬된 형태로 반환하는 np.unique일 것이다.

names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])

np.unique(names)
array(['Bob', 'Joe', 'Will'])

np.unique를 순수 파이썬만으로 구현하면?

sorted(set(names))

```

# 배열 데이터의 파일 입출력

```

NumPy는 디스크에서 텍스트나 바이너리 형식의 데이터를 불러오거나 저장할 수 있다.

여기서는 NumPy의 내장 이진 형식만 살펴본다.

많은 사람이 텍스트나 표 형식의 데이터는 pandas나 다른 도구를 사용해서 처리하는 것을 선호하므로 6장에서 더 살펴보도록 하자.

np.save와 np.load는 배열 데이터를 효과적으로 디스크에 저장하고 불러오기 위한 함수다.

배열은 기본적으로 압축되지 않은 원시(가공되지 않은) 바이너리 형식의 .npy파일로 저장된다.

arr = np.arange(10)

np.save('some_array', arr)

저장되는 파일 경로가 .npy로 끝나지 않으면 자동적으로 확장자가 추가된다.

np.load('some_array.npy)

```

# 선형대수

```

행렬의 곱셈, 분할, 행렬식, 그리고 정사각 행렬 수학 같은 선형대수는 배열을 다루는 라이브러리에서 중요한 부분이다.

매트랩 같은 언어와 다르게 두 개의 2차원 배열을 * 연산자로 곱하면 행렬 곱셈이 아니라 대응하는 각각의 원소의 곱을 계산한다.

행렬 곱센은 배열 메서드이자 numpy 네임스페이스 안에 있는 dot 함수를 이용해서 계산한다.

x = np.array([[1., 2., 3.], [4., 5., 6.]])

y = np.array([[6., 23.], [-1, 7], [8, 9]])

x.dot(y)

```

# pandas 시작하기

```

pandas는 앞으로 가장 자주 살펴볼 라이브러리다. 고수준의 자료구조와 파이썬에서 빠르고 쉽게 사용할 수 있는 데이터 분석 도구를 포함하고 있다.

pandas는 다른 산술 계산 도구인 NumPy와 SciPy, 분석 라이브러리인 statsmodels와 scikit-learn, 시각화 도구인 matplotlib과 함께 사용하는 경우가 흔하다.

pandas는 for 문을 사용하지 않고 데이터를 처리한다거나 배열 기반의 함수를 제공하는 등 NumPy의 배열 기반 계산 스타일을 많이 차용했다.

pandas가 NumPy의 스타일을 많이 차용했지만 갖아 큰 차이점은 pandas는 표 형식의 데이터나 다양한 형태의 데이터를 다루는 데 초점을 맞춰 설계했다는 것이다.

NumPy는 단일 산술 배열 데이터를 다루는 데 특화되어 있다.

import pandas as pd

from pandas import Series, DataFrame

```

# pandas 자료구조 소개

```

pandas에 대해 알아보려면 Series와 DataFrame, 이 두 가지 자료구조에 익숙해질 필요가 있다. 이 두 가지 자료구조로 모든 문제를 해결할 순 없지만 대부분의 애플리케이션에서 사용하기 쉬우며 탄탄한 기반을 제공한다.

```

# Series

```

Series는 일련의 객체를 담을 수 있는 1차원 배열 같은 자료구조다 (어떤 NumPy 자료형이라도 담을 수 있다.) 

그리고 색인이라고 하는 배열의 데이터와 연관된 이름을 가지고 있다.

가장 간단한 Series 객체는 배열 데이터로부터 생성할 수 있다.

obj = pd.Series([4, 7, -5, 3])

obj

0 4
1 7
2 -5
3 3

Series를 이해하는 다른 방법은 고정 길이의 정렬된 사전형이라고 생각하는 것이다.

Series는 색인값에 데이터값을 매핑하고 있으므로 파이썬의 사전형과 비슷하다.

Series 객체는 파이썬의 사전형을 인자로 받아야 하는 많은 함수에서 사전형을 대체하여 사용할 수 있다.

Series의 유용한 기능은 산술 연산에서 색인과 라벨로 자동 정렬하는 것이다. 데이터베이스를 사용해본 경험이 있다면 join 연산과 비슷하다고 여겨질 것이다.

Series 객체와 Series의 색인은 모두 name 속성이 있는데 이 속성은 pandas의 핵심 기능과 밀접한 관련이 있다.

obj4.name = 'population'

obj4.index.name = 'state'

```

# DataFrame

```

DataFrame은 표 같은 스프레드시트 형식의 자료구조이고 여러 개의 컬럼이 있는데 각 컬럼은 서로 다른 종류의 값(숫자, 문자열, 불리언 등)을 담을 수 있다.

DataFrame은 로우와 컬럼에 대한 색인을 가지고 있는데, 색인의 모양이 같은 Series 객체를 담고 있는 파이썬 사전으로 생각하면 편하다.

내부적으로 데이터는 리스트나 사전 또는 1차원 배열을 담고 있는 다른 컬렉션이 아니라 하나 이상의 2차원 배열에 저장된다.

DataFrame 객체는 다양한 방법으로 생성할 수 있지만 가장 흔하게 사용되는 방법은 같은 길이의 리스트에 담긴 사전을 이용하거나 NumPy 배열을 이용하는 것이다.

data = {'state' : ['Ohio', 'Nevada'], 'year' : ['2021', '2021'], 'pop' : [1.5, 1.7]}
frame = pd.DataFrame(data)

frame
 
  pop state year
0 1.5  Ohio 2021
1 1.7 Nevada 2021

원하는 순서대로 columns를 지정하면 원하는 순서를 가진 DataFrame 객체가 생성된다.

pd.dataFrame(data, columns=['year', 'state', 'pop'])

중첩된 사전을 이용해서 데이터를 생성할 수 있다. 다음과 같은 중첩된 사전이 있다고 하자

pop = {'Nevada' : {2001: 2.4, 2002: 2.9}, 'Ohio' : {2000: 1.5, 2002:3.6}}

이 중첩된 사전을 DataFrame에 넘기면 바깥에 있는 사전의 키는 컬럼이 되고 안에 있는 키는 로우가 된다.

frame3 = pd.DataFrame(pop)

frame3

        Nevada Ohio
2000    Nan     1.5
2001    2.4     1.7
2002    2.9     3.6

NumPy 배열과 유사한 문법으로 데이터를 전치 (컬럼과 로우를 뒤집음)할 수 있다.

frame3.T

중첩된 사전을 이용해서 DataFrame을 생성할 때 안쪽에 있는 사전값은 키값별로 조합되어 결과의 색인이 되지만 색인을 직접 지정하면 지정된 색인으로 DataFrame을 생성한다. ** <- 색인을 직접 지정해서 원하는 결과 값을 도출하는 부분이 추후 중요하게 작용할 것 같다.

pd.DataFrame(pop, index=[2001, 2002, 2003])
        Nevada  Ohio   
2001    2.4     1.7
2002    2.9     3.6
2003    NaN     NaN

데이터프레임의 색인(index)과 컬럼(columns)에 name 속성을 지정했다면 이 역시 함께 출력된다.

frame3.index.name = 'year'; frame3.columns.name = 'state'

frame3

state   Nevada  Ohio
year
2000    NaN     1.5
2001    2.4     1.7
2002    2.9     3.6

Series와 유사하게 values 속성은 DataFrame에 저장된 데이터를 2차원 배열로 반환한다.

frame3.values

```


# 재색인


```

pandas 객체의 중요한 기능 중 하나는 reindex인데, 새로운 색인에 맞도록 객체를 새로 생성한다.

아래 간단한 예제를 살펴보자.

obj = pd.Series([4.5, 7.2, -5.3, 3.6], index=['d', 'b', 'a', 'c'])

obj

d   4.5
b   7.2
a   -5.3
c   3.6

이 Series 객체에 대해 reindex를 호출하면 데이터를 새로운 색인에 맞게 재배열하고, 존재하지 않는 색인값이 있다면 NaN을 추가한다.

obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'])

obj2

a   -5.3
b   7.2
c   3.6
d   4.5
e   NaN

시계열 같은 순차적인 데이터를 재색인할 때 값을 보간하거나 채워 넣어야 할 경우가 있다.

method 옵션을 이용해서 이를 해결할 수 있으며, ffill 같은 메서드를 이용해서 누락된 값을 직전의 값으로 채워 넣을 수 있다.

obj3 = pd.Series(['blue', 'purple', 'yellow'], index=[0, 2, 4])

obj3

0   blue
2   purple
4   yellow

obj3.reindex(range(6), method='ffill')

0   blue
1   blue
2   purple
3   purple
4   yellow
5   yellow

DataFrame에 대한 reindex는 로우(색인), 컬럼 또는 둘 다 변경 가능하다. 그냥 순서만 전달하면 로우가 재색인된다.

```

# loc와 iloc로 선택하기

```

DataFrame의 로우에 대한 라벨로 색인하는 방법으로 특수한 색인 필드인 loc와 iloc를 소개한다.

이 방법을 이용하면 NumPy와 비슷한 방식에 추가적으로 축의 라벨을 사용하여 DataFrame의 로우와 컬럼을 선택할 수 있다.

축 이름을 선택할 때는 loc를, 정수 색인으로 선택할 때는 iloc를 이용한다.

축의 라벨로 하나의 로우와 여러 칼럼을 선택하기

data.loc['Colorado', ['two', 'three']]

two 5
three 6
Name : Colorado

data.lioc[2, [3, 0, 1]]

four 11
one 8
two 9
Name: Utah

이 두 함수는 슬라이스도 지원할 뿐더러 단일 라벨이나 라벨 리스트도 지원한다.

data.loc[:'Utah', 'two']

data.iloc[:, :3][data.three > 5]

```

# 산술 연산과 데이터 정렬

```

pandas에서 가장 중요한 기능 중 하나는 다른 색인을 가지고 있는 객체 간의 산술 연산이다.

객체를 더할 때 짝이 맞지 않는 색인이 있다면 결과에 두 색인이 통합된다.

데이터베이스를 사용해본 경험이 있다면 색인 라벨에 대한 외부 조인과 유사하게 동작한다고 생각할 수 있다.

예제를 보자.

s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=['a', 'b', 'c', 'd'])
s2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1], index = ['a', 'c', 'e', 'f', 'g'])

s1 + s2

a   5.2
c   1.1
d   NaN
e   0.0
f   NaN
g   NaN

서로 겹치는 색인이 없는 경우 데이터는 NaN 값이 된다. 산술 연산 시 누락된 값은 전파된다.

```

# 데이터 로딩과 저장, 파일 형식

```

이 책에서 다루는 대부분의 도구를 사용하는 첫 관문은 데이터에 접근하는 것이다.

다양한 형식의 데이터를 읽고 쓸 수 있는 많은 라이브러리가 있지만 이 책에서는 pandas에 초점을 맞춰 설명한다.

일반적으로 입출력은 몇 가지 작은 범주로 나뉘는데, 텍스트 파일을 이용하는 방법, 데이터베이스를 이용하는 방법, 웹 API를 이용해서 네트워크를 통해 불러오는 방법이 있다.

pandas에는 표 형식의 자료를 DataFrame 객체로 읽어오는 몇 가지 기능을 제공하고 있다.

아마 read_csv와 read_table을 주로 사용하게 될 테지만 표 6-1에 다른 함수도 정리해두었다.

```

# JSON 데이터

```

JSON (Javascript Object Notation)은 웹브라우저와 다른 애플리케이션이 HTTP 요청을 ㅗ데이터를 보낼 때 널리 사용하는 표준 파일 형식 중 하나다.

JSON은 CSV 같은 표 형식의 텍스트보다 좀 더 유연한 데이터 형식이다.

기본 자료형은 객체(사전), 배열(리스트), 문자열, 숫자, 불리언, 그리고 널이다. 객체의 키는 반드시 문자열이어야 한다.

JSON 데이터를 읽고 쓸 수 있는 파이썬 라이브러리가 몇 가지 있는데 여기서는 파이썬 표준 라이브러리인 json을 사용하겠다.

JSON 문자열을 파이썬 형태로 변환하기 위해서는 json.loads를 사용한다.

import json

result = json.loads(obj)

json.dumps는 파이썬 객체를 JSON 형태로 변환한다.

asjson = json.dumps(result)

pandas의 데이터를 JSON으로 저장하는 한 가지 방법은 Series나 DataFrame의 to_json함수를 이용하는 것이다.

data = pd.read_json('examples/example.json')

print(data.to_json())

```

# XML과 HTML: 웹 스크래핑

```

파이썬에는 lxml, Beautiful Soup(뷰티플 수프), 그리고 html5lib 같은 HTML과 XML 형식의 데이터를 읽고 쓸 수 있는 라이브러리가 무척 많다.

그중에서도 lxml은 가장 빠르게 동작하고 깨진 HTML과 XML 파일도 잘 처리해준다.

pandas에는 read_html이라는 내장 함수가 있다. 이는 lxml이나 Beautiful Soup 같은 라이브러리를 사용해서 자동으로 HTML 파일을 파싱하여 DataFrame으로 변환해준다.

```

# lxml.objectify를 이용해서 XML 파싱하기

```

XML(eXtensible MarkUp Language)은 계층적 구조와 메타데이터를 포함하는 중첩된 데이터 구조를 지원하는 또 다른 유명한 데이터 형식이다.

앞에서는 HTML에서 데이터를 파싱하기 위해 내부적으로 lxml 또는 Beautiful Soup을 사용하는 pandas.read_html 함수를 살펴봤다.

```

# 이진 데이터 형식

```

데이터를 효율적으로 저장하는 가장 손쉬운 방법은 파이썬에 기본으로 내장되어 있는 pickle 직렬화를 사용해 데이터를 이진 형식으로 저장하는 것이다.

편리하게도 pandas 객체는 모두 pickle을 이용해서 데이터를 저장하는 to_pickle 메서드를 가지고 있다.

pickle로 직렬화된 객체는 내장 함수인 pickle로 직접 불러오거나 아니면 좀 더 편리한 pickle 함수인 pandas.read_pickle 메서드를 이용해서 불러올 수 있다.

pickle은 오래 보관할 필요가 없는 데이터일 경우에만 추천한다.

pandas는 HDF5와 Message-Pack, 두 가지 바이너리 포맷을 지원한다.

```

# HDF5 사용하기

```

HDF5는 대량의 과학 계산용 배열 데이터를 저장하기 위해 고안된 훌륭한 파일 포맷이다.

C 라이브러리로도 존재하며 자바, 줄리아, 매트랩, 그리고 파이썬 같은 다양한 다른 언어에서도 사용할 수 있는 인터페이스를 제공한다.

HDF는 Hierarchical Data Format의 약자로 계층적 데이터 형식이라는 뜻이다.

각각의 HDF5 파일은 여러 개의 데이터셋을 저장하고 부가 정보를 기록할 수 있다.

```