# 오브젝트

1. 객체, 설계

2. 객체지향 프로그래밍

3. 역할, 책임, 협력

4. 설계 품질과 트레이드오프

5. 책임 할당하기

6. 메시지와 인터페이스

7. 객체 분해

8. 의존성 관리하기

9. 유연한 설계

10. 상속과 코드 재사용

11. 합성과 유연한 설계

12. 다형성

13. 서브클래싱과 서브타이핑

14. 일관성 있는 협력

15. 디자인 패턴과 프레임워크

# 클래스 다이어그램 or 커뮤니케이션 다이어그램

# 패러다임의 시대

1. 과학혁명의 구조 kuhn12

2. 절차형 패러다임에서 객체지향 패러다임으로의 변화

3. 프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다.

4. 프로그래밍 패러다임은 혁명적이 아니라 발전적이다.

# 객체, 설계

1. 로버트 마틴은 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.

2. 여기서 모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.

```

모든 소프트웨어 모듈에는 세 가지 목적이 있다.

첫 번째 목적은 실행 중에 제대로 동작하는 것이다.

두 번째 목적은 변경을 위해 존재하는 것이다.

세 번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다.

```

3. 마틴에 따르면 모든 모듈은 제대로 실행돼야 하고, 변경이 용이해야 하며, 이해하기 쉬워야 한다.

4. 의존성은 변경에 대한 영향을 암시한다.

5. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.

6. 객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 말한다. 반대로 객체들이 합리적인 수준으로 의존할 경우에는 결합도가 낮다고 말한다.

```

P20

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public TicketOffice getTicketOffice() {
        return ticketOffice;
    }

}


-> 

public class Theater {
    private TicketSeller ticketSeller;

    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }

    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}

public class TicketSeller {
    
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }

    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            
            audience.getBag().minusAmount(ticket.getFee());

            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());

            audience.getBag().setTicket(ticket);
        }
    }

}

TicketSeller에서 getTicketOffice 메서드가 제거 됐다.

tickeOffice의 가시성이 private이고 접근 가능한 퍼블릭 메서드가 더 이상 존재하지 않기 때문에 외부에서는 tciketOffice에 직접 접근할 수 없다.

결과적으로 ticketOffice에 대한 접근은 오직 TicketSeller 안에만 존재하게 된다.

따라서 TicketSeller는 tickerOffice에서 티켓을 꺼내거나 판매 요금을 적립하는 일을 스스로 수행할 수밖에 없다.

이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 부른다.

수정된 Theater 클래스 어디서도 ticketOffice에 접근하지 않는다는 사실에 주목하라.

Theater는 ticketOffice가 TicketSeller 내부에 존재한다는 사실을 알지 못한다.

Theater는 단지 ticketSeller가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

Theater는 오직 TicketSeller의 인터페이스(interface)에만 의존한다.

TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 구현(implementation)의 영역에 속한다.

```

7. 객체의 자율성을 높이는 방향으로 설계를 개선하자, 이해하기 쉽고 유연한 설계를 얻을 수 있었다.

8. 캡슐화와 응집도의 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호작용하도록 만드는 것이다.

9. 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

10. 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.

11. 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 부른다.

12. 프로세스와 데이터가 동일한 모듈 내부에 위치시키는 방식을 객체지향 프로그래밍이라고 부른다.

13. 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.

14. 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다. 따라서 각 객체는 자신을 스스로 책임진다.

15. TicketSeller의 책임은 무엇인가? 티켓은 판매하는 것이다.

16. Audience의 책임은 무엇인가? 티켓을 사는 것이다.

17. Theater의 책임은 무엇인가? 관람객을 입장시키는 것이다.

18. 적절한 객체에 적절한 책임을 할당하면 이해하기 쉬운 구조와 읽기 쉬운 코드를 얻게 된다.

19. 설계를 어렵게 만드는 것은 의존성이라는 것을 기억하라.

20. 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.

21. 예제에서 결합도를 낮추기 위해 선택한 방법은 Theater가 몰라도 되는 세부사항을 Audience와 TicketSeller 내부로 감춰 캡슐화하는 것이다.

22. 결과적으로 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다.

# 객체지향 프로그래밍

1. 할인 조건(discount condition)과 할인 정책(discount policy)

2. 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

3. 첫째, 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.

4. 둘째, 객체를 독립전인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.

5. 소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다.

6. 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다.

6. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.

7. 도메인 개념들의 구조를 반영하는 적절한 클래스 구조를 만들기 (P72)

8. 클래스는 내부와 외부로 구분되며 훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다.

10. 두 가지 중요한 사실

9. 첫째, 객체가 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재라는 것

10. 둘째, 객체가 스스로 판단하고 행동하는 자율적인 존재라는 것

11. 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 부른다.

12. 대부분의 객체지향 프로그래밍 언어들은 상태와 행동을 캡슐화하는 것에서 한 걸음 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어(access control) 메커니즘도 함께 제공한다.

13. 많은 프로그래밍 언어들은 접근 제어를 위해 public, protected, private과 같은 접근 수정자(access modifier)를 제공한다.

14. 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.

15. 객체지향의 핵심은 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다.

16. 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.

17. 캡슐화와 접근 제어를 객체를 두 부분으로 나눈다.

18. 하나는 외부에서 접근 가능한 부분으로 이를 퍼블릭 인터페이스(public interface)라고 부른다.

19. 다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 구현(implementation)이라고 부른다.

20. 인터페이스와 구현의 분리(separation of interface and implementation) 원칙은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

21. 프로그래머의 역할을 클래스 작성자(class creator)와 클라이언트 프로그래머(client programmer)로 구분하는 것이 유용하다.

22. 클래스 작성자는 새로운 데이터 타입을 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.

23. 클라이언트 프로그래머의 목표는 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것이다.

24. 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 꽁꽁 숨겨야 한다.

25. 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지함으로써 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

26. 이를 구현 은닉(implementation hiding)이라고 부른다.

27. 구현 은닉은 클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념이다.

28. 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있기 때문에 머릿속에 담아둬야 하는 지식의 양을 줄일 수 있다.

29. 클래스 작성자는 인터페이스를 바꾸지 않는 한 외부에 미치는 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

30. 다시 말해 public 영역을 변경하지 않는다면 코드를 자유롭게 수정할 수 있다는 것이다.

31. 객체의 외부와 내부를 구분하면 클라이언트 프로그래머가 알아야 할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할 수 있는 폭이 넓어진다.

32. 따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

33. 객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 한다.

34. 대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 허용한다.

35. 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청(Request)할 수 있다. 

36. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.

37. 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드(method)라고 부른다.

38. 메시지와 메서드를 구분하는 것은 매우 중요하다.

39. 메시지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.

40. 객체지향에서 중요하다고 여겨지는 두 가지 개념

41. 하나는 상속(inheritance)이고 다른 하나는 다형성이다.

42. 그리고 그 기반에는 추상화(abstraction)라는 원리가 숨겨져 있다.

43. 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴이라고 부른다.

44. 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.

45. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다는 사실을 기억하라.

45. 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하라.

46. 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.

47. 자식 클래스가 부모 클래스를 대신하는 것을 업캐스팅(upcasting)이라고 부른다.

48. 업캐스팅이라고 부르는 이유는 일반적으로 클래스 다이어그램을 작성할 때 부모 클래스를 자식 클래스의 위에 위치시키기 때문이다.

49. 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.

50. 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.

51. 다시 말해 인터페이스가 동일해야 한다는 것이다.

52. 다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

53. 다시 말해 메시지와 메서드를 실행시점에 바인딩한다는 것이다.

54. 이를 지연 바인딩(lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다.

55. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early bidning) 또는 정적 바인딩(static binding)이라고 부른다.

56. 객체지향이 컴파일 시점의 의존성과 실행 시점의 의존성을 분리하고, 하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다. 

57. 상속을 구현 상속(implementation inheritance)과 인터페이스 상속(interface inheritance)으로 분류할 수 있다.

58. 흔히 구현 상속을 서브클래싱(subclassing)이라고 부르고 인터페이스 상속을 서브타이핑(subtyping)이라고 부른다. 

59. 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것을 구현 상속이라고 부른다.

60. 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것을 인터페이스 상속이라고 부른다.

61. 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. 

62. 추상화를 사용할 경우의 두 가지 장점

63. 첫 번째 장점은 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것이다.

64. 두 번째 장점은 추상화를 이용하면 설계가 좀 더 유연해진다는 것이다.

# 역할, 책임, 협력

1. 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고 한다.

2. 객체가 협력에 참여하기 위해 수행하는 로직은 책임이라고 부른다.

3. 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다.

4. 객체를 가장 자율적으로 만드는 가장 기본적인 방법은 내부 구현을 캡슐화하는 것이다.

5. 캡슐화를 통해 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.

6. 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.

7. 협력이 바뀌면 객체가 제공해야 하는 행동 역시 바뀌어야 한다.

9. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문에 객체가 수행하는 행동에 필요한 상태도 함께 가지고 있어야 한다.

8. 객체의 행동을 결정하는 것이 협력이라면 객체의 상태를 결정하는 것은 행동이다.

9. 협력은 객체를 설계하는 데 필요한 일종의 문맥(context)을 제공한다.

10. 객체의 책임은 객체가 '무엇을 알고 있는가' 와 '무엇을 할 수 있는가'로 구성된다.

11. 객체의 책임을 크게 '하는 것(doing)'과 '아는 것(knowing)'의 두 가지 범주로 나누어 세분화하고 있다.

```

하는 것

- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것

- 다른 객체의 행동을 시작시키는 것

- 다른 객체의 활동을 제어하고 조절하는 것

아는 것

- 사적인 정보에 관해 아는 것

- 관련된 객체에 관해 아는 것

- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것


영화 예매 시스템에서..

Screening의 책임은? 

하는 것 -> 영화를 예매하는 것

아는 것 -> 자신이 상영할 영화

Move의 책임은?

하는 것 -> 요금을 계산하는 것

아는 것 -> 가격과 어떤 할인 정책이 적용 됐는지

```

12. 역할과 책임에 대한 CRC 카드 (P108) **

13. 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다.

14. 또한 객체는 자신이 할 수 없는 작업을 도와줄 객체를 알고 있을 책임이 있다.

15. 어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있는 것이다.

16. 객체지향 설계에서 가장 중요한 것은 책임이다.

17. 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다.

18. 이를 책임 할당을 위한 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.

19. 협력을 설계하는 출발점은 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보는 것이다.

20. 객체지향 설계는 시스템의 책임을 완료하는 데 필요한 더 작은 책임을 찾아내고 이를 객체들에게 할당하는 반복적인 과정을 통해 모양을 갖춰간다.

21. 책임을 갖고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 책임 주도 설계 (Resposibility-Driven Design, RDD)라고 부른다.

```

시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.

시스템 책임을 더 작은 책임으로 분할한다.

분활된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.

객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.

해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

```

22. 협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다.

23. 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.

24. 메시지가 객체를 선택해야 하는 두 가지 중요한 이유

25. 첫째, 객체가 최소한의 인터페이스(minimal interface)를 가질 수 있게 된다.

26. 필요한 메시지가 식별될 때까지 객체의 퍼블릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 않은 꼭 필요한 크기의 퍼블릭 인터페이스를 가질 수 있다.

27. 둘째, 객체는 충분히 추상적인 인터페이스(abstract interface)를 가질 수 있게 된다. 객체의 인터페이스는 무엇(what)을 하는지는 표현해야 하지만 어떻게(how) 수행하는지를 노출해서는 안 된다.

28. 메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 맞추는 인터페이스를 얻을 수 있다.

29. 영화 예매 시스템의 경우 예매하라라는 메시지를 선택하는 것으로 설계를 시작했다는 것을 기억하라

30. 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수는 객체의 행동이 아니라 상태에 초점을 맞추는 것이다.

31. 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다.

33. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.

34. 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파된다.

35. 이와 같이 객체의 내부 구현에 초점을 맞춘 설계 방법을 데이터-주도 설계(Data-Driven Desgin)라고 부르기도 했다.

36. 캡슐화를 위반하지 않도록 구현에 대한 결정을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야 한다.

37. 중요한 것은 객체의 상태가 아니라 행동이다. 협력이 객체의 행동을 결정하고 행동이 상태를 결정한다.

38. 그리고 그 행동이 바로 객체의 책임이 된다.

39. 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.

40. 실제로 협력을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋다.

41. 역할은 다른 것으로 교체할 수 있는 책임의 집합이다. (P118) *

42. 추상 클래스와 인터페이스 (P119) *

```

역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것이다.

협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것이다.

추상클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓았다는 차이가 있지만 협력의 관점에서 둘 모두 역할을 정의할 수 있는 구현 방법이라는 공통점을 공유한다.

```

43. 객체에 관해 생각할 때 '이 객체가 무슨 역할을 수행해야 하는가?'라고 자문하는 것이 도움이 된다.

44. 협력에 적합한 책임을 수행하는 대상이 한 종류라면 간단하게 객체로 간주한다.

45. 만약 여러 종류의 객체들이 참여할 수 있다면 역할이라고 부르면 된다.

46. 협력은 역할들의 상호작용으로 구성되고, 협력을 구성하기 위해 역할에 적합한 객체가 선택되며, 객체는 클래스를 이용해 구현되고 생성된다.

47. 연극 안에서 배역을 연기하는 배우라는 은유는 협력 안에서 역할을 수행하는 객체라는 관점이 가진 입체적인 측면들을 훌륭하게 담아낸다.

# 설계 품질과 트레이드오프

1. 객체지향 설계의 핵심은 역할, 책임, 협력이다.

2. 협력은 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용이다.

3. 책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동이고, 역할은 대체 가능한 책임의 집합이다.

4. 책임 주도 설계라는 이름에서 알 수 있는 것처럼 역할, 책임, 협력 중에서 가장 중요한 것은 '책임'이다.

5. 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.

6. 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다.

7. 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다.

8. 객체의 상태는 구현에 속한다. 구현은 불안정하기 때문에 변하기 쉽다. 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.

9. 결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼지게 된다.

9. 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화, 응집도, 결합도를 사용해보자

10. 캡슐화

- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서다.

- 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다.

- 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개함으로써 변경의 여파를 통제할 수 있다.

- 변경될 가능성이 높은 부분을 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다는 사실을 기억하라.

- 객체를 설계하기 위한 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다.

- 지금까지 설명한 내용에서 알 수 있는 것처럼 객체지향에서 가장 중요한 원리는 캡슐화다.

- 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.

- 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.

- 객체 내부에 무엇을 캡슐화해야 하는가?

- 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.

11. 응집도와 결합도

- 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.

- 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.

- 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.

- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.

- 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다.

12. 일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다.

13. 높은 응집도와 낮은 결합도를 가진 설계를 추구해야 하는 이유는 단 한가지다. 그것이 설계를 변경하기 쉽게 만들기 때문이다.

14. 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.

15. 변경과 응집도 사이의 관계 (P151) ***

16. 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 

17. 응집도가 낮은 설계에서는 하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산돼 있기 때문에 여러 모듈을 동시에 수정해야 한다.

17. 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다.

18. 결합도가 높으면 높을수록 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.

19. 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거다.

20. 단일 책임 원칙 (SRP)

- 클래스는 단 한가지의 변경 이유만 가져야 한다는 것

21. 캡슐화는 설계의 제 1원리다.

22. 데이터 중심의 설계가 낮은 응집도와 높은 결합도라는 문제로 몸살을 앓게 된 근본적인 원인은 바로 캡슐화의 원칙을 위반했기 때문이다.

23. 객체는 자신이 어떤 데이터를 가지고 있는지를 내부에 캡슐화하고 외부에 공개해서는 안된다.

24. 속성의 가시성을 private으로 설정했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다.

25. Rectangle을 변경하는 주체를 외부의 객체에서 Rectangle로 이동시킨다. 자신의 크기를 Rectangle 스스로 증가시키도록 '책임을 이동'시키다. (P149) *

26. 객체를 설계할 때 "이 객체가 어떤 데이터를 포함해야 하는가?"라는 질문은 다음과 같은 두 개의 개별적인 질문으로 분리해야 한다.

- 이 객체가 어떤 데이터를 포함해야 하는가?

- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

27. 두 질문을 조합하면 객체의 내부 상태를 저장하는 방식과 저장된 상태에 대해 호출할 수 있는 오퍼레이션의 집합을 얻을 수 있다.

28. 데이터 중심의 설계가 변경에 취약한 이유 두 가지

- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.

- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

29. 데이터 중심의 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

# 책임 할당하기

1. 데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서는 두 가지 원칙을 따라야 한다.

- 데이터보다 행동을 먼저 결정하라

- 협력이라는 문맥 안에서 책임을 결정하라

2. 협력이라는 문맥에서 적절한 책임이란 곧 클라이언트의 관점에서 적절한 책임을 의미한다.

3. 올바른 객체지향 설계는 클라이언트가 전송할 메시지를 결정한 후에야 비로소 객체의 상태를 저장하는 데 필요한 내부 데이터에 관해 고민하기 시작한다.

4. GRASP 패턴 (General Responsibility Assignment Software Pattern) 일반적인 책임 할당을 위한 소프트웨어 패턴의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것이다.

5. 도메인 개념에서 출발하기

6. 설계를 시작하기 전에 도메인 대한 개략적인 모습을 그려 보는 것이 유용하다.

7. 정보 전문가에게 책임을 할당하라

8. 책임 주도 설계 방식의 첫 단계는 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것이다.

9. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.

10. 메시지를 전송할 객체는 무엇을 원하는가?

11. 메시지를 수신할 적합한 객체는 누구인가?

12. 이 질문에 답하기 위해서는 객체가 상태와 행동을 통합한 캡슐화의 단위라는 사실에 집중해야 한다.

13. 따라서 객체에게 책임을 할당하는 첫 번째 원칙은 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것이다.

14. 이를 INFORMATION EXPERT(정보 전문가) 패턴이라고 부른다.

15. INFORMATION EXPERT 패턴은 객체가 자신이 소유하고 있는 정보와 관련된 작업을 수행한다는 일반적인 직관을 표현한 것이다.

16. 여기서 이야기하는 정보는 데이터와 다르다는 사실에 주의하라.

17. 책임을 수행하는 객체가 정보를 '알고'있다고 해서 그 정보를 '저장'하고 있을 필요는 없다.

18. 책임을 할당할 수 있는 다양한 대안들이 존재한다면 응집도와 결합도의 측면에서 더 나은 대안을 선택하는 것이 좋다.

19. 다시 말해 두 협력 패턴 중에서 높은 응집도와 낮은 결합도를 얻을 수 있는 설계가 있다면 그 설계를 선택해야 한다는 것이다.

20. GRASP에서는 이를 LOW COUPLING(낮은 결합도)
 패턴과 HIGH COHESION(높은 응집도) 패턴이라고 부른다.

21. LOW COUPLING 패턴

- 어떻게 하면 의존성을 낮추고 변화의 영향을 줄이며 재사용성을 증가시킬 수 있을까?

- 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.

- 낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다.

22. HIGH COHESION 패턴

- 어떻게 복잡성을 관리할 수 있는 수준으로 유지할 것인가?

- 높은 응집도를 유지할 수 있게 책임을 할당하라

- 낮은 결합도처럼 높은 응집도 역시 모든 설계 결정에서 염두에 둬야 할 원리다.

23. Screening의 가장 중요한 책임은 예매를 생성하는 것이다. (P174) **

```

만약 Screening이 DiscountCondition과 협력해야 한다면 Screnning은 영화 요금 계산과 관련된 책임 일부를 떠안아야 할 것이다.

이 경우 Screening은 DiscountCondition이 할인 여부를 판단할 수 있고 Movie가 이 할인 여부를 필요로 한다는 사실 역시 알고 있어야 한다.

다시 말해서 예매 요금을 계산하는 방식이 변경될 경우 Screening도 함께 변경해야 하는 것이다.

결과적으로 Screening과 DiscountCondition이 협력하게 되면 Screening은 서로 다른 이유로 변경되는 책임을 짊어지게 되므로 응집도가 낮아질 수밖에 없다.

반면 Movie의 주된 책임은 영화 요금을 계산하는 것이다.

따라서 영화 요금을 계산하는 데 필요한 할인 조건을 파단하기 위해 Movie가 DiscountCondition과 협력하는 것은 응집도에 아무런 해도 끼치지 않는다.

```

24. 창조자에게 객체 생성 책임을 할당하라

25. 영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것이다.

26. 이것은 협력에 참여하는 어떤 객체에게는 Reservation 인스턴스를 생성할 책임을 할당해야 한다는 것을 의미한다.

27. CREATOR(창조자) 패턴은 이 같은 경우에 사용할 수 있는 책임 할당 패턴으로서 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.

28. CREATOR 패턴

- 객체 A를 생성할 때 어떤 객체에게 객체 생성 책임을 할당해야 하는가?

- 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라

```

B가 A객체를 포함하거나 참조한다.

B가 A 객체를 기록한다.

B가 A 객체를 긴밀하게 사용한다.

B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (이 경우 B는 A에 대한 정보 전문가다)

```

- CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.

- 생성될 객체에 대해 잘 알고 있어야 하거나 그 객체를 사용해야 하는 객체는 어떤 방식으로든 생성될 객체와 연결될 것이다.

- 다시 말해서 두 객체는 서로 결합된다.

- 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.

29. 구현을 통한 검증 (P176) ****

30. 코드를 통해 변경의 이유를 파악할 수 있는 첫 번째 방법은 인스턴스 변수가 초기화되는 시점을 살펴보는 것이다.

31. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다.

32. 반면 응집도가 낮은 클래스는 객체의 속성 중 일부만 초기화하고 일부는 초기화되지 않은 상태로 남겨진다.

33. 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.

34. 코드를 통해 변경의 이유를 파악할 수 있는 두 번째 방법은 메서드들이 인스턴스 변수를 사용하는 방식을 살펴보는 것이다. 

35. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.

36. 반면 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.

37. 클래스의 응집도를 높이기 위해서는 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

38. 클래스의 응집도 판단하기

```

클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라.

클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.

메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라.

```

39. 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라는 것이다.

40. GRASP에서는 이를 POLYMORPHISM(다형성) 패턴이라고 부른다.

41. POLYMORPHISM

```

객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가?

타입을 명시적으로 정의하고 각 타입에 다형적으로 행동하는 책임을 할당하라.

조건에 따른 변화는 프로그램의 기본 논리다.

프로그램을 if ~ else 또는 swtich ~ case 등의 조건 논리를 사용해서 설계한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야 한다.

이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.

POLYMORPHISM 패턴은 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말라고 경고한다.

대신 다형성을 이용해 새로운 변화를 다루기 쉽게 확장하라고 권고한다.

```

42. PROECTED VARIATIONS 패턴

```

객체, 서브시스템, 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까?

변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라

PROTECTED VARIATIONS 패턴은 책임 할당의 관점에서 캡슐화를 설명한 것이다. "설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라"라는 객체지향의 오랜 격언은 PROTECTED VARITAIONS 패턴의 본질을 잘 설명해준다.

우리가 캡슐화해야 하는 것은 변경이다.

변경이 될 가능성이 높은가? 그렇다면 캡슐화하라

```

43. 클래스를 변경에 따라 분리하고 인터페이스를 이용해 변경을 캡슐화하는 것은 설계의 결합도와 응집도를 향상시키는 매우 강력한 방법이다.

44. 하나의 클래스가 여러 타입의 행동을 구현하고 있는 것처럼 보인다면 클래스를 분해하고 POLYMORPHISM 패턴에 따라 책임을 분산시켜라.

45. 예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 PROTECTED VARIATIONS 패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화하라.

46. 구현을 공유해야 할 경우에는 추상 클래스, 공유할 필요가 없을 경우에는 인터페이스

47. 개발자로서 변경에 대비할 수 있는 두 가지 방법이 있다.

48. 하나는 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다.

49. 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다.

50. 대부분의 경우에 전자가 더 좋은 방법이지만 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 발생하더라도 유연성을 추가하는 두 번째 방법이 더 좋다.

51. 예를 들어, 영화에 설정된 할인 정책을 실행 중에 변경할 수 있어야 한다는 요구사항이 추가됐다고 가정해 보자.

52. 현재의 설계에서는 할인 정책을 구현하기 위해 상속을 이용하고 있기 때문에 실행 중에 영화의 할인 정책을 변경하기 위해서는 새로운 인스턴스를 생성한 후 필요한 정보를 복사해야 한다.

53. 코드의 구조가 도메인의 구조에 대한 새로운 통찰력을 제공한다.

54. 객체 디자인에서 가장 기본이 되는 것 중의 하나는 책임을 어디에 둘지를 결정하는 것이다.

55. 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다.

56. 이런 메서드를 몬스터 메서드라고 부른다.

57. 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것이다.

58. 주석을 추가하는 대신 메서드를 작게 분해해서 각 메서드의 응집도를 높여라

59. 나는 다음과 같은 이유로 짧고, 이해하기 쉬운 이름으로 된 메서드를 좋아한다.

60. 첫째, 메서드가 잘게 나눠져 있을 때 다른 메서드에서 사용될 확률이 높아진다.

61. 둘째, 고수준의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌이 들게 할 수 있다.

52. 또한 메서드가 잘게 나눠져 있을 때 오버라이딩하는 것도 훨씬 쉽다. 

53. 각 메서드는 단 하나의 이유에 의해서만 변경된다.

53. 할인 조건 중에서 기간 조건을 판단하는 규칙이 변경된다면 isSatisfiedByPeriod 메서드를 수정하면 된다.

54. 할인 규칙 중에서 금액 할인 규칙이 변경된다면 calculateAmountDiscountFee 메서드를 수정하면 된다.

55. 예매 요금을 계산하는 규칙이 변경된다면 calculateFee 메서드를 수정하면 된다.

56. 작고, 명확하며, 한 가지 일에 집중하는 응집도 높은 메서드는 변경 가능한 설계를 이끌어내는 기반이 된다.

57. 이런 메서드들이 하나의 변경 이유를 가지도록 개선될 때 결과적으로 응집도 높은 클래스가 만들어진다.

# 메시지와 인터페이스

1. 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.

2. 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.

3. 메시지는 객체 사이의 협력을 가능하게 하는 매개체다.

4. 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.

5. 객체는 자신의 희망을 메시지라는 형태로 전송하고 메시지를 수신한 객체는 요청을 적절히 처리한 후 응답한다.

6. 두 객체 사이의 협력 관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버(Client-Server)모델이다.

7. 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.

8. 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.

9. 메시지와 메시지 전송

10. 메시지(message)는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

11. 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송(message sending)또는 메시지 패싱(message passing)이라고 부른다.

12. 이때 메시지를 전송하는 객체를 메시지 전송자(message sender)라고 부르고 메시지를 수신하는 객체를 메시지 수신자(message receiver)라고 부른다.

13. 클라이언트-서버 모델관점에서는 메시지 전송자는 클라이언트, 메시지 수신자는 서버라고 부르기도 한다.

14. 메시지는 오퍼레이션명(operation name)과 인자(argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.

15. 따라서 메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합이다.

16. 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.

17. 중요한 것은 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것이다.

18. 객체들로 구성된 시스템 안의 행동은 두 가지 방법으로 명세할 수 있다. 메시지와 메서드

19. 계산을 메시지와 메서드로 분리하고 실행 시간에 수신자의 클래스에 기반해서 메시지를 메서드에 바인딩하는 것은 일반적인 프로시저 호출의 관점에서 아주 작은 변화처럼 보이지만 이 작은 변화가 커다란 차이를 만든다.

20. 객체는 안과 밖을 구분하는 뚜렷한 경계를 가진다.

21. 외부에서 볼 때 객체의 안쪽은 검은 장막으로 가려진 미지의 영역이다.

22. 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.

23. 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다.

24. 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션(operation)이라고 부른다.

25. 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다.

26. 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.

27. 앞에서 예로든 DiscountCondition 인터페이스에 정의된 isSatisFiedBy가 오퍼레이션에 해당한다.

28. 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.

```

UML은 공싱적으로 오퍼레이션을 다음과 같이 정의한다.

오퍼레이션이란 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세다.

UML 용어로 말하자면, 인터페이스의 각 요소는 오퍼레이션이다.

오퍼레이션은 구현이 아닌 추상화다.

반면 UML의 메서드는 오퍼레이션을 구현한 것이다.

인용하면, 메서드는 오퍼레이션에 대한 구현이다.

메서드는 오퍼레이션과 연관된 알고리즘 또는 절차를 명시한다.

```

29. 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 시그니처(signature)라고 부른다. 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다.

30. 메서드는 이 시그니처에 구현을 더한 것이다.

```

메시지 - 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘. 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 '메시지 전송'이라고 부른다.

메시지는 협력에 참여하는 전송자와 수신자 양쪽 모두를 포함하는 개념이다.

오퍼레이션 - 객체가 다른 객체에게 제공하는 추상적인 서비스다. 메시지가 전송자와 수신자 사이의 협력 관계를 강조하는 데 비해 오퍼레이션은 메시지를 수신하는 객체의 인터페이스를 강조한다.

다시 말해서 메시지 전송자는 고려하지 않은 채 메시지 수신자의 관점만을 다룬다. 메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것을 의미한다.

메서드 - 메시지에 응답하기 위해 실행되는 코드 블록을 메서드라고 부른다. 메서드는 오퍼레이션의 구현이다. 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.

오퍼레이션과 메서드의 구분은 다형성의 개념과 연결된다.

퍼블릭 인터페이스 - 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음. 클래스의 퍼블릭 메서드들의 집합이나 메시지의 집합을 가리키는 데 사용된다. 객체를 설계할 때 가장 중요한 것은 훌륭한 퍼블릭 인터페이스를 설계하는 것이다.

시그니처 - 시그니처는 오퍼레이션이나 메서드의 명세를 나타낸 것으로, 이름과 인자의 목록을 포함한다.

대부분의 언어는 시그니처의 일부로 반환 타입을 포함하지 않지만 반환 타입을 시그니처의 일부로 포함하는 언어도 존재한다.

```

1. 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.

2. 퍼블릭 인터페이스의 품질에 영향을 미치는 기법

```

디미터 법칙

묻지 말고 시켜라

의도를 드러내는 인터페이스

명령 - 쿼리 분리

```

3. 디미터 법칙을 따르면 부끄럼타는 코드(shy code)를 작성할 수 있다.

4. 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.

5. 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다.

6. 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.

7. 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.

8. 여러분이 구현하고 있는 로직은 메시지 수신자가 담당해야 할 책임일 것이다.

9. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.

10. 절차적인 코드는 정보를 얻은 후에 결정한다.

11. 객체지향 코드는 객체에게 그것을 하도록 시킨다.

12. 객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.

13. 묻지 말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.

14. 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가? 그렇다면 해당 객체가 책임져야 하는 어떤 행동이 객체 외부로 누수된 것이다.

15. 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라

16. 협력을 설계하고 객체가 수신할 메시지를 결정하는 매 순간 묻지 말고 시켜라 원칙과 디미터 법칙을 머릿속에 떠올리는 것은 퍼블릭 인터페이스의 품질을 향상시킬 수 있는 좋은 습관이다.

17. 의도를 드러내는 인터페이스

18. 켄트 백의 메서드를 명명하는 두 가지 방법

19. 첫 번째 방법은 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것이다.

20. 이 경우 메서드의 이름은 내부의 구현 방법을 드러낸다. (P218) ***

```

public class PeriodCondition {
    public boolean isSatisfiedByPeriod(Screening screening) {...}
}

public class SequenceCondition {
    public boolean isSatisfiedBySequence(Screend screening) {...}
}

이런 스타일은 좋지 않은데 두 가지로 요약할 수 있다.

메서드에 대해 제대로 커뮤니케이션하지 못한다.

클라이언트의 관점에서는 두 가지 메소드 다 할인 조건을 판단하는 동일한 작업을 수행한다.

하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행한다는 사실을 알아채기 어렵다.

더 큰 문제는 메서드 수준에서 캡슐화를 위반한다는 것이다.

이 메서드들은 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다. PeriodCondition을 사용하는 코드를 SequenceCondition을 사용하도록 변경하려면 단순히 참조하는 객체를 변경하는 것뿐만 아니라 호출하는 메서드를 변경해야 한다.

만약 할인 여부를 판단하는 방법이 변경된다면 메서드의 이름 역시 변경해야 할 것이다.

메서드 이름을 변경한다는 것은 메시지를 전송하는 클라이언트의 코드도 함께 변경해야 한다는 것을 의미한다. 

따라서 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약할 수밖에 없다.

```

21. 메서드의 이름을 짓는 두 번째 방법은 '어떻게'가 아니라 '무엇'을 하는지를 드러내는 것이다.

22. 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수밖에 없다.

23. 반면 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.

24. 이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며, 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다. 

25. 클라이언트의 관점에서 두 메서드는 할인 여부를 판단하기 위한 작업을 수행한다.

26. 따라서 두 메서드 모두 클라이언트의 의도를 담을 수 있도록 isSatisfiedBy로 변경하는 것이 적절할 것이다.

27. 클라이언트가 두 메서드를 가진 객체를 동일한 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어야 한다.

28. 가장 간단한 방법은 DiscountCondition이라는 인터페이스를 정의하고 이 인터페이스에 isSatisfiedBy 오퍼레이션을 정의하는 것이다.

```

public interface DiscountCondition {
    boolean isSatisfiedBy(Screening screening);
}


public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy (Screening screening) {...}
}

public class SequenceCondition implements DiscountCondition {
    public boolean isSatisfiedBy (Screening screening) {...}
}

```

29. 이처럼 어떻게 하느냐가 아니라 무엇을 하느냐에 다라 메서드의 이름을 짓는 패턴을 의도를 드러내는 선택자(Intention Revealing Selector)라고 부른다.

30. 켄트 벡은 메서드에 의도를 드러낼 수 있는 이름을 붙이기 위해 다음과 같이 생각할 것은 조언한다.

31. 도메인 주도 설계에서 에릭 에반스는 켄트 벡의 의도를 드러내는 선택자를 인터페이스 레벨로 확장한 의도를 드러내는 인터페이스(Intention Revealing Interface)를 제시했다.

32. 객체에게 묻지 말고 시키되 구현 방법이 아닌 클라이언트의 의도를 드러내야 한다.

33. 이것이 이해하기 쉽고 유연한 동시에 협력적인 객체를 만드는 가장 기본적인 요구사항이다.

34. 근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다.

35. 기억해야 할점은 객체의 내부 구조는 구현에 해당한다는 것이다.

36. P221 ~ P227 리팩토링 + 퍼블릭 인터페이스의 의도

37. 위임 메서드를 통해 객체의 내부 구조를 감추는 것은 협력에 참여하는 객체들의 결합도를 낮출 수 있는 동시에 객체의 응집도를 높일 수 있는 가장 효과적인 방법이다.

38. 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다.

39. 결과적으로는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.

40. 클래스는 하나의 변경 원인만을 가져야 한다.

41. 가끔식은 필요에 따라 물어야 한다는 사실에 납득했다면 명령-쿼리 분리(Command-Query Separation) 원칙을 알아두면 도움이 될 것이다.

42. 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.

43. 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴(routine)이라고 부른다.

44. 루틴은 다시 프로시저(procedure)와 함수(function)로 구분할 수 있다.

```

프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.

함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.

```

45. 명령(command)과 쿼리(query)는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.

46. 객체의 상태를 수정하는 오퍼레이션을 명령이라고 부르고 객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리라고 부른다.

47. 명령 = 프로시저, 쿼리 = 함수

48. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.

```

객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.

객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

```

49. "질문이 답변을 수정해서는 안 된다"

50. P234 ~ P240 명령과 쿼리의 사용 + 퍼블릭 인터페이스와 가시성 **

51. 책임에 초점을 맞춰라

52. 메시지를 먼저 선택하는 방식이 디미터 법칙, 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스, 명령-쿼리 분리 원칙에 미치는 긍정적인 영향을 살펴보면 다음과 같다.

```

디미터 법칙 - 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.

수신할 객체를 알지 못한 상태에서 메시지를 먼저 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.

따라서 메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.

묻지 말고 시켜라 - 메시지를 먼저 선택하면 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.

클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현할 메시지를 전송하면 된다.

의도를 드러내는 인터페이스 - 메시지를 먼저 선택한다는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다. 당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수밖에 없다.

명령-쿼리 분리 원칙 - 메시지를 먼저 선택한다는 것은 협력이라는 문맥 안에서 객체의 인터페이스에 관해 고민한다는 것을 의미한다. 객체가 단순히 어떤 일을 해야 하는지 뿐만 아니라 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 된다.

따라서 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 될 것이다.

```

53. 훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.

# 객체 분해 

1. 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업을 추상화라고 부른다.

2. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 분해(decomposition)라고 부른다.

3. 분해의 목적은 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것이다.

4. 현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘은 프로시저 추상화(procedure abstraction)와 데이터 추상화(data abstraction)다.

5. 프로시저 추상화는 소프트웨어가 무엇을 해야하는지를 추상화한다.

6. 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다.

7. 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.

8. 시스템을 분해하는 방법을 결정하려면 먼저 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지를 결정해야 한다.

9. 프로시저 추상화를 중심으로 시스템을 분해하기로 결정했다면 기능 분해(functional decomposition)의 길로 들어서는 것이다.

10. 기능 분해는 알고리즘 분해(algorithm decompostion)라고 부르기도 한다.

11. 데이터 추상화를 중심으로 시스템을 분해하기로 결정했다면 다시 두 가지 중 하나를 선택해야 한다.

12. 하나는 데이터를 중심으로 타입을 추상화(type abstraction)하는 것이고 다른 하나는 데이터를 중심으로 프로시저를 추상화(procedure abstract)하는 것이다.

13. 전자를 추상 데이터 타입(Abstract Data Type)이라고 부르고 후자를 객체지향(Object-Oriented)이라고 부른다.

14. 전통적인 기능 분해 방법은 하향식 접근법(Top-Down Approach)을 따른다. 하향식 접근법이란 시스템을 구성하는 가장 최상위(topmost) 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.

15. 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다.

16. 하향식 기능 분해 방식이 가지는 문제점을 이해하는 것은 유지보수 관점에서 객체지향의 장점을 이해할 수 있는 좋은 출발점이다.

17. 기능 분해 방식에 따라 분해된 급여 관리 시스템을 구현해가면서 전통적인 하향식 기능 분해 방식이 가지는 문제점을 살펴보자.

18. P252 ~ 255 하향식 기능 분해 ***

18. 하향식 기능 분해의 문제점

```

시스템은 하나의 메인 함수로 구성돼 있지 않다.

기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.

비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.

하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.

데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

```

19. 설계는 코드 배치 방법이며 설계가 필요한 이유는 변경에 대비하기 위한 것이라는 점을 기억하라.

20. 변경은 성공적인 소프트웨어가 맞이해야 하는 피할 수 없는 운명이다.

21. 시스템 안에는 여러 개의 정상이 존재하기 때문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하는 하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.

22. 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.

23. 하향식으로 기능을 분해하는 과정은 하나의 함수를 더 작은 함수로 분해하고, 분해된 함수들의 실행 순서를 결정하는 작업으로 요약할 수 있다.

24. 이것은 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지가 아니라 어떻게(how) 동작해야 하는지에 집중하도록 만든다.

25. 하향식 접근법의 설계는 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 시간 제약(temporal constraint)을 강조한다.

26. 메인 함수가 작은 함수들로 분해되기 위해서는 우선 함수들의 순서를 결정해야 한다.

27. 함수가 재사용 가능하려면 상위 함수보다 더 일반적이어야 한다.

28. 하지만 하향식 접근법을 따를 경우 분해된 하위 함수는 항상 상위 함수보다 문맥에 더 종속적이다.

29. 이것은 정확하게 재사용과 반대되는 개념이다.

30. 하향식 설계와 관련된 모든 문제의 원인은 결합도다.

31. 함수는 상위 함수가 강요하는 문맥에 강하게 결합된다.

32. 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다.

33. 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.

34. 이를 위해 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 한다.

35. 즉, 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다.

36. 이것이 바로 의존성 관리의 핵심이다.

37. 하향식은 이미 완전이 이해된 사실을 서술하기에 적합한 방법이다.

38. 그러나 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.

39. 정보 은닉(information hiding)은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 사용되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.

40. 모듈은 서브 프로그램이라기보다는 책임의 할당이다.

41. 모듈화는 개별적인 모듈에 대한 작업이 시작되기 전에 정해져야 하는 설계 결정들을 포함한다.

42. 정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리다.

43. 모듈은 변경될 가능성이 있는 비밀은 내부로 감추고, 잘 정의되고 쉽게 변경되지 않을 퍼블릭 인터페이스를 외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.

44. 모듈 분해는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다.

45. 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인터페이스를 구현할 수 있다.

46. 모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

```

복잡성 - 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 

외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.

변경 가능성 - 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 

변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

```

47. 모듈의 장점과 한계

```

모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.

비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.

전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

```

48. 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.

49. 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다.

50. 따라서 모듈 내부는 높은 응집도를 유지한다. 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신해야 한다.

51. P269 ~ P270 모듈이 가지는 장점

52. 모듈에 있어서 핵심은 데이터다. 

53. 메인 함수를 정의하고 필요에 따라 더 세부적인 함수로 분해하는 하향식 기능 분해와 달리 모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조작하는 데 필요한 함수를 결정한다.

52. 다시 말해서 기능이 아니라 데이터를 중심으로 시스템을 분해하는 것이다.

53. 모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위다.

54. 좀 더 높은 수준의 추상화를 위해서는 직원 전체가 아니라 개별 직원을 독립적인 단위로 다룰 수 있어야 한다.

55. 다시 말해서 다수의 직원 인스턴스가 존재하는 추상화 메커니즘이 필요한 것이다.

55. 그리고 이를 만족시키기 위해 등장한 개념이 바로 추상 데이터 타입이다.

56. 추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 지원이 필요하다.

```

타입 정의를 선언할 수 있어야 한다.

타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.

제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.

타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

```

57. 클래스는 추상 데이터 타입인가?

58. 클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다

59. 상속과 다형성을 지원하는 객체지향 프로그래밍(Object-Oriented Programming)과 구분하기 위해 상속과 다형성을 지원하지 않은 추상 데이터 타입 기반의 프로그래밍 패러다임을 객체기반 프로그래밍(Object-Based Programming)이라고 부르기도 한다.

60. 추상 데이터 타입은 타입을 추상화한 것(type abstraction)이고 클래스는 절차를 추상화한 것(procedure abstraction)이다.

61. P275 타입 추상화와 절차 추상화의 차이점 **

62. 추상 데이터 타입이 오퍼레이션을 기준으로 타입을 묶는 방법이라면 객체지향은 타입을 기준으로 오퍼레이션을 묶는다.

63. 정규 직원과 아르바이트 직원이라는 두 가지 클래스로 분리할 경우 공통 로직을 어디에 둘 것인지가 이슈가 된다.

64. 공통 로직을 제공할 수 있는 가장 간단한 방법은 공통 로직을 포함한 부모 클래스를 정의하고 두 직원 유형의 클래스가 부모 클래스를 상속받게 하는 것이다.

65. 이제 클라이언트는 부모 클래스의 참조자에 대해 메시지를 전송하면 실제 클래스가 무엇인지에 따라 적절한 절차가 실행된다.

66. 즉, 동일한 메시지에 대해 서로 다르게 반응한다. 이것이 바로 다형성이다.

67. 클라이언트의 관점에서 두 클래스의 인스턴스는 동일하게 보인다는 것에 주목하라

68. 객체지향은 절차 추상화(procedural abstraction)다.

69. 클래스가 추상 데이터 타입의 개념을 따르는지를 확인할 수 있는 가장 간단한 방법은 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지를 살펴보는 것이다.

70. 추상 데이터 타입으로 구현된 Employee 클래스를 살펴보면 hourly라는 인스턴스 변수에 직원의 유형을 저장한다는 것을 알 수 있다.

71. 이처럼 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다.

72. 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.

73. 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.

74. 흔히 '객체지향이란 조건문을 제거하는 것'이라는 다소 편협한 견해가 널리 퍼진 이유가 바로 이 땜누이다.

75. 모든 설계 문제가 그런 것처럼 조건문을 사용하는 방식을 기피하는 이유 역시 변경 때문이다.

76. 추상 데이터 타입을 기반으로 한 Employee에 새로운 직원 타입을 추가하기 위해서는 hourly의 값을 체크하는 클라이언트의 조건문을 하나씩 다 찾아 수정해야 한다.

77. 이에 반해 객체지향은 새로운 직원 유형을 구현하는 클래스를 Employee 상속 계층에 추가하고 필요한 메서드를 오버라이딩 하면 된다.

78. 이처럼 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 개방-폐쇄 원칙(Open-Closed Principle, OCP)이라고 부른다.

79. 새로운 타입을 빈번하게 추가해야 한다면 객체지향의 클래스 구조가 더 유용하다.

80. 새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택하는 것이 현명한 판단이다.

# 의존성 관리하기

1. 잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다.

2. 작고 응집도 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체를 의미한다.

3. 이런 작은 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 때문에 일반적인 애플리케이션의 기능을 구현하기 위해서는 다른 객체에게 도움을 요청해야 한다.

4. 이런 요청이 객체 사이의 협력을 낳는다.

5. 협력을 위해서는 의존성이 필요하지만 과도한 의존성을 애플리케이션을 수정하기 어렵게 만든다.

6. 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 데 있다.

7. 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.

8. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.

```

실행 시점 - 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.

구현 시점 - 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

```

9. 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.

10. 의존성은 방향성을 가지며 항상 단방향이다.

11. Screening이 변경될 때 PeriodCondition이 영향을 받게 되지만 그 역은 성립하지 않는다. P284 *

12. PeriodCondition이 의존하고 있는 모든 대상 

```

PeriodCondition -> DiscountCondition -> 인터페이스에 정의된 오퍼레이션들을 펍르릭 인터페이스의 일부로 포함시키기 위해 의존

PeriodCondition -> DayOfWeek -> 인스턴스 변수

PeriodCondition -> LocalTime -> 인스턴스 변수

PeriodCondition -> Screening -> 메서드 인자

```

13. 의존성은 전이될 수 있다.

14. 의존성 전이(transitive dependency)가 의미하는 것은 PeriodCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다.

```

PeriodCondition -> Screening -> Movie

```

15. 의존성은 전이될 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)과 간접 의존성(indirect dependency)으로 나누기도 한다.

16. 직접 의존성이란 말 그대로 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다.

17. PeriodCondition이 Screening에 의존하는 경우가 여기에 속하며, 이 경우 의존성은 PeriodCondition의 코드에 명시적으로 드러난다.

18. 간접 의존성이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전판되는 경우를 가리킨다.

19. 이 경우 의존성은 PeriodCondition의 코드안에 명시적으로 드러나지 않는다.

20. 의존성과 관련해서 다뤄야 하는 또 다른 주제는 런타임 의존성(run-time dependency)과 컴파일 타임 의존성(compile-time dependency)의 차이다.

21. 먼저 여기서 사용하는 런타임과 컴파일타임의 의미를 이해할 필요가 있다.

22. 런타임은 간단한다. 말 그대로 애플리케이션이 실행되는 시점을 가리킨다.

23. 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 코드 그 자체를 가리키기도 한다.

24. 컴파일타임 의존성이 바로 이런 경우에 해당한다.

25. 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문이다.

26. 또한 동적 타입 언어의 경우에는 컴파일타임이 존재하지 않기 때문에 컴파일타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있다.

27. 객체지향 애플리케이션에서 런타임의 주인공은 객체다.

28. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.

29. 반면 코드 관점에서 주인공은 클래스다.

30. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

31. 여기서 중요한 것은 런타임 의존성과 컴파일타임 의존성이 다를 수 있다는 것이다.

32. 사실 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.

33. 의존성 ***** P288 ~ P289

34. 유연하고 확장 가능한 설계를 만들기 위해서는 컴파일타임 의존성과 런타임 의존성이 달라야 한다는 사실을 이해했을 것이다.

35. 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안 된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.

```

구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될 것인지를 구체적으로 명시하는 것과 같다. Movie 클래스 안에 PercentDiscountPoilicy 클래스에 대한 컴파일타임 의존성을 명시적으로 표현하는 것은 Movie가 비율 할인 정책이 적용된 영화의 요금을 계산하는 문맥에서 사용될 것이라는 것을 가정하는 것이다.

이와 달리 Movie 클래스에 추상 클래스인 DiscountPolicy에 대한 컴파일타임 의존성을 명시하는 것은 Movie가 할인 정책에 따라 요금을 계산하지만 구체적으로 어떤 정책을 따르는지는 결정하지 않았다고 선언하는 것이다. 이 경우 구체적인 문맥은 컴파일타임 의존성을 어떤 런타임 의존성으로 대체하느냐에 따라 달라질 것이다.

```

36. 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 컨텍스트 독립성이라고 부른다.

37. 클래스가 실행 컨텍스트에 독립적인데도 어떻게 실행 컨텍스트에 적절한 객체들과 협력할 수 있을까?

38. 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체돼야 한다.

39. 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성해결이라고 부른다.

40. 의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다. ***** P291 (의존성 해결)

```

객체를 생성하는 시점에 생성자를 통해 의존성 해결

객체 생성 후 setter 메서드를 통해 의존성 해결

메서드 실행 시 인자를 이용해 의존성 해결

```

41. 객체를 생성하는 시점에 생성자를 통해 의존성 해결 

```

Movie avatar = new Movie("아바타", Duration.ofMinutes(120), Money.wons(10000), new AmountDiscountPolicy(...));

Movie avatar = new Movie("스타워즈", Duration.ofMinutes(180), Money.wons(11000), new PercentDiscountPolicy(...));

이를 위해 Movie 클래스는 PercentDiscountPolicy와 AmountDiscountPolicy 인스턴스 모두를 선택적으로 전달받을 수 있도록 이 두 클래스의 부모 클래스인 DiscountPolicy 타입의 인자를 받는 생성자를 정의한다.

public class Movie {
    public Movie(String title, Duration runningTime, Money Fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}

```

42. 인스턴스를 생성한 후에 메서드를 이용해 의존성을 해결하는 방법

```

Movie avatar = new Movie(...);
avatar.setDiscountPolicy(new AmountDiscountPolicy(...));

public class Movie {
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
}

```

43. setter 메서드를 이용하는 방식은 객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열어 놓고 싶은 경우에 유용하다.

44. setter 메서드를 이용하는 방법은 실행 시점에 의존 대상을 변경할 수 있기 때문에 설계를 좀 더 유연하게 만들 수 있다.

45. 단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 점이다.

46. 더 좋은 방법은 생성자 방식과 setter 방식을 혼합하는 것이다.

47. 항상 객체를 생성할 때 의존성을 해결해서 완전한 상태의 객체를 생성한 후, 필요에 따라 setter 메서드를 이용해 의존 대상을 변경할 수 있게 할 수 있다.

48. 바람직한 의존성을 재사용성과 관련이 있다.

49. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다.

50. 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합도(loose coupling) 또는 약한 결합도(weak coupling)를 가진다고 말한다.

51. 반대로 두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도(tight coupling) 또는 강한 결합도 (strong coupling)를 가진다고 말한다.

52. 의존성과 결합도 P296 *

53. 구체 클래스 의존성 -> 추상 클래스 의존성 -> 인터페이스 의존성

54. 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다. 이것이 핵심이다.

55. 명시적인 의존성(explict dependency)과 숨겨진 의존성(hidden dependency)

```

public class Movie {

    private DiscountPolicy discountPoilicy;

    public movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }

}

의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부다.

생성자의 인자로 선언하는 방법은 Movie가 DiscountPolicy에 의존한다는 사실을 Movie의 퍼블릭 인터페이스에 드러내는 것이다.

모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출된다. 이를 명시적인 의존성(explict dependency)이라고 부른다.

반면 Movie의 내부에서 AmountDiscountPolicy의 인스턴스를 직접 생성하는 방식은 Movie가 DiscountPolicy에 의존한다는 사실을 감춘다. 다시 말해 의존성이 퍼블릭 인터페이스에 표현되지 않는다.

이를 숨겨진 의존성(hidden dependency)이라고 부른다.

```

56. 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수밖에 없다.

57. 의존성은 명시적으로 표현돼야 한다. 의존성을 구현 내부에 숨겨두지 마라. 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.

58. 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.

59. new는 해롭다 **** P301

```

new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다.

따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.

new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.

따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.

```

60. P304 ** 생성의 책임을 분리..

- 이 그림에서도 결국 new Movie라는 것을 사용하는데.. ? 

61. 사용자 생성의 책임을 분리하고, 의존성을 생성자에 명시적으로 드러내고, 구체 클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만들 수 있다.

62. 그리고 그 출발은 객체를 생성하는 책임을 객체 내부가 아니라 클라이언트로 옮기는 것에서 시작했다는 점을 기억하라.

# 유연한 설계 

1. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

2. 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

3. 여기서 키워드는 '확장'과 '수정'이다. 이 둘은 순서대로 애플리케이션의 '동작'과 '코드'의 관점을 반영한다.

```

확장에 대해 열려 있다 - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.

수정에 대해 닫혀 있다 - 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다. 

```

4. 사실 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다. 런타임 의존성은 실행시에 협력에 참여하는 개체들 사이의 관계다.

5. 컴파일타임 의존성은 코드에서 드러나는 클래스들 사이의 관계다. P313 ***

6. 개방-폐쇄 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.

7. P314 확장에는 열려 있고 수정에는 닫혀 있는 할인 정책 설계

8. 개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.

9. 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.

10. 개방-폐쇄 원칙의 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다.

11. 공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다.

12. 다시 말해서 수정할 필요가 없어야 한다.

13. 따라서 추상화 부분은 수정에 대해 닫혀 있다.

14. 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.

15. 변하지 않는 부분을 고정하고 변하는 부분을 생략하는 추상화 메커니즘이 개방-폐쇄 원칙의 기반이 된다는 사실에 주목하라.

16. 언제라도 추상화의 생략된 부분을 채워넣음으로써 새로운 문맥에 맞게 기능을 확장할 수 있다.

17. 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다.

18. 개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.

19. 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.

20. Movie는 할인 정책을 추상화한 DiscountPolicy에 대해서만 의존한다.

21. 의존성은 변경의 영향을 의미하고 DisocountPolicy는 변하지 않는 추상화라는 사실에 주목하라.

22. Movie는 안정된 추상화인 DiscountPolicy에 의존하기 때문에 할인 정책을 추가하기 위해 DiscountPolicy의 자식 클래스를 추가하더라도 영향을 받지 않는다. 따라서 Movie와 DiscountPolicy는 수정에 대해 닫혀 있다.

23. 앞 장에서 설명한 것처럼 명시적 의존성과 의존성 해결 방법을 통해 컴파일타임 의존성을 런타임 의존성으로 대체함으로써 실행 시에 객체의 행동을 확장할 수 있다.

24. 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

25. ***** P316 추상화를 했다고 해서 모든 수정에 대해 설계가 폐쇄되는 것은 아니라는 것이다.

26. 메시지를 전송하지 않고 객체를 생성하기만 한다면 아무런 문제가 없다.

27. 또는 객체를 생성하지 않고 메시지를 전송하기만 하는것도 괜찮다.

28. 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제다.

29. 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.

30. 하나는 객체를 생성하는 것이고, 다른 하나는 객체를 사용하는 것이다.

31. 한 마디로 말해서 객체에 대한 생성과 사용을 분리(separating use from creation)해야 한다.

32. 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는) 시작 단계와 (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다.

33. 사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.

34. 다시 말해서 Movie의 클라이언트가 적절한 DiscountPolicy 인스턴스를 생성한 후 Movie에게 전달하게 하는 것이다.

35. Factory추가하고 P319 *

36. 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.

37. PURE FABRICATION 패턴

```

객체지향 설계는 문제 도메인 상의 개념을 소프트웨어 객체로 구현하고 책임을 할당한다.

하지만 만약 도메인 객체에 책임을 할당한 경우 HIGH COHESION, LOW COUPLING, 재사용성 등의 목적을 위반한다면 어떻게 해야 하는가?

문제 도메인 개념을 포함하지 않는, 인의적으로 또는 편의상 만든 클래스에 매우 응집된 책임을 할당하라.

```

38. 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입(Dependency Injection)이라고 부른다.

39. 이 기법을 의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.

40. 의존성 주입에서 의존성을 해결하는 세 가지 방법

```

생성자 주입(construction injection): 객체를 생성하는 시점에 생성자를 통한 의존성 해결

setter 주입(setter injection): 객체 생성 후 setter 메서드를 통한 의존성 해결

메서드 주입(method injection): 메서드 실행 시 인자를 이용한 의존성 해결

```

41. 생성자 주입

```

Movie 생성자의 인자로 AmountDiscountPolicy의 인스턴스를 전달해서 DiscountPolicy 클래스에 대한 컴파일타임 의존성을 런타임 의존성으로 대체하는 예

Movie의 생성자를 이용해 의존성을 주입하기 때문에 생성자 주입이라고 부른다.

Movie avatar = new Moive("아바타", Duration.ofMinutes(120), Money.wons(10000), new AmountDiscountPolicy(...));

```

42. setter 주입

```

setter 주입은 이미 생성된 movie에 대해 setter 메서드를 이용해 의존성을 해결한다.

avatar.setDiscountPolicy(new AmountDiscountPolicy(...));

```

43. 메서드 주입 or 메서드 호출 주입(method call injection)

```

메서드가 의존성을 필요로 하는 유일한 경우일 때 사용할 수 있다.

생성자 주입을 통해 의존성을 전달받으면 객체가 올바른 상태로 생성되는 데 필요한 의존성을 명확하게 표현할 수 있다는 장점이 있지만

주입된 의존성이 한 두 개의 메서드에서만 사용된다면 각 메서드의 인자로 전달하는 것이 더 나은 방법일 수 있다.

avatar.calculateDiscountAmount(screening, new AmountDiscountPolicy(...));

```

44. 의존성 주입 외에도 의존성을 해결할 수 있는 다양한 방법이 존재한다.

45. 그중에서 가장 널리 사용되는 대표적인 방법은 SERVICE LOCATOR 패턴이다. 

46. SERVICE LOCATOR는 의존성을 해결할 객체들을 보관하는 일종의 저장소다.

```

SERVICE LOCATOR 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 클래스의 타입이 무엇인지),

어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해준다.

의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 컴파일타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있다.

숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다.

의존성을 숨기는 코드는 단위 테스트 작성도 어렵다.

```

47. 추상화와 의존성 역전 (P330) ** - 추상화에 의존하라

```

Movie -> Amount DiscountPolicy X

왜 X? Percent DiscountPolicy가 추가될 경우?


Movie -> DiscountPolicy <- Amount DiscountPolicy

```

48. 의존성 역전 원칙(Dependency Inversion Principle, DIP)

```

상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.

추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

```

49. 의존성 역전 원칙과 패키지 (P333) **

50. 훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다.

51. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.

52. 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일 타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미한다.

53. 유연성은 항상 복잡함은 수반한다. 유연하지 않은 설계는 단순하고 명확하다. 유연한 설계는 복잡하고 암시적이다.

54. 객체지향에 입문한 개발자들이 가장 이해하기 어려워하는 부분이 바로 코드 상에 표현된 정적인 클래스의 구조와 실행 시점의 동적인 객체 구조가 다르다는 사실이다.

55. 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.

56. 따라서 역할, 책임, 협력에 먼저 집중하라

# 상속과 코드 재사용

1. 객체지향 프로그래밍의 장점 중 하나는 코드를 재사용하기가 용이하다는 것이다.

2. 전통적인 패러다임에서 코드를 재사용하는 방법은 코드를 복사한 후 수정하는 것이다.

3. 객체지향은 조금 다른 방법을 취한다.

4. 객체지향에서는 코드를 재사용하기 위해 '새로운'코드를 추가한다.

5. 객체지향에서 코드는 일반적으로 클래스 안에 작성되기 때문에 객체지향에서 클래스를 재사용하는 전통적인 방법은 새로운 클래스를 추가하는 것이다.

6. 클래스를 재사용하기 위해 새로운 클래스를 추가하는 가장 대표적인 기법 '상속'

7. 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.

8. 객체지향에서는 상속 외에도 코드를 효과적으로 재사용할 수 있는 방법이 한 가지 더 있다.

9. 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법으로 흔히 '합성'이라고 부른다.

10. 중복 코드는 변경을 방해한다.

11. 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.

12. DRY 원칙 -> Don't Repeat Yourself 동일한 지식을 중복하지 말라.

13. 중복 코드 살펴보기 (P340) ** 중복 코드의 문제

14. 타입 코드 사용하기 (P346) ** 중복 코드를 제거하는 한 가지 방법, 클래스를 하나로 합치는 것

15. 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다. **

16. 상속을 위한 경고 1

```

자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. 

super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

```

17. 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)라고 부른다.

18. 상속을 위한 경고 2

```

상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

```

19. 상속을 위한 경고 3

```

자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

```

20. 상속을 위한 경고 4

```

클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나,

자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.

```

21. 추상화에 의존하자

22. 코드 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙

```

두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.

부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.

부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다

자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있따.

```

23. 중복 코드 안에서 차이점을 별도의 메서드로 추출하는 것이다.

24. 변하는 것으로부터 변하지 않는 것을 분리하라. (P363) *** 

```

- phone -> NightlyDiscountPhone 에서

- AbstractPhone -> phone
- AbstractPhone -> NightlyDiscountPhone 

```

25. 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가진다는 것에 주목하라.

```

Abstract Phone은 전체 통화 목록을 계산하는 방법이 바뀔 경우에만 변경된다.

Phone은 일반 요금제의 통화 한 건을 계산하는 방식이 바뀔 경우에만 변경된다.

NightlyDiscountPhone은 심야 할인 요금제의 통화 한 건을 계산하는 방식이 바뀔 경우에만 변경된다.

세 클래스는 각각 하나의 변경 이유만을 가진다.

이 클래스들은 단일 책임 원칙을 준수하기 때문에 응집도가 높다.

```

26. 상속이 강력한 이유는 익숙한 개념을 이용해서 새로운 개념을 쉽고 빠르게 추가할 수 있기 때문이다.

27. 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 차이에 의한 프로그래밍(programming by difference)이라고 부른다.

28. 상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법은 합성이다.

# 합성과 유연한 설계

1. 상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용하는 데 비해

2. 합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.

3. 상속에서 부모 클래스와 자식 클래스 사이의 의존성은 컴파일타임에 해결되지만 합성에 두 객체 사이의 의존성은 런타임에 해결된다.

4. 상속 관계는 is-a 관계라고 부르고 합성 관계는 has-a 관계라고 부른다.

5. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.

6. 따라서 합성을 이용하면 포함된 객체의 내부 구현이 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 더 안정적인 코드를 얻을 수 있게 된다.

7. 상속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계다.

8. 이 차이점은 생각보다 중요한데, 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관계는 실행 시점에 동적으로 변경할 수 있기 때문이다.

9. 따라서 상속 대신 합성을 사용하면 변경하기 쉽고 유연한 설계를 얻을 수 있다.

10. 상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.

11. 따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다.

12. 다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.

13. 코드 재사용을 위해 상속을 남용했을 때 직면할 수 있는 세 가지 문제

```

불필요한 인터페이스 상속 문제 - 자식 클래스에게 부적합한 오퍼레이션이 상속되기 때문에 자식 클래스 인스턴스의 상태가 불안정해지는 문제

메서드 오버라이딩의 오작용 문제 - 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제

부모 클래스와 자식 클래스의 동시 수정 문제 - 부모 클래스와 자식 클래스 사이의 개념적인 결합으로 인해 부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제

```

14. 합성을 사용하면 상속이 초래하는 세 가지 문제점을 해결할 수 있다.

15. 상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.

15. 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것을 포워딩(forwarding)이라 부르고,

16. 동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드(forwarding method)라고 부른다.

17. 합성을 사용하면 오직 하나의 클래스만 추가하고 런타임에 필요한 정책들을 조합해서 원하는 기능을 사용할 수 있다. (385~408p) ***

```

403 ~ 405 여러번 읽어보기 **

Phone 내부에 RatePolicy에 대한 참조자가 포함돼 있다는 것에 주목하라. 이것이 바로 합성이다.

Phone이 다양한 요금 정책과 협력할 수 있어야 하므로 요금 정책의 타입이 RatePolicy라는 인터페이스로 정의돼 있다는 것에도 주목하라.

Phone은 이 컴파일타임 의존성을 구체적인 런타임 의존성으로 대체하기 위해 생성자를 통해 RatePolicy의 인스턴스에 대한 의존성을 주입받는다.

Phone의 경우처럼 다양한 종류의 객체와 협력하기 위해 합성 관계를 사용하는 경우에는 합성하는 객체의 타입을 인터페이스나 추상 클래스로 선언하고

의존성 주입을 사용해 런타임에 필요한 객체를 설정할 수 있도록 구현하는 것이 일반적이다.


```



