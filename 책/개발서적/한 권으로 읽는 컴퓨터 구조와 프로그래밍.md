# 한 권으로 읽는 컴퓨터 구조와 프로그래밍 

# 컴퓨터 보안

1. 데이터 암호화 표준 (Data Encryption Standard, DES)

2. DES를 대신하는 향상된 암호화 표준 (Advanced Encryption Standard, AES)

3. 어떤 내용을 다른 내용 속에 감추는 방식 - 스테가노그래피

4. 공개키 암호 시스템은 암호화와 복호화에 사용하는 키가 다르기 때문에 비대칭 시스템이다.

5. 비대칭 암호화는 계산 비용이 많이 든다.

6. 그로 인해 비밀리에 메시지 내용을 실제로 암호화할 때 사용할 대칭 세션 키를 만들기 위해 비대칭 암호화를 사용하는 경우도 자주 있다.

# 전자 회로의 조합 논리

1. 아날로그 세계에서 디지털 만들기

2. 수많은 엔지니어가 과학자들이 발견한 자연적으로 발생하는 전이 함수를 영리하게 응용하는 데 참여했다.

3. 카메라 센서나 필름의 전이 함수

4. x축은 들어오는 빛의 양(입력)을 뜻하며, y축은 (센서나 필름에) 기록되는 밝기나 센서가 기록하는 빛(출력)을 의미한다.

5. 곡선은 이 둘 사이의 관계를 보여준다.

6. 빛이 곡선의 상단부에 많이 닿으면 필름이나 센서에 기록되는 밝기 값이 서로 모이면서 최댓값에 가까워져서 이미지 노출이 과해진다.

7. 비슷한 방식으로 빛이 곡선의 하단부에 많이 닿으면 이미지 노출이 부족해진다.

8. 카메라의 경우, 목표는 노출을 조절해서 빛이 직선부에 많이 닿게 만드는 것이다.

9. 빛이 선형 영역에 닿게 하기 위해 카메라의 셔터 속도나 조리개를 조절하는 장치를 만들었다.

10. 여러분이 사용하는 이어폰이나 스피커를 구동하는 증폭 회로도 이런 트릭에 속한다.

11. 볼륨은 게인 또는 곡선이 가파른 정도를 조절한다. 

12. 게인이 높으면 곡선이 가팔라지고 출력도 커진다.

13. 게인이 11로 고정된 특별한 증폭기를 사용한다면? 이렇게 하면 출력이 더 이상 입력을 충실하게 재현하지 못하기 때문에 왜곡이 발생하며, 소리가 이상해진다.

14. 입력이 조금만 변해도 곡선의 가파른 부분 때문에 추렭이 확 달라진다.

15. 이는 마치 한 손가락에서 다른 손가락으로 건너뛰는 것과 같다.

16. 이 때 판정 기준을 문턱값(threshold)이라고 부른다.

17. 출력값이 문턱값의 한쪽에서 반대쪽으로 옮겨가고 중간 정도의 출력값이 나오기는 어렵기 때문에 이런 왜곡이 유용하다.

18. 이 현상은 연속적인 공간을 이산적인 영역으로 나눠준다. 이로부터 우리는 안전성과 잡음 내성을 얻을 수 있다.

19. 아날로그는 가능한 한 선형 영역을 크게 만들기 위해 노력하는 것이고 디지털은 직선부를 가능하면 작게 만드는 것이라고 생각할 수 있다.

20. 10진 숫자 대신 비트를 사용하는 이유?

21. 10진 문턱값과 2진 문턱값을 비교했을 때의 전이 함수 차이때문이라고 생각?

14. 전기는 수도 배관과 유사하다.

15. 전기는 눈에 보이지 않아서 시각화하기 어렵다.

16. 전기를 물이라고 생각해보자

17. 물탱크 = 배터리

18. 물탱크가 텅 비변 물을 채워 넣어야 하는 것처럼 배터리 에너지가 고갈되면 충전을 해야 한다.

19. 태양에서 온 에너지가 물을 기화시켜 수증기로 만들고, 수증기는 다시 물이 되어 물탱크를 채운다.

20. 물이 파이프를 흘러서 전달되는 데 시간이 걸리는 것처럼, 전기가 컴퓨터 칩 내부에서 전파되는데도 시간이 걸린다.

21. 샤워기 물 온도를 변화시키기 위해 손잡이를 돌리고 원하는 대로 온도가 변할 때까지 시간이 약간 걸리는 것으로부터 이를 경험한 독자도 있을 것이다.

22. 이런 효과를 전파 지연이라고 부른다.

23. 물의 경우 온도 변화가 파이프를 확장시키거나 수축시키기 때문에 물의 흐름이 달라지며 그에따라 지연 시간도 차이가 난다.

24. 물이 파이프를 흘러가는 것처럼 전기도 선을 통해 이동한다.

25. 전기 선은 두 부분으로 구성된다.

26. 내부에 있는 금속을 도체라고 부르고, 금속 바깥쪽을 둘러싼 부분을 부도체라고 부른다.

27. 물 배관을 예로 들자면 도체는 파이프 내부, 부도체는 파이프 자체라고 할 수 있다.

28. 물의 흐름을 제어할 수 있는 것처럼, 전기의 흐름을 제어할 수 있는 밸브를 스위치라고 부른다.
29. 물이 배관 파이프 속을 능동적으로 흘러 다니지는 않는다.
30. 물은 압력에 의해 밀려서 움직인다.
31. 압력의 세기는 달라질 수 있다.
32. 전기에서 수압에 해당하는 존재는 전압이며, 측정 단위는 볼트다.
33. 전기 흐름의 양은 전류라고 부르고, 측정 단위는 암페어다.
34. 물은 굵은 관이나 가는 관을 통해 흐를 수 있다.
35. 하지만 관이 더 가늘수록 관을 통해 흐를 수 있는 물의 양을 제한하는 저항이 더 커진다.
36. 전압(수압)이 높더라도 너무 가는 도체(관)를 사용함으로 인해 저항이 아주 크면 전류(물의 흐름)가 커지지 못한다.

37. 물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출이라는 현상을 기반으로 진공관을 만들다.
38. 진공관 안에는 야구 투수 같은 역할을 하는 캐소드와 캐소드를 가열하는 히터가 있다.
39. 캐소드에서 발생한 전자(야구공)는 진공 속에서 애노드(포수 같은 역할을 함)로 날아간다.
40. 캐소드는 항상 전자가 흘러나오는 장소이고, 애노드는 항상 전자가 흘러 들어가는 장소다.
41. 캐소드를 음극, 애노드를 양극이라고 번역하기도 한다.
42. 그러나 음극과 양극이 상황에 따라 달라질 수 있기 때문에 캐소드와 애노드로 쓰는 게 성질을 더 명확히 표현해준다.
43. 보통 전기를 소비하는 경우에는 캐소드가 음극, 전기를 생상하는 경우에는 캐소드가 양극이 된다.
44. 진공관에 추가로 '타자' 역할을 하는 요소를 더할 수 있는데 이를 그리드라고 한다.
45. 그리드는 캐소드에서 나오는 전자를 쫓아내서 애노드에 도착하지 못하게 만든다.
46. 세 요소(캐소드, 그리드, 애노드)가 들어 있는 진공관을 삼극관이라고 부른다.

47. 최근에는 트랜지스터가 왕이다.
48. 전송 저항이라는 말을 줄인 트랜지스터는 진공관과 비슷하지만 반도체라는 특별한 물질을 사용한다.
49. 반도체는 도체와 부도체 사이를 오갈 수 있는 물질이다.
50. 트랜지스터를 아주 작게 만들 수 있으며 이는 좋은 일이지만, 도체가 가늘고 얇아지면 저항이 더 늘어나기 때문에 열이 발생한다.
51. 반도체는 쉽게 녹을 수 있기 때문에, 트랜지스터에서 열을 제거하는 일은 아주 중요한 문제다.
52. 알아둬야 할 중요한 내용은 트랜지스터가 반도체 물질로 이뤄진 기판 또는 슬랩 위에 만들어진다는 점이다.
53. 보통은 실리콘이 기판 재료로 쓰인다.
54. 트랜지스터에는 여러 가지 유형이 있지만, 가장 중요한 두 가지 유형은 쌍극 접합 트랜지스터(BJT, Bipolar Junction Transistor)와 필드 효과 트랜지스터(FET, Field Effect Transistor)다.
55. 트랜지스터를 밸브나 스위치로 생각할 수 있따. 게이트나 베이스는 스위치 손잡이이며, 이 손잡이가 올라가면 전기가 위에서 아래로 흐른다.
56. 이는 릴레이의 코일이 접점을 움직이는 것과 비슷하다.
57. 하지만 지금까지 살펴본 밸브나 스위치와 달리, 쌍극 접합 트랜지스터에서는 전기가 한 방향으로만 흐를 수 있다.

# 메모리와 디스크의 핵심: 순차 논리

1. 순차 논리라는 말은 순서라는 말에서 비롯된 용어다. 
2. 순서는 '시간적으로 어떤 값 뒤에 오는 다른 값'이라는 뜻이다.
3. 비트를 하나 기억할 때 플립플롭이 유용하다는 사실을 봤고, 레지스터를 사용하면 쉽게 여러 비트를 저장할 수 있다는 사실도 배웠다.
3. 하지만 훨씬 더 많은 정보를 저장해야 한다면 어떻게 해야 할까? 예를 들어, 여러가지 덧셈 결과를 저장해야 한다면 어떻게 할까?
5. 그렇다. 레지스터를 많이 쌓아두는 것부터 시작할 수 있다. 하지만 새로운 문제가 생긴다.
6. 어떤 레지스터를 사용해야 하는지 어떻게 지정할 수 있을까?
7. 각 레지스터에 번호를 부여하는 것이다.
8. 레지스터와 디코더를 기본 요소로 사용하면 이런 처리가 가능하며, 이 번호를 주소라고 한다.
9. 디코더의 출력을 레지스터의 입력을 활성화하기 위해 사용한다.
10. 다음으로는 지정한 주소에 해당하는 레지스터의 출력을 선택할 방법이 필요하다.
11. 다행히 우리는 실렉터를 만드는 방법을 배웠고, 실렉터는 우리 필요에 딱 들어 맞는다.
12. 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있다.
13. 이런 경우 트라이스테이트 출력이라는 또 다른 기본요소가 필요하다.
14. 그림에서 주소와 데이터에는 개별 신호 대신 큰 화살표를 사용한 것을 볼 수 있다.
15. 이런 식으로 연관된 신호를 버스라고 부른다.
16. 따라서 메모리 칩에는 주소 버스와 데이터 버스가 있다.
17. 버스는 비트를 이동시키는 대량 교통 수단이다.
18. 우리가 지금까지 살펴본 메모리를 임의 접근 메모리(random access memory, RAM), 즉 램이라고 부른다.
19. 램을 사용하면 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다.
20. 정적RAM, 즉 SRAM은 비싸지만 아주 빠르다.
21. 동적RAM, 즉DRAM은 커패시터라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다.
22. SRAM이나 DRAM은 모두 휘발성 메모리다. 휘발성이라는 말은 전원이 끊어지면 데이터가 사라진다는 뜻이다.
23. 코어 메모리는 오래된 비휘발성 RAM으로 비트를 토러스 모양의 쇳조각에 저장한다.
24. 읽기 전용 메모리(Read-Only Memory, ROM), 즉 ROM이라는 이름은 그리 정확한 이름이 아니다.
25. 한 번만 쓸 수 있는 메모리(Write-Once Memory)라고 불러야 할 것이다.
26. 메모리를 읽거나 쓰려면 시간이 걸린다.
27. 대량 저장장치로 알려진 디스크 드라이브는 엄청나게 많은 데이터를 저장하기 아주 좋은 장치다.
28. 디스크 드라이브는 중화요리집 식탁 중간에 있는 회전판과 비슷한 자화된 판에 비트를 저장한다.
29. 중국집에서는 여러분이 식탁 회전판을 돌리면서 원하는 요리가 여러분 앞에 오면 손을 사용해 음식을 앞접시에 옮겨 담는다.
30. 디스크 드라이브에서는 디스크 헤드가 여러분의 손 역할을 한다.
31. 디스크 드라이브는 다른 유형의 메모리에 비해 상대적으로 느리다.
32. 방금 헤드를 지나간 데이터가 필요한 경우 그 데이터를 읽을 수 있으려면 회전판이 거의 1바퀴 돌 때까지 기다려야 한다.
33. 최근의 디스크들은 1분에 7,200번 회전한다(7,200 RPM) 이말은 한 바퀴 도는데 8밀리초보다 약간 더 시간이 걸린다는 뜻이다.
34. 디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다.
35. 블록은 역사적으로 섹터라고 불려왓고, 디스크에서 읽고 쓰기가 가능한 가장 작은 단위다.
36. 디스크는 역사적으로 섹터당 512바이트를 저장했으나 최근에는 4,096 바이트를 저장한다.
37. 이 말은 디스크에서 한 바이트만 바꾸고 싶으면 전체 블록을 읽고 원하는 바이트를 바꾼 다음 전체 블록을 다시 써야 한다는 뜻이다.
38. 하드 디스크에는 레이아웃이 이뤄진 원판이 하나 이상 회전축에 연결되어 돌아간다.
39. 모든 섹터에 같은 수의 비트가 들어 있기 때문에 bit/nm^2으로 표현하는 비트 밀도는 각 원판의 바깥쪽보다 안쪽이 더 높다. P158
40. 현대적인 디스크는 방사상으로 움직이는 액추에이터 암에 달린 헤드가 있는데, 디스크는 헤드의 위치에 따라 트랙으로 나뉜다.
41. 탐색 시간(seek time)은 헤드를 한 트랙에서 다른 트랙으로 옮길 때 걸리는 시간이다.
42. 탐색 시간에 더해서, 원하는 데이터가 헤드 아래로 올 때까지 디스크가 돌아야 하는데 이때 걸리는 시간을 회전 지연 시간이라고 부른다.
43. 디스크 드라이브를 종종 하드 드라이브라고 부른다.
44. 플래시 메모리는 가장 최근 나타난 EEPROM 유형의 매체다.
45. 음악 플레이어나 디지털 카메라 등의 응용에는 플래시 메모리가 적합하다.
46. 플래시 메모리는 DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동한다.
47. 하지만 플래시 메모리의 버킷은 DRAM보다 더 크고 잘 만들어져 있어서 전자가 새지 않는다.
48. 플래시 메모리는 EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있다.
49. 플래시 메모리는 RAM처럼 원하는 위치를 마음대로 읽을 수 있따.
50. 모든 메모미를 다 지우는 것은 낭비가 심하므로 플래시 메모리 내부는 블록으로 나눠서, 블록 단위로 지우고 값을 쓸 수 있다.
51. 따라서 플래시 메모리는 읽을 때는 임의 접근(Random Access) 장치이고 쓸 때는 블록 접근(Block Access)장치다.
52. 디스크 드라이브는 점차 SSD로 알려진 고체 상태 드라이브(Solid-state Drive)로 교체되고 있다.
53. SSD는 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다.

# 컴퓨터 내부 구조

1. 전자 부품을 다양하게 조합해 비트를 좆가하는 회로를 만들 수 있는데, 이런 회로를 컴퓨터라고 부른다.
2. 현대적 컴퓨터는 크게 메모리(기억 장치), 입력과 출력(I/O), CPU(Central Processing unit, 중앙 처리 장치)라는 세 가지 부분으로 나눌 수 있따.
3. 컴퓨터에 정보를 전달하거나 컴퓨터에서 정보를 가져올 방법이 필요하다.
4. 이런 방법을 입력(input) / 출력(output)을 줄여서 I/O라고 부른다.
5. I/O에 연결되는 장치를 I/O 장치라고 부른다.
6. 이들은 컴퓨터의 주변부에 위치하기 때문에 주변장치라고 부르며, 영어로는 퍼리퍼럴이라고 한다.
7. 중앙 처리 장치(CPU, Central Processing Unit)는 실제 계산을 처리하는 컴퓨터 부품이다.
8. 우리가 사용하는 비유에서 CPU는 도심에 해당한다. 다른 모든 요소는 CPU를 지원하는 역할을 한다.
9. 산술 논리 장치(ALU, Arithmetic Logic Unit)는 CPU의 핵심 부품이다.
10. ALU는 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치다. P172
11. 컴퓨터의 실행 장치는 제어 장치라고도 알려져 있으며, 컴퓨터의 대장 역할을 한다.
12. 결국 ALU 그 자체로는 그리 유용하지 않다.
13. 누군가는 ALU에게 할 일을 알려줘야 한다.
14. 실행 장치는 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.
15. 우리는 실행 장치에게 명령어 목록을 제공한다.
16. 실행 장치는 어디에서 이런 명령어를 찾을 수 있을까?
17. 메모리에서 찾을 수 있다.
18. 여기서 설명하는 방식으로 실행되는 컴퓨터를 프로그램 저장 방식 컴퓨터(stored-program computer)라고 부른다.
19. 이제 비트를 살펴보고 해석하는 방법이 하나 더 생겼다.
20. 명령어는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다.
21. 명령어의 비트 패턴은 CPU마다 고유한 설계에 속한다.
22. 실행 장치는 메모리에서 명령어를 가져와야 하는 위치를 어떻게 알 수 있을까?
23. 프로그램 카운터를 사용한다(Program Counter, PC)
24. PC는 우편 배달부나 '현재 위치'를 알려주는 큰 화살표 같은 것이다.
25. 프로그램 카운터도 레지스터의 일종이며, 메모리와 별도의 특별한 곳에 위치한다.
26. 프로그램 카운터는 순수 레지스터 대신 카운터로 이뤄진다.
27. 카운터를 레지스터에 카운터 기능이 추가된 것으로 생각하면 된다.
28. 프로그램 카운터에는 메모리 주소가 들어 있다.
29. 즉, 프로그램 카운터는 메모리 위치를 가리킨다 (또는 참조한다)
30. 실행 장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다.
31. 프로그램 카운터의 값을 바꾸는 특별한 명령어가 있다.
32. 이런 명령어를 실행하는 경우가 아니라면 명령어를 수행한 뒤에는 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가된다.
33. CPU마다 정해진 초기 프로그램 카운터 값이 있으며, CPU 전원이 들어오면 PC는 이 값으로 설정된다.
34. 명령어와 누산기 P180 *
35. 주소 지정 모드 세 가지
36. 즉시 주소 지정, 직접 주소 지정, 간접 주소 지정
37. 최종 명령어 집합 구성 - 모드, 명령코드, 주소
38. 명령어는 두 단계로 이뤄진 상태 기계로 설명할 수 있다 (페치(fetch), 실행)
39. 처음에 컴퓨터가 해야 하는 일은 메모리에서 명령어를 가져오는 페치다.
40. 일단 명령어를 가져오고 나면 이 명령어를 어떻게 실행할지 고민해야 한다.
41. 명령어를 실행하려면 메모리에 접근해야 할 경우가 많다.
42. 이 말은 다른 목적으로 메모리를 사용할 때 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치가 필요하다는 뜻이다.
43. 그림에서는 CPU에 명령어 레지스터를 추가해서 현재 실행 중인 명령어를 저장한다.
44. 어떤 명령어든 처리하려면 페치를 해야 한다. 페치를 하려면 다음과 같은 신호가 필요하다
45. address source는 프로그램 카운터를 선택해야 한다.
46. 메모리를 동작시켜야 한다. 그리고 r/w는 읽기로 설정해야 한다.
47. 명령어 레지스터를 동작시켜야 한다.

# 컴퓨터 아키텍처와 운영체제

1. 컴퓨터 아키텍처라는 말은 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다.
2. 멀티태스킹은 여러 프로그램을 동시에 실행하는 기능이거나 최소한 겉으로 보기에는 여러 프로그램이 동시에 실행되는 것처럼 보이게 하는 기능을 뜻한다.
3. 여러 프로그램을 실행한다는 말은 프로그램들의 실행을 제어하기 위한 감독 프로그램인 운영체제(Operating System, OS)가 있어야 한다는 사실을 암시한다.
4. 가장 흔한 두 가지 컴퓨터 구조는 폰 노이만 구조와 하버드 구조다.
5. 두 구조 모두 CPU가 하나뿐이고 ALU, 레지스터, 실행 장치의 조합이다.
6. 1980년대에 처음 만들어진 멀티 프로세서 시스템은 단일 CPU보다 훨씬 더 좋은 성능을 얻어내기 위한 방법이다.
7. 예전에 CPU라고 부르던 것을 요즘은 프로세스 코어(Process Core)라고 부른다.
8. 이런 코어가 여럿 들어가는 멀티코어 프로세서가 이제는 일반적으로 쓰인다.
9. 여러 프로그램을 동시에 실행하려면 어떻게 해야 할까?
10. 우선 각 프로그램을 서로 전환시켜 줄 수 있는 일종의 관리자 프로그램이 필요하다.
11. 이런 프로그램을 운영체제 또는 운영체제 커널(kernel, 중심)이라고 부른다.
12. 우리는 OS와 OS가 관리하는 프로그램을 구분하기 위해 OS를 시스템 프로그램이라고 부르고
13. 다른 모든 프로그램을 사용자 프로그램이나 프로세스 프로그램이라고 부른다.
14. 간단한 운영체제
15. 사용자 프로그램을 메모리로 읽기 -> 상태 복원 -> 사용자 프로그램 실행 -> 타이머 인터럽트 -> 사용자 프로그램 중단 -> 상태 저장 -> 사용자 프로그램을 메모리로 읽기..
16. 이런 식으로 사용자 프로그램의 실행 시간을 조절하는 스케줄링 기법을 시분할이라고 부른다.
17. 시분할 방식에서는 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행한다.
18. 사용자 프로그램 상태 또는 문맥은 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다.
19. 이때 메모리에는 스택도 포함된다.
20. 이런 방법은 잘 작동하지만 아주 느리다.
21. 프로그램을 메모리로 불러들이려면 시간이 걸린다.
22. 프로그램을 메모리로 불러오되 그림 5-9처럼 각 프로그램에게 각기 다른 공간을 허용할 수 있으면 훨씬 더 빠르게 시분할 실행이 가능하다. P208
23. 통신 작업은 계속해서 백그라운드에서 실행(즉 사용자가 실행 중인 프로그램과 더불어 실행된다는 뜻이다)돼야 하기 때문에 멀티태스킹이 필수다.
23. 인덱스 레지스터와 상대 주소 지정이 멀티태스킹에 도움이 될 수 있지만, 이들만으로 충분하지는 않다.
24. 사용자 프로그램이 OS의 메모리를 덮어쓴다면 어떤 일이 벌어질까?
24. 각 프로그램을 분리해서 이런 시나리오가 아예 불가능하게 할 수 있으면 정말 좋다.
25. 이를 위해 오늘날 대부분의 마이크로프로세서에는 메모리 관리 장치(Memory Management Unit, MMU)가 들어있다.
26. MMU는 아주 복잡한 하드웨어다.
27. MMU가 들어있는 시스템은 가상 주소와 물리 주소를 구분한다.
28. 프로그램 -(가상 주소)> 메모리 관리 장치 -(물리 주소)> 메모리 
29. MMU는 가상 메모리 주소를 두 부분으로 나눈다. 주소의 하위 부분은 물리적 주소 범위와 같다.
30. 상위 부분은 페이지 테이블(page table)이라는 ram 영역을 통해 주소를 변환한다.
31. 운영체제OS는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리한다.
32. 예를 들어, OS가 CPU 자체에 대한 접근을 관리하는 방식을 그림 5-8에서 살펴봤다 P212
33. OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공한다.
34. 사용자 프로그램이 MMU의 설정을 마음대로 바꿀 수 있다면 MMU가 프로그램을 서로 격리시키지 못 할 것이다.
35. 여러 CPU는 이런 문제를 해결할 수 잇는 추가 하드웨어를 제공한다.
36. CPU에는 컴퓨터가 시스템 모드에 있는지 사용자 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어 있다.
37. I/O를 처리하는 명령어 등 일부 명령어는 특권(privileged) 명령어라서 오직 시스템 모드에서만 실행할 수 있다.
38. 트랩(trap)이나 시스템 콜(system call)이라고 부르는 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램(즉 운영체제)에게 요청을 보낼 수 있다.
39. 이 방식은 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호한다.
40. 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.
41. P216 ***
42. 컴퓨터는 빠르다. 컴퓨터는 1초에 수십억 개의 명령어를 실행할 수 있다.
43. 하지만 실행할 명령어가 도착하기를 CPU가 기다려야 하거나, 메모리에 데이터를 읽거나 쓸 때까지 CPU가 기다려야 한다면 그렇게 많은 일을 해낼 수 없다.
44. 프로세서에 레지스터라는 빠르고 비싼 메모리가 들어 있다는 사실을 살펴봤다.
45. 레지스터가 전체 메모리에서 차지하는 비율은 점점 작아져 왔다.
46. 프로세서는 보통 RAM으로 이뤄진 주 메모리(Main Memory)와 통신하는데, 주 메모리는 프로세서보다 1/10 정도밖에 속도가 나지 않는다.
47. 레지스터 = 냉장고 (물건 하나), 주 메모리 = 가게 (장바구니), 대용량 저장장치 = 창고 (트럭)
48. CPU가 주 메모리보다 10배 더 빠르게 작동한다고 하자.
49. 이를 해석하면 CPU가 메모리를 기다리느라 많은 시간을 소비해야 한다는 뜻이다.
50. 이를 해결하기 위해 집에 있는 식품저장고에 해당하는 캐시(cache)라는 하드웨어(아주 빠른 온칩 메모리)를 CPU에 추가한다.
51. 이 식품저장고는 가게보다 훨씬 작지만 훨씬 빠르고 프로세서와 같은 속도로 작동한다.
52. 캐시 실패는 CPU가 캐시에서 어떤 내용(어떤 주 메모리 주소에 들어 있는 내용)을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우를 뜻한다.
53. 비슷하게 캐시 적중은 CPU가 원하는 내용을 찾은 경우를 뜻한다.
54. 캐시 메모리에도 몇 가지 계층이 있다.
55. 모든 캐시가 같은 칩 안에 존재하는 경우에도 CPU에서 멀어질수록 캐시는 더 느려지고 더 커진다.
56. 이들을 L1, L2, L3 캐시라고 부른다.
57. 그리고 디스페처(dispatcher)가 들어있다. 디스패처는 여러 가지 크기의 장바구니, 박스, 트럭에 내용물을 채워넣거나 내용물을 꺼내는 일을 담당하는 아주 큰 논리회로다.
58. (빠르고 비쌈) CPU -> 레지스터 -> L1 캐시 -> L2 캐시 -> L3 캐시 -> 주 메모리 -> 대량 저장장치 (느리고 쌈)
59. 표 4-4 메모리에 명령어만 담는 게 아니라 데이터도 담는다는 사실을 알았다.
60. 이 경우 데이터는 정적(static) 데이터다. '정적'이라는 말은 프로그램을 작성할 때 얼마나 많은 메모리가 필요한지 알고 있다는 뜻이다.
61. 대부분의 프로그램은 동적(dynamic) 데이터를 다뤄야 한다.
62. 동적 데이터는 프로그램을 실행하기 전에는 크기를 알 수 없는 데이터를 말한다.
63. 예를 들어, 메시징 시스템은 저장해야 할 메시지 개수나 각 메시지의 크기를 미리 알 수 없다.
64. 그림 5-16처럼 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓이며, 이를 힙(heap)이라고 부른다.
65. 더 많은 데이터를 저장해야 할 경우 스택은 아래로 자라나는 반면, 힙은 위로 자라난다.

# 입출력과 네트워킹

1. 