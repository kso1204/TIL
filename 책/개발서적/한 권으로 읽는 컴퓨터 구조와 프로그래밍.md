# 한 권으로 읽는 컴퓨터 구조와 프로그래밍 

# 컴퓨터 보안

1. 데이터 암호화 표준 (Data Encryption Standard, DES)

2. DES를 대신하는 향상된 암호화 표준 (Advanced Encryption Standard, AES)

3. 어떤 내용을 다른 내용 속에 감추는 방식 - 스테가노그래피

4. 공개키 암호 시스템은 암호화와 복호화에 사용하는 키가 다르기 때문에 비대칭 시스템이다.

5. 비대칭 암호화는 계산 비용이 많이 든다.

6. 그로 인해 비밀리에 메시지 내용을 실제로 암호화할 때 사용할 대칭 세션 키를 만들기 위해 비대칭 암호화를 사용하는 경우도 자주 있다.

# 전자 회로의 조합 논리

1. 아날로그 세계에서 디지털 만들기

2. 수많은 엔지니어가 과학자들이 발견한 자연적으로 발생하는 전이 함수를 영리하게 응용하는 데 참여했다.

3. 카메라 센서나 필름의 전이 함수

4. x축은 들어오는 빛의 양(입력)을 뜻하며, y축은 (센서나 필름에) 기록되는 밝기나 센서가 기록하는 빛(출력)을 의미한다.

5. 곡선은 이 둘 사이의 관계를 보여준다.

6. 빛이 곡선의 상단부에 많이 닿으면 필름이나 센서에 기록되는 밝기 값이 서로 모이면서 최댓값에 가까워져서 이미지 노출이 과해진다.

7. 비슷한 방식으로 빛이 곡선의 하단부에 많이 닿으면 이미지 노출이 부족해진다.

8. 카메라의 경우, 목표는 노출을 조절해서 빛이 직선부에 많이 닿게 만드는 것이다.

9. 빛이 선형 영역에 닿게 하기 위해 카메라의 셔터 속도나 조리개를 조절하는 장치를 만들었다.

10. 여러분이 사용하는 이어폰이나 스피커를 구동하는 증폭 회로도 이런 트릭에 속한다.

11. 볼륨은 게인 또는 곡선이 가파른 정도를 조절한다. 

12. 게인이 높으면 곡선이 가팔라지고 출력도 커진다.

13. 게인이 11로 고정된 특별한 증폭기를 사용한다면? 이렇게 하면 출력이 더 이상 입력을 충실하게 재현하지 못하기 때문에 왜곡이 발생하며, 소리가 이상해진다.

14. 입력이 조금만 변해도 곡선의 가파른 부분 때문에 추렭이 확 달라진다.

15. 이는 마치 한 손가락에서 다른 손가락으로 건너뛰는 것과 같다.

16. 이 때 판정 기준을 문턱값(threshold)이라고 부른다.

17. 출력값이 문턱값의 한쪽에서 반대쪽으로 옮겨가고 중간 정도의 출력값이 나오기는 어렵기 때문에 이런 왜곡이 유용하다.

18. 이 현상은 연속적인 공간을 이산적인 영역으로 나눠준다. 이로부터 우리는 안전성과 잡음 내성을 얻을 수 있다.

19. 아날로그는 가능한 한 선형 영역을 크게 만들기 위해 노력하는 것이고 디지털은 직선부를 가능하면 작게 만드는 것이라고 생각할 수 있다.

20. 10진 숫자 대신 비트를 사용하는 이유?

21. 10진 문턱값과 2진 문턱값을 비교했을 때의 전이 함수 차이때문이라고 생각?

14. 전기는 수도 배관과 유사하다.

15. 전기는 눈에 보이지 않아서 시각화하기 어렵다.

16. 전기를 물이라고 생각해보자

17. 물탱크 = 배터리

18. 물탱크가 텅 비변 물을 채워 넣어야 하는 것처럼 배터리 에너지가 고갈되면 충전을 해야 한다.

19. 태양에서 온 에너지가 물을 기화시켜 수증기로 만들고, 수증기는 다시 물이 되어 물탱크를 채운다.

20. 물이 파이프를 흘러서 전달되는 데 시간이 걸리는 것처럼, 전기가 컴퓨터 칩 내부에서 전파되는데도 시간이 걸린다.

21. 샤워기 물 온도를 변화시키기 위해 손잡이를 돌리고 원하는 대로 온도가 변할 때까지 시간이 약간 걸리는 것으로부터 이를 경험한 독자도 있을 것이다.

22. 이런 효과를 전파 지연이라고 부른다.

23. 물의 경우 온도 변화가 파이프를 확장시키거나 수축시키기 때문에 물의 흐름이 달라지며 그에따라 지연 시간도 차이가 난다.

24. 물이 파이프를 흘러가는 것처럼 전기도 선을 통해 이동한다.

25. 전기 선은 두 부분으로 구성된다.

26. 내부에 있는 금속을 도체라고 부르고, 금속 바깥쪽을 둘러싼 부분을 부도체라고 부른다.

27. 물 배관을 예로 들자면 도체는 파이프 내부, 부도체는 파이프 자체라고 할 수 있다.

28. 물의 흐름을 제어할 수 있는 것처럼, 전기의 흐름을 제어할 수 있는 밸브를 스위치라고 부른다.
29. 물이 배관 파이프 속을 능동적으로 흘러 다니지는 않는다.
30. 물은 압력에 의해 밀려서 움직인다.
31. 압력의 세기는 달라질 수 있다.
32. 전기에서 수압에 해당하는 존재는 전압이며, 측정 단위는 볼트다.
33. 전기 흐름의 양은 전류라고 부르고, 측정 단위는 암페어다.
34. 물은 굵은 관이나 가는 관을 통해 흐를 수 있다.
35. 하지만 관이 더 가늘수록 관을 통해 흐를 수 있는 물의 양을 제한하는 저항이 더 커진다.
36. 전압(수압)이 높더라도 너무 가는 도체(관)를 사용함으로 인해 저항이 아주 크면 전류(물의 흐름)가 커지지 못한다.

37. 물체를 충분히 가열하면 전자가 튀어나오는 열전자 방출이라는 현상을 기반으로 진공관을 만들다.
38. 진공관 안에는 야구 투수 같은 역할을 하는 캐소드와 캐소드를 가열하는 히터가 있다.
39. 캐소드에서 발생한 전자(야구공)는 진공 속에서 애노드(포수 같은 역할을 함)로 날아간다.
40. 캐소드는 항상 전자가 흘러나오는 장소이고, 애노드는 항상 전자가 흘러 들어가는 장소다.
41. 캐소드를 음극, 애노드를 양극이라고 번역하기도 한다.
42. 그러나 음극과 양극이 상황에 따라 달라질 수 있기 때문에 캐소드와 애노드로 쓰는 게 성질을 더 명확히 표현해준다.
43. 보통 전기를 소비하는 경우에는 캐소드가 음극, 전기를 생상하는 경우에는 캐소드가 양극이 된다.
44. 진공관에 추가로 '타자' 역할을 하는 요소를 더할 수 있는데 이를 그리드라고 한다.
45. 그리드는 캐소드에서 나오는 전자를 쫓아내서 애노드에 도착하지 못하게 만든다.
46. 세 요소(캐소드, 그리드, 애노드)가 들어 있는 진공관을 삼극관이라고 부른다.

47. 최근에는 트랜지스터가 왕이다.
48. 전송 저항이라는 말을 줄인 트랜지스터는 진공관과 비슷하지만 반도체라는 특별한 물질을 사용한다.
49. 반도체는 도체와 부도체 사이를 오갈 수 있는 물질이다.
50. 트랜지스터를 아주 작게 만들 수 있으며 이는 좋은 일이지만, 도체가 가늘고 얇아지면 저항이 더 늘어나기 때문에 열이 발생한다.
51. 반도체는 쉽게 녹을 수 있기 때문에, 트랜지스터에서 열을 제거하는 일은 아주 중요한 문제다.
52. 알아둬야 할 중요한 내용은 트랜지스터가 반도체 물질로 이뤄진 기판 또는 슬랩 위에 만들어진다는 점이다.
53. 보통은 실리콘이 기판 재료로 쓰인다.
54. 트랜지스터에는 여러 가지 유형이 있지만, 가장 중요한 두 가지 유형은 쌍극 접합 트랜지스터(BJT, Bipolar Junction Transistor)와 필드 효과 트랜지스터(FET, Field Effect Transistor)다.
55. 트랜지스터를 밸브나 스위치로 생각할 수 있따. 게이트나 베이스는 스위치 손잡이이며, 이 손잡이가 올라가면 전기가 위에서 아래로 흐른다.
56. 이는 릴레이의 코일이 접점을 움직이는 것과 비슷하다.
57. 하지만 지금까지 살펴본 밸브나 스위치와 달리, 쌍극 접합 트랜지스터에서는 전기가 한 방향으로만 흐를 수 있다.

# 메모리와 디스크의 핵심: 순차 논리

1. 순차 논리라는 말은 순서라는 말에서 비롯된 용어다. 
2. 순서는 '시간적으로 어떤 값 뒤에 오는 다른 값'이라는 뜻이다.
3. 비트를 하나 기억할 때 플립플롭이 유용하다는 사실을 봤고, 레지스터를 사용하면 쉽게 여러 비트를 저장할 수 있다는 사실도 배웠다.
3. 하지만 훨씬 더 많은 정보를 저장해야 한다면 어떻게 해야 할까? 예를 들어, 여러가지 덧셈 결과를 저장해야 한다면 어떻게 할까?
5. 그렇다. 레지스터를 많이 쌓아두는 것부터 시작할 수 있다. 하지만 새로운 문제가 생긴다.
6. 어떤 레지스터를 사용해야 하는지 어떻게 지정할 수 있을까?
7. 각 레지스터에 번호를 부여하는 것이다.
8. 레지스터와 디코더를 기본 요소로 사용하면 이런 처리가 가능하며, 이 번호를 주소라고 한다.
9. 디코더의 출력을 레지스터의 입력을 활성화하기 위해 사용한다.
10. 다음으로는 지정한 주소에 해당하는 레지스터의 출력을 선택할 방법이 필요하다.
11. 다행히 우리는 실렉터를 만드는 방법을 배웠고, 실렉터는 우리 필요에 딱 들어 맞는다.
12. 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결해야 할 수도 있다.
13. 이런 경우 트라이스테이트 출력이라는 또 다른 기본요소가 필요하다.
14. 그림에서 주소와 데이터에는 개별 신호 대신 큰 화살표를 사용한 것을 볼 수 있다.
15. 이런 식으로 연관된 신호를 버스라고 부른다.
16. 따라서 메모리 칩에는 주소 버스와 데이터 버스가 있다.
17. 버스는 비트를 이동시키는 대량 교통 수단이다.
18. 우리가 지금까지 살펴본 메모리를 임의 접근 메모리(random access memory, RAM), 즉 램이라고 부른다.
19. 램을 사용하면 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있다.
20. 정적RAM, 즉 SRAM은 비싸지만 아주 빠르다.
21. 동적RAM, 즉DRAM은 커패시터라는 아주 작은 버킷에 전자를 담고, 트랜지스터를 1개만 사용해 뚜껑을 덮는다.
22. SRAM이나 DRAM은 모두 휘발성 메모리다. 휘발성이라는 말은 전원이 끊어지면 데이터가 사라진다는 뜻이다.
23. 코어 메모리는 오래된 비휘발성 RAM으로 비트를 토러스 모양의 쇳조각에 저장한다.
24. 읽기 전용 메모리(Read-Only Memory, ROM), 즉 ROM이라는 이름은 그리 정확한 이름이 아니다.
25. 한 번만 쓸 수 있는 메모리(Write-Once Memory)라고 불러야 할 것이다.
26. 메모리를 읽거나 쓰려면 시간이 걸린다.
27. 대량 저장장치로 알려진 디스크 드라이브는 엄청나게 많은 데이터를 저장하기 아주 좋은 장치다.
28. 디스크 드라이브는 중화요리집 식탁 중간에 있는 회전판과 비슷한 자화된 판에 비트를 저장한다.
29. 중국집에서는 여러분이 식탁 회전판을 돌리면서 원하는 요리가 여러분 앞에 오면 손을 사용해 음식을 앞접시에 옮겨 담는다.
30. 디스크 드라이브에서는 디스크 헤드가 여러분의 손 역할을 한다.
31. 디스크 드라이브는 다른 유형의 메모리에 비해 상대적으로 느리다.
32. 방금 헤드를 지나간 데이터가 필요한 경우 그 데이터를 읽을 수 있으려면 회전판이 거의 1바퀴 돌 때까지 기다려야 한다.
33. 최근의 디스크들은 1분에 7,200번 회전한다(7,200 RPM) 이말은 한 바퀴 도는데 8밀리초보다 약간 더 시간이 걸린다는 뜻이다.
34. 디스크는 바이트 단위로 주소를 지정해 읽는 대신 블록 단위로 주소를 지정해 읽는다.
35. 블록은 역사적으로 섹터라고 불려왓고, 디스크에서 읽고 쓰기가 가능한 가장 작은 단위다.
36. 디스크는 역사적으로 섹터당 512바이트를 저장했으나 최근에는 4,096 바이트를 저장한다.
37. 이 말은 디스크에서 한 바이트만 바꾸고 싶으면 전체 블록을 읽고 원하는 바이트를 바꾼 다음 전체 블록을 다시 써야 한다는 뜻이다.
38. 하드 디스크에는 레이아웃이 이뤄진 원판이 하나 이상 회전축에 연결되어 돌아간다.
39. 모든 섹터에 같은 수의 비트가 들어 있기 때문에 bit/nm^2으로 표현하는 비트 밀도는 각 원판의 바깥쪽보다 안쪽이 더 높다. P158
40. 현대적인 디스크는 방사상으로 움직이는 액추에이터 암에 달린 헤드가 있는데, 디스크는 헤드의 위치에 따라 트랙으로 나뉜다.
41. 탐색 시간(seek time)은 헤드를 한 트랙에서 다른 트랙으로 옮길 때 걸리는 시간이다.
42. 탐색 시간에 더해서, 원하는 데이터가 헤드 아래로 올 때까지 디스크가 돌아야 하는데 이때 걸리는 시간을 회전 지연 시간이라고 부른다.
43. 디스크 드라이브를 종종 하드 드라이브라고 부른다.
44. 플래시 메모리는 가장 최근 나타난 EEPROM 유형의 매체다.
45. 음악 플레이어나 디지털 카메라 등의 응용에는 플래시 메모리가 적합하다.
46. 플래시 메모리는 DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동한다.
47. 하지만 플래시 메모리의 버킷은 DRAM보다 더 크고 잘 만들어져 있어서 전자가 새지 않는다.
48. 플래시 메모리는 EEPROM보다 더 빨리 지울 수 있고 더 저렴하게 만들 수 있다.
49. 플래시 메모리는 RAM처럼 원하는 위치를 마음대로 읽을 수 있따.
50. 모든 메모미를 다 지우는 것은 낭비가 심하므로 플래시 메모리 내부는 블록으로 나눠서, 블록 단위로 지우고 값을 쓸 수 있다.
51. 따라서 플래시 메모리는 읽을 때는 임의 접근(Random Access) 장치이고 쓸 때는 블록 접근(Block Access)장치다.
52. 디스크 드라이브는 점차 SSD로 알려진 고체 상태 드라이브(Solid-state Drive)로 교체되고 있다.
53. SSD는 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리와 같다.

# 컴퓨터 내부 구조

1. 전자 부품을 다양하게 조합해 비트를 좆가하는 회로를 만들 수 있는데, 이런 회로를 컴퓨터라고 부른다.
2. 현대적 컴퓨터는 크게 메모리(기억 장치), 입력과 출력(I/O), CPU(Central Processing unit, 중앙 처리 장치)라는 세 가지 부분으로 나눌 수 있따.
3. 컴퓨터에 정보를 전달하거나 컴퓨터에서 정보를 가져올 방법이 필요하다.
4. 이런 방법을 입력(input) / 출력(output)을 줄여서 I/O라고 부른다.
5. I/O에 연결되는 장치를 I/O 장치라고 부른다.
6. 이들은 컴퓨터의 주변부에 위치하기 때문에 주변장치라고 부르며, 영어로는 퍼리퍼럴이라고 한다.
7. 중앙 처리 장치(CPU, Central Processing Unit)는 실제 계산을 처리하는 컴퓨터 부품이다.
8. 우리가 사용하는 비유에서 CPU는 도심에 해당한다. 다른 모든 요소는 CPU를 지원하는 역할을 한다.
9. 산술 논리 장치(ALU, Arithmetic Logic Unit)는 CPU의 핵심 부품이다.
10. ALU는 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치다. P172
11. 컴퓨터의 실행 장치는 제어 장치라고도 알려져 있으며, 컴퓨터의 대장 역할을 한다.
12. 결국 ALU 그 자체로는 그리 유용하지 않다.
13. 누군가는 ALU에게 할 일을 알려줘야 한다.
14. 실행 장치는 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.
15. 우리는 실행 장치에게 명령어 목록을 제공한다.
16. 실행 장치는 어디에서 이런 명령어를 찾을 수 있을까?
17. 메모리에서 찾을 수 있다.
18. 여기서 설명하는 방식으로 실행되는 컴퓨터를 프로그램 저장 방식 컴퓨터(stored-program computer)라고 부른다.
19. 이제 비트를 살펴보고 해석하는 방법이 하나 더 생겼다.
20. 명령어는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다.
21. 명령어의 비트 패턴은 CPU마다 고유한 설계에 속한다.
22. 실행 장치는 메모리에서 명령어를 가져와야 하는 위치를 어떻게 알 수 있을까?
23. 프로그램 카운터를 사용한다(Program Counter, PC)
24. PC는 우편 배달부나 '현재 위치'를 알려주는 큰 화살표 같은 것이다.
25. 프로그램 카운터도 레지스터의 일종이며, 메모리와 별도의 특별한 곳에 위치한다.
26. 프로그램 카운터는 순수 레지스터 대신 카운터로 이뤄진다.
27. 카운터를 레지스터에 카운터 기능이 추가된 것으로 생각하면 된다.
28. 프로그램 카운터에는 메모리 주소가 들어 있다.
29. 즉, 프로그램 카운터는 메모리 위치를 가리킨다 (또는 참조한다)
30. 실행 장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다.
31. 프로그램 카운터의 값을 바꾸는 특별한 명령어가 있다.
32. 이런 명령어를 실행하는 경우가 아니라면 명령어를 수행한 뒤에는 다음 명령어를 메모리의 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가된다.
33. CPU마다 정해진 초기 프로그램 카운터 값이 있으며, CPU 전원이 들어오면 PC는 이 값으로 설정된다.
34. 명령어와 누산기 P180 *
35. 주소 지정 모드 세 가지
36. 즉시 주소 지정, 직접 주소 지정, 간접 주소 지정
37. 최종 명령어 집합 구성 - 모드, 명령코드, 주소
38. 명령어는 두 단계로 이뤄진 상태 기계로 설명할 수 있다 (페치(fetch), 실행)
39. 처음에 컴퓨터가 해야 하는 일은 메모리에서 명령어를 가져오는 페치다.
40. 일단 명령어를 가져오고 나면 이 명령어를 어떻게 실행할지 고민해야 한다.
41. 명령어를 실행하려면 메모리에 접근해야 할 경우가 많다.
42. 이 말은 다른 목적으로 메모리를 사용할 때 페치한 명령어에 편하게 접근할 수 있도록 저장할 다른 위치가 필요하다는 뜻이다.
43. 그림에서는 CPU에 명령어 레지스터를 추가해서 현재 실행 중인 명령어를 저장한다.
44. 어떤 명령어든 처리하려면 페치를 해야 한다. 페치를 하려면 다음과 같은 신호가 필요하다
45. address source는 프로그램 카운터를 선택해야 한다.
46. 메모리를 동작시켜야 한다. 그리고 r/w는 읽기로 설정해야 한다.
47. 명령어 레지스터를 동작시켜야 한다.

# 컴퓨터 아키텍처와 운영체제

1. 컴퓨터 아키텍처라는 말은 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다.
2. 멀티태스킹은 여러 프로그램을 동시에 실행하는 기능이거나 최소한 겉으로 보기에는 여러 프로그램이 동시에 실행되는 것처럼 보이게 하는 기능을 뜻한다.
3. 여러 프로그램을 실행한다는 말은 프로그램들의 실행을 제어하기 위한 감독 프로그램인 운영체제(Operating System, OS)가 있어야 한다는 사실을 암시한다.
4. 가장 흔한 두 가지 컴퓨터 구조는 폰 노이만 구조와 하버드 구조다.
5. 두 구조 모두 CPU가 하나뿐이고 ALU, 레지스터, 실행 장치의 조합이다.
6. 1980년대에 처음 만들어진 멀티 프로세서 시스템은 단일 CPU보다 훨씬 더 좋은 성능을 얻어내기 위한 방법이다.
7. 예전에 CPU라고 부르던 것을 요즘은 프로세스 코어(Process Core)라고 부른다.
8. 이런 코어가 여럿 들어가는 멀티코어 프로세서가 이제는 일반적으로 쓰인다.
9. 여러 프로그램을 동시에 실행하려면 어떻게 해야 할까?
10. 우선 각 프로그램을 서로 전환시켜 줄 수 있는 일종의 관리자 프로그램이 필요하다.
11. 이런 프로그램을 운영체제 또는 운영체제 커널(kernel, 중심)이라고 부른다.
12. 우리는 OS와 OS가 관리하는 프로그램을 구분하기 위해 OS를 시스템 프로그램이라고 부르고
13. 다른 모든 프로그램을 사용자 프로그램이나 프로세스 프로그램이라고 부른다.
14. 간단한 운영체제
15. 사용자 프로그램을 메모리로 읽기 -> 상태 복원 -> 사용자 프로그램 실행 -> 타이머 인터럽트 -> 사용자 프로그램 중단 -> 상태 저장 -> 사용자 프로그램을 메모리로 읽기..
16. 이런 식으로 사용자 프로그램의 실행 시간을 조절하는 스케줄링 기법을 시분할이라고 부른다.
17. 시분할 방식에서는 시간을 정해진 간격으로 나누고, 정해진 시간 간격 동안 사용자 프로그램을 실행한다.
18. 사용자 프로그램 상태 또는 문맥은 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다.
19. 이때 메모리에는 스택도 포함된다.
20. 이런 방법은 잘 작동하지만 아주 느리다.
21. 프로그램을 메모리로 불러들이려면 시간이 걸린다.
22. 프로그램을 메모리로 불러오되 그림 5-9처럼 각 프로그램에게 각기 다른 공간을 허용할 수 있으면 훨씬 더 빠르게 시분할 실행이 가능하다. P208
23. 통신 작업은 계속해서 백그라운드에서 실행(즉 사용자가 실행 중인 프로그램과 더불어 실행된다는 뜻이다)돼야 하기 때문에 멀티태스킹이 필수다.
23. 인덱스 레지스터와 상대 주소 지정이 멀티태스킹에 도움이 될 수 있지만, 이들만으로 충분하지는 않다.
24. 사용자 프로그램이 OS의 메모리를 덮어쓴다면 어떤 일이 벌어질까?
24. 각 프로그램을 분리해서 이런 시나리오가 아예 불가능하게 할 수 있으면 정말 좋다.
25. 이를 위해 오늘날 대부분의 마이크로프로세서에는 메모리 관리 장치(Memory Management Unit, MMU)가 들어있다.
26. MMU는 아주 복잡한 하드웨어다.
27. MMU가 들어있는 시스템은 가상 주소와 물리 주소를 구분한다.
28. 프로그램 -(가상 주소)> 메모리 관리 장치 -(물리 주소)> 메모리 
29. MMU는 가상 메모리 주소를 두 부분으로 나눈다. 주소의 하위 부분은 물리적 주소 범위와 같다.
30. 상위 부분은 페이지 테이블(page table)이라는 ram 영역을 통해 주소를 변환한다.
31. 운영체제OS는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리한다.
32. 예를 들어, OS가 CPU 자체에 대한 접근을 관리하는 방식을 그림 5-8에서 살펴봤다 P212
33. OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공한다.
34. 사용자 프로그램이 MMU의 설정을 마음대로 바꿀 수 있다면 MMU가 프로그램을 서로 격리시키지 못 할 것이다.
35. 여러 CPU는 이런 문제를 해결할 수 잇는 추가 하드웨어를 제공한다.
36. CPU에는 컴퓨터가 시스템 모드에 있는지 사용자 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어 있다.
37. I/O를 처리하는 명령어 등 일부 명령어는 특권(privileged) 명령어라서 오직 시스템 모드에서만 실행할 수 있다.
38. 트랩(trap)이나 시스템 콜(system call)이라고 부르는 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램(즉 운영체제)에게 요청을 보낼 수 있다.
39. 이 방식은 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호한다.
40. 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.
41. P216 ***
42. 컴퓨터는 빠르다. 컴퓨터는 1초에 수십억 개의 명령어를 실행할 수 있다.
43. 하지만 실행할 명령어가 도착하기를 CPU가 기다려야 하거나, 메모리에 데이터를 읽거나 쓸 때까지 CPU가 기다려야 한다면 그렇게 많은 일을 해낼 수 없다.
44. 프로세서에 레지스터라는 빠르고 비싼 메모리가 들어 있다는 사실을 살펴봤다.
45. 레지스터가 전체 메모리에서 차지하는 비율은 점점 작아져 왔다.
46. 프로세서는 보통 RAM으로 이뤄진 주 메모리(Main Memory)와 통신하는데, 주 메모리는 프로세서보다 1/10 정도밖에 속도가 나지 않는다.
47. 레지스터 = 냉장고 (물건 하나), 주 메모리 = 가게 (장바구니), 대용량 저장장치 = 창고 (트럭)
48. CPU가 주 메모리보다 10배 더 빠르게 작동한다고 하자.
49. 이를 해석하면 CPU가 메모리를 기다리느라 많은 시간을 소비해야 한다는 뜻이다.
50. 이를 해결하기 위해 집에 있는 식품저장고에 해당하는 캐시(cache)라는 하드웨어(아주 빠른 온칩 메모리)를 CPU에 추가한다.
51. 이 식품저장고는 가게보다 훨씬 작지만 훨씬 빠르고 프로세서와 같은 속도로 작동한다.
52. 캐시 실패는 CPU가 캐시에서 어떤 내용(어떤 주 메모리 주소에 들어 있는 내용)을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우를 뜻한다.
53. 비슷하게 캐시 적중은 CPU가 원하는 내용을 찾은 경우를 뜻한다.
54. 캐시 메모리에도 몇 가지 계층이 있다.
55. 모든 캐시가 같은 칩 안에 존재하는 경우에도 CPU에서 멀어질수록 캐시는 더 느려지고 더 커진다.
56. 이들을 L1, L2, L3 캐시라고 부른다.
57. 그리고 디스페처(dispatcher)가 들어있다. 디스패처는 여러 가지 크기의 장바구니, 박스, 트럭에 내용물을 채워넣거나 내용물을 꺼내는 일을 담당하는 아주 큰 논리회로다.
58. (빠르고 비쌈) CPU -> 레지스터 -> L1 캐시 -> L2 캐시 -> L3 캐시 -> 주 메모리 -> 대량 저장장치 (느리고 쌈)
59. 표 4-4 메모리에 명령어만 담는 게 아니라 데이터도 담는다는 사실을 알았다.
60. 이 경우 데이터는 정적(static) 데이터다. '정적'이라는 말은 프로그램을 작성할 때 얼마나 많은 메모리가 필요한지 알고 있다는 뜻이다.
61. 대부분의 프로그램은 동적(dynamic) 데이터를 다뤄야 한다.
62. 동적 데이터는 프로그램을 실행하기 전에는 크기를 알 수 없는 데이터를 말한다.
63. 예를 들어, 메시징 시스템은 저장해야 할 메시지 개수나 각 메시지의 크기를 미리 알 수 없다.
64. 그림 5-16처럼 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓이며, 이를 힙(heap)이라고 부른다.
65. 더 많은 데이터를 저장해야 할 경우 스택은 아래로 자라나는 반면, 힙은 위로 자라난다.

# 입출력과 네트워킹

1. 프로그래밍 관점에서 I/O 장치와 상호작용하는 기술
2. 실제 세계의 아날로그 데이터를 컴퓨터가 쓸 수 있는 디지털 형태로 바꾸거나, 역방향으로 바꾸려면 샘플링을 해야 한다.
3. LED(light Emitting diode)는 발광 다이오드다.
4. 다이오드는 놀이동산 입구의 회전문 같은 역할을 하는 반도체 장치다.
5. 즉, 다이오드는 전기를 회로도에 표시된 속이 빈 화살표 방향으로만 흐르도록 제한한다.
6. LED는 다이오드 역할을 하면서 부수적으로 빛도 나는 장치다.
7. LED와 저항을 직렬로 연결했다는 점에 유의하라. 저항을 연결한 이유는 LED에 흐르는 전류를 제한해서 PB0와 LED가 타버리는 일이 없도록 방지하기 위함이다.
8. 포트 B는 그림6-2처럼 세 가지 레지스터에 의해 제어된다.
9. DDRB는 데이터 방향 레지스터다 (Data Direction Register B)
10. DDRB는 각 핀을 입력으로 쓸지 출력으로 쓸지 결정한다.
11. PORTB는 출력 데이터를 저장하는 장치다.
12. PINB는 핀의 값을 읽는다.
13. DDRB는 포트 B에 대한 데이터 방향 레지스터다.
14. 이 레지스터의 어느 비트에 1을 넣으면 그 비트 번호에 해당하는 포트 B 비트가 출력으로 쓰이게 된다.
15. 0을 넣으면 입력이다.
16. PORTB는 포트의 출력 부분이다. PORTB의 어느 비트에 0이나 1을 넣으면 핀의 출력 전압이 0이나 1로 바뀐다.
17. PINB를 읽으면 연관된 핀의 상태를 읽을 수 있다.

# 데이터 구조와 처리

1. C언어 기본 데이터 타입들 P276
2. 동적 메모리를 명시적으로 관리하면서 포인터를 잘못 쓰면 두 가지 문제가 생긴다.
3. 포인터는 단지 메모리 주소를 나타내는 숫자에 지나지 않는다는 사실을 기억하라.
4. 하지만 모든 숫자가 올바른 메모리 주소는 아니다.
5. 포인터를 사용해 존재하지 않는 메모리에 접근하거나 프로세서의 메모리 경계에 맞지 않는 주소에 접근하면 예외가 발생하면서 프로그램이 중단된다.
6. 자바나 자바스크립트 같은 언어에는 포인터가 없지만 직접 malloc이나 free를 하지 않으면서도 동적 메모리 할당을 지원한다.
7. 이런 언어는 malloc과 free 대신에 가비지 컬렉션(garbage collection)을 구현한다.
8. 자바 같은 언어는 포인터 대신 참조를 사용한다.
9. 참조(reference)는 포인터를 추상화해서 거의 비슷한 기능을 제공하지만 실제 메모리 주소를 노출하지는 않는다.
10. 가비지 컬렉션을 사용하는 언어에는 데이터 요소를 만들어내면서 이 요소가 사용할 메모리도 할당하는 new 연산자를 제공하는 경우가 자주 있다.
11. 디스크의 기본 단위는 블록이고 연속적인 블록을 클러스트라고 부른다고 언급했다.
12. 클러스트는 한 트랙 안에 있는 연속적인 섹터로 이뤄지므로, 데이터를 한 클러스트에만 저장할 수 있다면 좋을 것이다.
13. 메모리에 있는 정보는 일시적이고 데이터를 장기적으로 저장할 때는 디스크를 사용하므로, 데이터를 디스크에 저장하기 위해서는 영구적인 어떤 존재가 필요하다.
14. 바로 파일 이름이 그 답이다.
15. 이런 파일 이름을 디스크에 저장할 방법과 파일 이름과 파일의 데이터가 저장된 디스크 블록을 연결해줄 방법이 필요하다.
16. 블록 중 일부를 아이노드(inode)로 따로 지정한다.
17. 아이노드는 디스크 블록에 대한 인덱스(index)와 노드(node)를 합친 단어다.
18. 따라서 아이노드는 인덱스 노드다.
19. 아이노드에는 보통 직접 블록 포인터(실제로는 포인터가 아니라 블록의 인덱스?)가 12개 있다. 따라서 직접 블록을 통해서 최대, 4096*12 = 49,152바이트까지 데이터를 보관할 수 있다.
20. 파일이 더 커지면 간접 블록을 사용하기 시작한다.
21. 32비트 인덱스를 사용하면 한 블록에는 4바이트짜리 인덱스가 1,024개 있으므로 간접 블록을 통해서는 최대 4Mib까지 지원할 수 있다.
22. 객체에는 함수에 해당하는 메서드와 데이터에 해당하는 프로퍼티가 들어 있다.
23. 성능과 효율이 분리된 상황을 응용하는 방법으로 데이터베이스 샤딩이 있다.
24. 샤딩은 다른 말로 수평 파티셔닝이라고도 부른다. P318 
25. 인터페이스를 통해 요청이 들어온 데이터베이스 연산을 모든 샤드에 전달한다.
26. 그리고 컨트롤러가 결과를 하나로 모은다.
27. 이 기법을 사용하면 작업을 여러 작업자로 나눠 (동시에 병렬적으로) 수행할 수 있기 때문에 성능이 향상된다.
28. 샤딩의 변종으로 맵리듀스(MapReduce)가 있다. 맵리듀스는 근본적으로 컨트롤러가 중간 결과를 모으는 방법을 코드로 직접 작성할 수 있게 해준다.

# 프로그래밍 언어 처리

1. 초기 컴퓨터 프로그래머들은 프로그램을 작성하는 더 나은 방법을 고안해냈다. 이 방법이 바로 어셈블리 언어다.
2. 어셈블리 언어를 쓰면 프로그래머가 모든 비트 조합을 외우지 않고 이해하기 쉬운 니모닉(mnemonics)을 통해 명령어를 쓸 수 있다.
3. 어셈블리 언어에서는 주소에 이름, 즉 레이블(label)을 붙일 수 있다.
4. 그리고 코드에 주석(comment)을 달아서 다른 사람들이 프로그램을 더 쉽게 이해하도록 도와줄 수 있다.
5. 어셈블리 언어로 작성된 코드를 읽어서 동등한 기계어 코드(machine code)를 생성해주는 프로그램을 어셈블러(assembler)라고 부른다.
6. 이런 변환 과정에서 어셈블러는 레이블이나 심볼(symbol)의 값을 결정해 채워 넣어준다.
7. bss(block started by symbol)라는 의사명령어(pseudo-instruction)는 메모리 덩어리를 예약하되 메모리 안에는 아무 값도 넣지 않는다.
8. 첫 번째 어셈블러는 아주 원시적이었지만 제대로 작동하는 어셈블러가 생겼기 때문에 이 어셈블러에서 작동하는 어셈블리 언어를 사용해 더 나은 어셈블러를 어셈블리 언어로 작성할 수 있었고,
9. 개선된 의사명령어와 기능을 활용하는 어셈블리 언어로 더 많은 기능을 제공하는 어셈블러를 만들 수 있었으며, 이런 식의 개선을 계속할 수 있었다.
10. 부트스트랩(bootstrap)이라는 말이 그래서 생겨났다. 종종 이 말을 부트(boot)라고 줄여서 부르기도 한다.
11. 컴퓨터를 부팅하는 과정은 롬 등에 들어 있는 작은 프로그램을 메모리로 읽어오는 것부터 시작한다.
12. 이 프로그램은 필요한 초기화를 진행한 후 더 큰 프로그램을 (보통은 하드 디스크, USB 등 대용량 저장장치에서) 읽어오고, 이 프로그램은 더 큰 운영체제 등을 불러올 수 있다.
13. 초기 컴퓨터에서는 사람이 직접 전면 패널의 스위치를 사용해 최초 부트스트랩 프로그램을 입력해야만 했다.
14. 고수준 언어(high-level language)는 어셈블리 언어보다 더 높은 추상화 단계에서 작동한다.
15. 고수준 언어의 소스 코드는 컴파일러(compiler)라는 프로그램에 의해 실행된다.
16. 컴파일러는 소스 코드를 기계어로 번역, 즉 컴파일(compile)해준다.
17. 기계어를 다른 말로 목적 코드(object code)라고도 한다. 
18. 고수준 언어를 컴파일할 수도 있지만 인터프리트(interpret)할 수도 있다.
19. 인터프리트냐 컴파일이냐의 선택은 언어 설계 자체보다는 구현에 의해 이뤄진다.
20. 컴파일러는 소스 코드를 구체적인 기계에 맞는 기계어로 변환한다.
21. 같은 프로그램에 대해 다른 컴파일러를 사용하면 다른 대상 기계를 위한 프로그램을 만들어낼 수 있다.
22. 프로그램을 컴파일하고 나면 실행할 준비가 된 것이다.
23. 인터프리터 언어는 실제 기계(하드웨어로 된 '실제로 만져지는' 기계)에 사용할 기계어를 만들어 내지는 않는다.
24. 대신 인터프리터 언어는 가상 머신(virtual machine) or 가상 기계에서 실행된다.
25. 가상 머신은 소프트웨어로 작성된 기계다.
26. 가상 머신도 자신만 실행할 수 있는 기계어를 제공하기도 하지만, 이 기계어는 실제 하드웨어로 구현된 컴퓨터 명렁어 집합은 아니다.
27. 최근에는 '가상 머신'이라는 용어가 추상적인 계산 기계를 뜻할 수도 있다는 점에 유의하라.
28. 일부 인터프리터 언어는 인터프리터에 의해 직접 실행되기도 한다.
29. 또 어떤 인터프리터 언어들은 나중에 해석될 수 있도록 중간어(intermediate language)로 컴파일되기도 한다.
30. 일반적으로 컴파일이 된 코드는 기계어이기 때문에 더 빠르게 실행된다.
31. 이는 마치 영어 책을 우리말로 번역하는 것과 같다.
32. 번역이 끝나면 한글과 우리말을 아는 누구든 책을 읽을 수 있다.
33. 인터프리터에 의해 실행되는 코드는 마치 누군가가 영어로 된 책을 보면서 우리말로 즉시 번역해 읽어주는 것처럼 수명이 짧다.
34. 인터프리터 구조, 컴파일러 구조 P340


```

인터프리터

프론트엔드(어휘 분석, 문법 파싱) -> 파스 트리(중간 언어) -> 기계1 백엔드, 기계2 백엔드, 기계3 백엔드

컴파일러

프론트엔드(어휘 분석, 문법 파싱) -> 파스 트리(중간 언어) -> 기계1 코드 생성기 -> 기계1 어셈 블리어 -> 기계1 어셈블러 -> 기계1 기계어


```


# 웹 브라우저

1. 매일 보는 웹 브라우저는 그 자체가 가상 머신(virtual machine)이다.
2. 웹 브라우저는 아주 복잡한 명령어 집합을 완전히 소프트웨어로만 구현한 추상적인 컴퓨터다.
3. 다시 말해, 웹 브라우저는 인터프리터에 속한다.
4. 웹 브라우저의 입력 언어와 이 입력 언어를 어떻게 웹 브라우저가 실행하는지 배운다.
5. 브라우저를 배울 때 흥미로운 점은 브라우저가 크고 복잡한 애플리케이션인 동시에 소프트웨어로 구현된 프로그래밍할 수 있는 컴퓨터이기도 하다는 점이다.
6. 브라우저에는 개발자 콘솔(developer console)이 있다.
7. 웹 브라우저를 이해하면 시스템 설계에 대해서도 어느정도 이해할 수 있다.
8. 시스템 설계는 분명 프로그래밍보다 더 중요하다.
9. 브라우저 =(URL)> 서버  =(문서)> 브라우저 P350
10.  https://www.nostratch.com/catloag/general-computing 
11. https:<-- 스킴 
12. www.nostratch.com <- 호스트
13. catalong/general-computing <-경로
14. 스킴(scheme)은 통신 메커니즘을 표시한다.
15. 예를 들어, https는 안전한(암호화를 사용하는) 하이퍼 텍스트 전송 프로토콜을 뜻한다.
16. 통신하려는 서버가 호스트(host)다.
17. 호스트 숫자는 숫자로 된 인터넷 주소일 수도 있지만 보통은 도메인 이름을 사용한다.
18. 문서는 경로가 가리키는 위치에서 추출된다.
19. 스킴 중에는 file이 있다. file을 스킴으로 사용하면 URL의 호스트와 경로가 로컬 파일 경로로 된다.
20. 다시 말해 file 스킴을 사용하면 여러분 컴퓨터에 있는 파일을 가리킬 수 있다.
21. 웹 브라우저는 문서를 문서 객체 모델(DOM, Document Object Model)에 따라 처리한다.
22. 브라우저는 문서 트리로 깊이 우선 순회를 탐색하면서 트리를 해석한다?
23. 캐스케이딩 스타일 시트(CSS, Cascading Style Sheets), 즉 CSS는 HTML에서 스타일 정보를 분리해서 HTML을 한 번만 작성해도 대상 장치에 따라 여러 스타일을 적용할 수 있게 했다.
24. CSS가 실렉터(selector)라고 하는 정규식의 변형을 사용해 DOM의 엘리먼트 위치를 지정하므로 구성요소를 어떻게 구성하느냐가 중요하다.
25. CSS는 색, 글꼴 크기 등의 많은 프로퍼티(property)를 정의한다.
26. DOM 엘리먼트와 결합된 프로퍼티를 애트리뷰트라 부른다.
27. 자바스크립트를 사용하면 서버가 아니라 (브라우저가 실행 중인) 여러분의 컴퓨터에서 실행될 수 있는 실제 프로그램을 웹 페이지에 포함시킬 수 있다.
28. 이 프로그램은 DOM을 변경하고 직접 웹 서버와 통신할 수 있다. 그림 9-8 P364
29. DOM <=> 자바스크립트 프로그램 <=> 서버
30. 자바스크립트 프로그램과 서버의 상호작용은 그림 9-1에서 본 브라우저-서버 통신과 같지 않다.
31. 자바스크립트와 서버의 상호작용은 비동기 자바스크립트와 XML(Asynchronous JavaScript and XML), 즉 AJAX(에이잭스)를 통해 이뤄진다.
32. '비동기'는 브라우저가 서버의 응답이 언제 일어날지에 대해(그리고 응답이 돌아올지 돌아오지 않을지에 대해서도) 아무 제어를 하지 않는다는 뜻이다.
33. '자바스크립트'라는 말은 이 상호작용이 자바스크립트의 제어하에 이뤄진다는 뜻이다.
34. 마지막으로, 서버와 자바스크립트 프로그램 사이를 오가는 데이터 형식으로 처음에는 'XML'(HTML이 아님)을 사용했다.
35. JSON은 자바스크립트 객체 표기법(JavaScript Object Notation)을 줄인 말이다.
36. JSON은 근본적으로 자바스크립트 객체를 사람이 읽기 쉬운 방식으로 표현한 것이다.

```

P372

통신 인터페이스

언어 파서 (HTML, XML, XHTML, SVG, CSS, JavaScript)

자바스크립트 인터프리터 (JSON, XML)

문서 객체 모델 데이터 (DOM)

사용자 인터페이스 엔진 (키보드, 포인터, 그림, 오디오, 비디오)

```

# 애플리케이션 프로그래밍과 시스템 프로그래밍

1. 브라우저는 복잡한 애플리케이션 프로그램으로 아주 고차원의 '명령어'를 제공하는 '컴퓨터'를 구현한다고 설명했다.
2. 이번 장에서는 브라우저를 실행하는 프로그램을 작성한 다음에, 비슷한 프로그램을 브라우저를 사용하지 않고 작성한다. P374

```

애플리케이션 수준 프로그램 #1 <=> 브라우저(시스템 수준) <=> 운영체제 <=> I/O 장치

시스템 수준 프로그램 #2 <=> 운영체제 <=> I/O장치

```

3. 운영체제는 사용자 프로그램이 I/O 장치의 복잡도를 상당 부분 볼 수 없게 가려준다.
4. 비슷한 방식으로, 브라우저 같은 복잡한 사용자 프로그램은 그 프로그램 위에 만들어진 다른 애플리케이션 프로그램들이 운영체제를 다루는 복잡도를 볼 수 없게 가려준다.
5. C는 컴파일 언어이기 때문에 자바스크립트를 인터프리터로 실행했던 것처럼 그냥 소스 코드를 '실행'할 수는 없다.
6. 소스 코드를 먼저 기계어로 변환해야 한다.
7. 명령줄에서 쉽게 이런 변환을 할 수 있다.
8. 소스 파일의 이름이 gta.c라면, 그림 10-5에 있는 명령을 터미널에 타이핑해서 gta라는 기계어 파일을 생성할 수 있다. (이를 빌드한다고 부른다)
9. cc gta.c -o gta 
10. 터미널은(212페이지의 '시스템 공간과 사용자 공간'절에서 설명한 것처럼) I/O 장치이며, 사용자 프로그램은 직접 I/O장치와 통신하지 않는다.
11. 그림 10-6처럼 운영체제가 중간에서 통신을 중재한다. P386
12. 터미널 <=> 장치 드라이버 | 운영체제 <=(시스템 콜)> 사용자 프로그램
13. 장치 드라이버는 보기보다 복잡하다.
14. 복잡한 주된 이유는 운영체제가 한 번에 사용자 프로그램을 하나 이상 실행할 수 있기 때문이다.
15. 컴퓨터는 레지스터 집합이 하나뿐이므로 운영체제는 한 사용자 프로그램을 다른 사용자 프로그램으로 바꿀 때마다 레지스터들을 저장하고 복구해야 한다.
16. CPU 레지스터 외에도 저장하고 복구해야 할 내용이 많다.
17. 예를 들어, MMU 레지스터나 I/O 상태 등도 저장하고 복구해야 한다.
18. 이때 저장하고 복구해야 하는 모든 내용을 프로세스 문맥(process context)이라고 부르고, 그냥 문맥이라고도 한다.
19. 문맥의 크기가 커서 문맥 전환(context switching) 비용이 비싸기 때문에, 문맥 전환을 경솔히 자주 하고 싶지는 않다.
20. 시스템 콜이 이뤄지는 과정을 그림 10-7에 표시했다. P388
21. OS는 사용자 프로그램을 슬립시킨다.
22. 심지어 요청을 만족시킬 수 있는 경우에도 때로 다른 사용자 프로그램이 실행될 기회를 주기 위해 현재 실행 중인 사용자 프로그램을 슬립시킬 수도 있다.
23. 사용자가 키를 누를 때마다 문맥 전환이 일어나기를 바라지는 않는다.
24. 이런 경우 문맥 전환 횟수를 최소화하기 위해서는 사용자가 ENTER를 누를 때까지는 사용자가 무엇을 타이핑하든 상관없다는 점을 알아야 한다.
25. 사용자 프로그램은 시스템 콜을 사용해 터미널에서 입력을 '읽고'싶다는 의사를 표시한다.(키 입력이 없기 때문에) 대기하는 것 외에는 할 일이 없어서, 사용자 프로그램은 슬립 상태가 된다.
26. 그 결과 OS는 또 다른 프로그램을 실행하는 등의 다른 동작을 수행할 수 있다.
27. 물리적 장치와 관련된 처리를 담당하는 장치 드라이버(device driver)는 터미널에서 들어오는 문자를 버퍼(buffer)에 저장하고, 사용자가 키를 누를 때가 아니라 ENTER를 누를 때에만 사용자 프로그램을 '깨운다'
28. 소프트웨어 영역에서는 버퍼는 선입선출(FIFO) 데이터 구조다.
29. 사용자가 누른 키가 무엇인지 혼동할수도 있으므로 키 입력에 대한 버퍼를 사용하는 것만으로는 충분하지 않고, 사용자 입력을 즉시 화면에 표시하는 echo(메아리)가 필요하다.
30. 그리고 사용자 키 입력은 프로그램이 디스플레이에 보내느 출력보다 느리기 때문에 입력 버퍼(input buffer)외에도 출력 버퍼(output buffer)가 필요하다.
31. 출력 버퍼가 꽉 찼는데도 프로그램이 터미널에 출력을 시도하면 프로그램을 슬립 상태로 전환한다.
32. 표준 입출력(Standard Input/Output) 라이브러리(stdio)에는 사용자 프로그램이 쓸 수 있는 버퍼 I/O 함수가 들어있다.
33. 누군가를 가리킬 때는 그 대상의 모든 특성을 완전히 기술하는 것보다 이름을 사용해 가리키면 편하다.
34. 운영체제도 비슷한 접근 방식을 사용한다. open 시스템 콜은 파일 이름을 파일을 참조할 수 있는 핸들(handle)이나 파일 디스크립터(file discriptor)로 바꿔준다.
35. 이 핸들을 close 시스템 콜로 닫으면 더 이상 핸들을 사용할 수 없다.
36. 핸들은 마치 공연이나 박물관에 들어가면서 가방을 맡기고 받는 보관증과 비슷하다.

# 성능 향상을 위한 알고리즘 기법

1. 미사용 공간을 사용한 MIP 맵 기법

# 병렬성과 비동기성

1. 앞서 멀티태스킹 또는 컴퓨터가 한 번에 둘 이상의 작업을 수행하는 것에 대해 이야기했다.
2. 원래는 작업을 수행할 수 있는 컴퓨터(또는 CPU)가 하나뿐이어서 그냥 여러 작업을 동시에 수행할 수 있는 척만 했다.
3. 하지만 이제는 멀티코어 프로세서가 대세이고, 컴퓨터는 실제로 한 번에 둘 이상의 일을 하고 있다.
4. 운영체제는 프로세스(process)를 관리한다.
5. 프로세스는 사용자 공간(user space)에서 실행되는 프로그램이다.
6. 멀티코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있다.
7. 하지만 여러 프로그램이 병렬로 실행된다는 것만으로는 경합 조건(race condition)이 발생하지 않는다.
8. 병렬로 실행되는 프로그램이 자원을 공유해야 경합 조건이 발생할 수 있다.
9. 프로세서가 여러 가지 일에 신경을 써야 할 수도 있다.
10. 프린트 서버(print server)가 좋은 예다.
11. 프린트 서버는 프린터 문서 출력을 처리하는 동시에 다른 프로그램이 자신에게 통신하는 것도 신경을 써야 한다.
12. 핸들러를 인터럽트할 수 있게 만드는 것
13. 핸들러가 실행하는 중간에 잠시 실행을 중단하면서 상태를 저장하고, 나중에 그 위치로 돌아와 실행을 재개할 수 있다는 뜻이다.
14. 저장할 상태는 스택에 있다.
15. 문제는 프로세스마다 스택이 하나뿐이라는 점이다.
16. 이 경우에는 프로세스에 속한 모든 핸들러가 각각 따로 스택을 가져야 하는 것처럼 보인다.
17. 실행 스레드를 생각해보자.
18. 217페이지에서 운영체제가 프로세스 메모리를 어떻게 배치하는지 살펴봤다.
19. 스레드(thread)는 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분을 말한다.
20. 각 스레드는 자신이 cpu 레지스터를 완전히 소유한다고 가정한다.
21. 따라서 한 스레드에서 다른 스레드로 실행이 넘어갈 때는 스레드 스케줄러(thread scheduler)가 CPU 레지스터를 저장해야 한다.
22. 이는 마치 운영체제가 프로세스에서 다른 프로세스로 문맥을 전환할 때 일어나는 일과 비슷하다.
23. 스레드는 일반 프로세스보다 저장한 컨텍스트 크기가 훨씬 작기 때문에 프로세스 문맥 전환보다 스레드 문맥 전환이 더 빠르다.
24. 그래서 스레드를 다른 말로 경량 프로세스 (lightweight process)라고 부르기도 한다.
25. 우리가 처리해야 할 문제는 실제로는 공유 자원이 아니다.
26. 실제로 처리해야 할 문제는 여러 작은 연산으로 이뤄진 작업을 어떻게 원자적(atomic)으로 만들 수 있을까 하는 문제다('원자적'이라는 말은 나눌 수 없고 인터럽트할 수 없다는 뜻이다.)
27. 코드에서 중요한 부분을 상호 배제(mutual exclusion) 메커니즘을 통해 원자적으로 처리하게 만들어야 한다.
28. 이런 목표를 프로그램이 충돌을 피하기 위해 따르는 어드바이저리 락(advisory lock)을 만들어서 달성한다. P472
29. 성능을 향상할 가장 좋은 방법은 여러 연산을 한 트랜잭션(transaction)에 넣는 것이다.
30. 트랜잭션에 들어 있는 모든 연산은 모두 다 성공하거나 모두 다 실패한다.
31. 각 연산을 독립적으로 수행하는 대신(원자적으로 실행돼야하는 일련의 연산을) 한꺼번에 묶어서 처리한다.
32. 분명한 가이드라인은 어떤 대상을 잠그는 시간을 최소화하라는 것이다. 락이 걸려 있는 시간이 길면 동시성이 줄어들기 때문이다.
33. 교착 상태

```

교착 상태가 발생할 수 있는 상황은 공유 자원(shared resource)과 이 자원을 함께 사용하는 프로세스가 여럿 있는데 다음 네 가지 조건을 동시에 만족하는 경우에만 발생한다.

상호 배제(mutual exclusion) - 공유 자원을 함께 쓸 수 없어서 어느 한 프로세스가 독점적으로 사용해야만 한다. 

점유 대기(hold and wait) - 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청한다.

비선점(no preemption) - 프로세스가 할당받은 자원을 강제로 빼앗을 수 없다.

순환 대기 (circular wait) - 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구한다.

```

34. 자바스크립트는 단일 스레드로 돌아가는데, 어떻게 단일 스레드에서 동시성이 문제가 될 수 있을까?

35. 자바스크립트가 사용자 이벤트에 응답하는 짧은 프로그램을 실행하기 위해 만들어졌기 때문에,
36. 자바스크립트 구현은 이벤트 루프(event loop)모델을 사용한다.
37. 이벤트 루프 동작을 그림 12-8에서 볼 수 있다. P478
38. 여기서는 실행할 작업을 이벤트 큐(event queue)에 추가한다.
39. 자바스크립트는 이런 작업을 큐에서 한번에 하나씩 꺼내서 실행한다.
40. 자바스크립트는 단일 스레드 프로그램이기 때문에 이런 작업은 인터럽트할 수가 없다.
41. 하지만 프로그래머가 이벤트가 큐에 추가되는 순서를 제어할 수는 없다.
42. 두 개의 post 요청이 있을 때 도착 순서를 우리가 제어할 수는 없다.
43. 자바스크립트 인터프리터는 프로그래머에게 단일 스레드 모델을 제공하지만 내부에서는 멀티스레드를 활용하기 때문이다??
44. 자바스크립트에서 프로미스는 비동기 콜백 메커니즘을 언어 고유 기능으로 넣어서 라이브러리가 잘못 비동기 연산을 구현하지 못하게 한다.
45. 프로미스는 체이닝(chaining, 연쇄호출)이 가능하다.
46. 체이닝을 사용하면 something().then().then().then()... 스타일의 코드를 작성할 수 있다.
47. 프로미스를 사용하면 내포의 깊이를 줄일 수 있다.
48. 자바스크립트는 또 다른 '비동기' 프로그래밍을 작성하는 방법을 제공한다.
49. 이 방법은 프로미스를 기반으로 만들어졌지만 동기적인 코딩 스타일을 반영한다.
50. async와 await가 바로 이 방법이다.

# 세상을 바꾸는 기계 지능

1. 기계 지능은 머신러닝(Machine Learning, ML), 인공지능(Artificial Inteligence, AI), 빅 데이터(Big Data) 등의 연관 분야가 포함된 고급 주제다.
2. 잘 조직된 훈련 데이터(training data)를 프로그램에 넣고 프로그램에게 데이터의 의미를 말해주면 된다. 이를 머신러닝이라고 한다.
3. 여러 측면에서 머신러닝 시스템은 인간의 자율 신경계의 기능과 같다.
4. 인간의 두뇌는 실제로 호흡 등 수많은 저수준 처리를 능동적으로 수행하지는 않는다.
5. 두뇌는 저녁으로 뭘 먹ㅇ르 것인가 같은 더 고차원적인 기능을 위해 예약되어 있다.
6. 저수준 기능은 자동 신경계가 처리한다.
7. 근본적으로 복잡한 데이터를 더 단순한 어떤 것으로 변환하는 방법을 찾는 것이다.
8. 예를 들어, 누군가가 머신러닝 시스템을 훈련시켜서 고양이와 미트로프를 구별하게 만들었다고 하자.
9. 이 시스템은 아주 복잡한 이미지 데이터를 간단한 고양이와 미트로프 비트로 변환해준다. 이런 과정을 분류(classification)라고 한다.
10. 목표를 통해 배우는 경우 인간은 자신의 분류기를 더 세분화하는 것으로 끝내지 않고 새로운 프로그램을 만들어낸다.
11. 컴퓨터가 이런 일을 할 수 있을 때 이를 인공지능(AI)이라고 부른다.
12. AI 시스템은 스스로 프로그램을 작성하면서 목표를 달성한다.
13. 어떤 수준의 머신러닝을 사용하든 통계학을 만나게 될 확률이 아주 높다. 따라서 먼저 기본적인 통계 이론을 살펴보자
14. 베이즈의 베이스 정리 (Bayes' theorem)
15. 베이즈의 업적 중 중요한 부분은 나이브 베이즈 분류다(naive Bayes classifier)
16. 가우스
17. 종모양 곡선(bell curve)이라고도 하고 정규 분포(normal distribution)나 가우시안 분포(Guassian distribution)라고도 불리는 확률 분포
18. 종모양 곡선을 u를 중심으로 회전시켜서 3차원 버전을 만들면 그림 14-4와 같다.
19. 이 3차원 가우스 분포를 이미지로 끌어가서 u를 각 픽셀의 중심에 차례로 일치시킨다.
20. 곡면의 일부분이 중심 픽셀 주변의 픽셀을 덮는 것을 생각할 수 있다.
21. 이제 곡면 아래 있는 픽셀의 값과 곡면의 값을 곱한 결과를 모두 더해서 중심 픽셀의 값으로 만든다.
22. 이런 방식으로 이미지를 흐리게 만드는 방식을 가우시안 블러(gaussian blur)라고 부른다.
23. 픽셀과 픽셀 주변의 값을 서로 조합하는 과정이 약간 복잡해 보일 것이다.
24. 실제로 이 과정을 수학에서는 컨볼루션(convolution)이라고 부르며, 가중치 배열을 커널(kernel)이나 컨볼루션 커널(convolution kernel)이라고 부른다.
25. 이미지를 밝기 = f(x,y)라는 수학 함수의 결과로 생각할 수 있다. 이 함수의 값은 각 좌표 점상의 픽셀 밝기다. 이 함수는 이산적인 함수다.
26. 비슷한 방식으로 컨볼루션 커널을 값이 가중치 = g(x, y)라는 작은 이미지라고 생각할 수도 있다.
27. 인공지능에서 사용해온 접근 방법 중에는 이간의 행동을 흉내 내려는 노력이 있었다.
28. 인간의 경우 뉴런(neuron)이 큰 역할을 한다는 사실을 잘 알고 있었다.
29. 수상돌기(dendrite, 나무모양 돌기)는 입력이고, 축삭(axon, 중심을 따라 길게 뻗었다는 뜻)은 출력이며, 축삭 종말(axon terminal)은 단지 축삭과 다른 뉴런을 연결해주는 것에 지나지 않는다.
30. 각 수상돌기의 값을 어떤 가중치(weight)로 곱한 다음, 모든 가중치가 곱해진 값을 더한다.
31. 이 과정은 베이즈 분류와 비슷하다. 전체를 더한 값이 활동 전위(action potential)보다 낮으면 비교기의 출력이 false이고, 그렇지 않으면 비교기 출력이 true다.
32. 비교기 출력이 true이면 뉴런이 출력 플롭을 true로 설정해서 활성화(fire) 된다.
33. 최초의 인공뉴런을 만들려는 시도는 미국 심리학자인 프랭크 로젠블랏의 퍼셉트론(perceptron)이었다.

# 훌륭한 프로그래머가 되기 위한 팁과 경험담

1. 멀틱스(Multics) 운영체제는 큰 GE645 메인프레임(main frame) 컴퓨터에서 실행됐는데, 1960년대에 벨 전화 연구소와 제너럴 일렉트릭(GE), MIT가 협력해 개발한 것이었다.
2. 벨은 프로젝트에서 빠졌고, 멀틱스 프로젝트를 수행할 때 가졌던 파일 시스템에 대한 아이디어를 바탕으로 디지털 이퀍먼트사(DEC, Digital Equipment Corporation)에서 만든 더 작은 컴퓨터에서 실험했다.
3. 이들의 작업은 UNIX라는 혁신적인 새 운영체제를 낳았고, 유닉스는 소프트웨어에 있어 최소주의와 모듈화라는 철학을 구현했다.
4. UNIX는 첫 번째 이식 가능한(portable) 운영체제가 됐다.
5. 이식 가능하다는 말은 여러 종류의 컴퓨터에서 실행 가능하다는 말이다.
6. 이 책에서는 유닉스라는 용어를 리눅스, 프리BSD, 넷BSD, 오픈BSD, 최근의 맥OS 등의 유닉스 계열 시스템을 모두 포함하는 용어로 사용한다.
7. 리눅스 이전에도 몇몇 시도가 있었지만, 드디어 리눅스에서 패키지 관리가 활성화됐다.
8. 패키지 관리 도구는 프로그램을 의존관계 목록이 포함된 패키지로 묶게 해준다.
9. 이런 도구들은 대부분 잘 작동하지만 여러 프로그램이 동일한 의존관계에 대해 각기 다른 버전을 요구할 때는 문제가 발생하는 경향이 있다.
10. 컨테이너(container)는 패키지 관리 문제를 해결하는 방법으로 최근에 등장한 새로운 접근 방법이다.
11. 아이디어는 애플리케이션과 모든 의존관계를 컨테이너에 한꺼번에 담는 것이다.
12. 컨테이너는 이렇게 담긴 데이터 파일 등의 모든 내용물이 들어 있는 환경에서 프로그램을 실행해주되, 시스템의 나머지와는 격리된(isolated) 상태에서 실행해준다.
13. 컨테이너는 애플리케이션을 실행하기 위해 필요한 모든 의존관계(라이브러리나 프로그램)를 하나의 패키지로 묶을 수 있어서 소프트웨어 디플로이(deploy)를 단순화해준다.
14. 시스템이 어떤 컨테이너 유형을 지원하기만 하면, 시스템의 다른 부분에 영향을 끼치는 것을 걱정하지 않고 해당 컨테이너 유형으로 패키징된 애플리케이션을 설치해 실행할 수 있다는 뜻이다.
15. 이런 접근 방식의 다점은 실질적으로 컨테이너가 공유 라이브러리 사용을 없애버린다는 점이다. 이로 인해 메모리 활용도는 낮아질 수 있다.
16. 컨테이너화된 애플리케이션을 스냅이라고 부른다. 코어OS 리눅스는 이제 컨테이너 리눅스(container linux)라고 불리는데, 리눅스를 컨테이너에서 실행하기 위해 가볍게 만들려는 노력 중 하나다.
17. 자바의 새로운 아이디어 중 하나는 모든 대상 기계애 대해 코드를 재컴파일하는 대신, 대상 기계에서 실행될 자바 인터프리터(자바 가상머신이라고 불리는 바이트코드(Bytecode)라는 기계어를 실행하는 인터프리터다)만 
18. 누군가 재컴파일해두면 프로그래머가 자바 코드를 재컴파일할 필요는 없다는 것이었다.
19. 코드를 한 번만 작성하고 나면 어디서 이 코드를 실행할 수 있다.
20. 자바는 프로그래머 교육에 널리 쓰이면서 점점 중요해졌다.
21. 교육에 자바가 쓰인 이유 중 하나는 자바가 가비지 컬렉셔을 통해 메모리를 관리하기 때문에 초보자에게 복잡한 메모리 관리를 가르치지 않아도 되기 때문이었다.
23. 자바는 아름다운 클래스 계층을 유지하는 것에 대한 환상적인 강박관념이 있어서 때로는 어떤 목표를 달성하는 것보다 클래스 계층 유지에 더 우선순위를 두곤 한다.
22. 좋은 예로 자바 데이터베이스 도구인 하이버네이트(hibernate)
23. 하이버네이트는 두 가지 '목표'를 이루려고 시도한다.
24. 첫 번째는 자바 클래스와 하위 클래스로 데이터 은닉(data hiding), 즉 내부에서만 사용하는 변수를 외부에서 보지 못하게 제한하는 멋진 목표를 달성하려고 한다.
25. 하지만 데이터 은닉에도 불구하고 클래스 계층의 맨 밑바닥에 있는 클래스는 전체 데이터베이스에 접근할 수 있다.
26. 두 번재는 HQL(Hibernate Query Language, 하이버네이트 질의 언어)이라는 추상화를 일반적으로 SQL인 기반 데이터베이스에 API 위에 제공하는 것이다.
27. 이론적으로는 이렇게 하면 프로그래머가 데이터베이스 시스템 사이의 차이점에 신경 쓰지 않고도 데이터베이스 연산을 처리 할 수있다.
28. 노드제이에스
29. 이 책에서 본 것처럼 자바스크립트는 브라우저에서 사용하는 스크립팅 언어로 시작됐다.
30. 노드제이에스(node.js)는 자바스크립트가 브라우저 밖에서 실행되게 해주는 아주 최근에 나온 환경이다.
31. 노드의 주된 매력은 클라이언트와 서버 쪽 애플리케이션을 하나의 프로그래밍 언어로 작성할 수 있다는 점이다.
32. 몇 가지 이유로 필자는 노드를 서버에 사용하지 않는다.
33. 첫째로, 노드는 자신의 패키지 관리자를 만들었다. 이런 패키지 관리자는 모든 사람에게 필요하지만, 호환되지 않는 방법으로 이를 만들었기 때문에 시스템을 유지보수하기가 더 어려워졌다.
34. 둘째로, 의존성이 꼬인 노드 패키지가 수천 수백가지 있고 상당수는 심각한 작업에 적합하지 않다.
35. 클라우드 컴퓨팅
36. 클라우드 컴퓨팅은 네트워크를 통해 다른 누군가의 컴퓨터를 쓴다는 것이다.
37. 이런 개념은 전혀 새로운 개념이 아니다.
38. 1960년대 발명품인 시분할을 새롭게 포장한 버전일 뿐이다.
39. 클라우드 컴퓨팅을 더 흥미롭게 만드는 요소를 꼽자면 다음과 같다.

```

네트워크가 전 세계로 퍼졌고 속도가 극적으로 빨라졌다.

이로 인해 전자우편 같은 정보를 로컬 컴퓨터에 담아두지 않아도 되는 것은 물론, 오디오와 비디오 스트리밍 등의 기능이 가능해졌다.

믿을 수 없을 만큼 큰 컴퓨팅 파워와 저장소를 마음껏 제공할 수 있을 정도로 하드웨어 가격이 저렴해졌다.

이로 인해 문제 해결을 위해 과거에는 실용성이 없던 새로운 알고리즘이나 처리 방식을 사용할 수 있게 됐다.

```

40. 가상 머신
41. 과거에는 프로그램이 한 컴퓨터에서 하나만 실행됐다.
42. 운영체제는 시분할을 통해 여러 프로그램을 실행할 수 있게 해준다.
43. 하지만 사용자가 원하는 모든 애플리케이션이 모든 운영체제에서 실행될 수 있도록 준비되어 있지는 않다.
44. 특히 클로즈드 소스 시스템이 규범이 되면서 이런 현상을 더 심해졌다.
45. 많은 사용자는 다양한 운영체제를 실행하도록 컴퓨터를 많이 사용해 이런 문제를 해결하거나, 같은 컴퓨터를 리부팅하면서 다른 운영체제를 실행하는 방법으로 이를 해결했다.
46. 이제는 하드웨어가 충분히 빨라져서 전체 운영체제를 애플리케이션으로 간주해도 될 정도가 됐다.
47. 이로 인해 여러 운영체제를 시분할로 돌려도 실용적일 수 있게 됐다.
48. 이런 일을 하려면 하부의 물리적인 기계의 집합과 다른 명령어 집합을 해석해야 하는 경우도 생긴다.
49. 그리고 단지 새로운 명령어 집합을 실행할 수 있는 것만으로는 충분하지 않다.
50. 운영체제가 예상하는 하드웨어 환경도 따로 제공해줘야 한다.
51. 운영체제가 물리적 기계 하드웨어 위에서 바로 실행될 필요가 없으므로, 이런 (하드웨어 환경과 운영체제가 실행되기 위한 명령어 집합을 제공하는) 시스템을 가상 머신(Virtual Machine)이라고 부른다.
52. 가상머신은 특정 운영체제에 종속되는 것을 방지한다는 면 외에도 여러 가지 장점을 제공하다.
53. 프로그램, 그 중에서도 운영체제를 개발할 때 가상 머신은 도움이 된다.
54. 가상 머신은 클라우드 컴퓨팅 세계의 주류다. 클라우드상에서 공간을 빌리고 여러분이 원하는 운영체제를 조합해 실행할 수 있다.
55. 가상 머신을 운영하는 시스템을 하이퍼바이저(hypervisor)라고 부르기도 한다.
56. 이동식 장치
57. 클라우드 컴퓨팅과 마찬가지로 통신 기술과 하드웨어 가격 대 성능비의 발전으로 인해 컴퓨팅 파워와 기능을 제공하는 이동식(Portable) 장치 개발이 가능해졌다.
58. 최근의 휴대전화기는 몇십 년 전 온 세계의 컴퓨터의 능력을 합한 것보다 더 큰 컴퓨팅 파워를 제공한다.
59. 훌륭한 인터페이스를 설계하는 어렵다. 다음 몇 가지를 염두에 두고 API를 설계하라.

```

API는 자세한 내부 구현을 노출해서는 안 된다. 특정 구현에 API가 의존해서도 안 된다.

API는 응집도가 높아야 한다. 즉 좋은 추상화를 제공해야 한다는 뜻이다.

API는 확장 가능(extensible)해야 한다(미래의 새로운 필요에 맞춰 변화가 가능해야 한다.). 추상화를 잘해두면 이 경우 도움이 된다.

API는 최소화해야 한다. 이 말은 API가 같은 일을 처리하는 방법을 여러가지고 제공하지 말아야 한다는 뜻이다.

모듈화(Modularity)가 잘되어 있으면 좋다. API가 연관된 기능을 제공한다면 이들을 가능한 서로 독립적으로 만들어라.

모듈화를 잘해두면 좀 더 쉽게 프로젝트를 여러 조각으로 나눠서 동시에 각 부분에 대해 작업하게 할 수 있다.

기능은 합성 가능 (Composable)해야 한다. 이 말은 여러 기능을 유용하게 조합하기가 쉬워야 한다는 뜻이다.

예를 들어, 검색 결과를 정렬해 돌려주는 인터페이스가 있다면 검색과 정렬을 별도로 분리할 경우 각각을 독립적으로 쓸 수도 있고 조합해서 쓸 수도 있다.

```

60. 터미널과 셸
61. 모든 데스크톱 컴퓨터 시스템에는 터미널이 있다.
62. 기본적으로 터미널은 명령 해석기(command interpreter)를 실행한다.
63. 여러분에게는 명령 프롬프트(prompt)가 표시된다.
64. 여러분도 상상할 수 있는 것처럼, 프롬프트 다음에 명령을 입력하면 된다.
65. 유닉스 기반의 시스템(애플 맥OS나 리눅스, 프리BSD 등)은 명령 해석기로 셸(Shell)이 있다. 보통은 배시(bash)라는 셸을 사용한다.
66. 버전 관리 시스템 (RCS-Revision Control System, SCSS-Source Code Control System)는 한 컴퓨터 안에서만 잘 작동했고, 딕 그룬은 동시성 버전 제어 시스템(CVS, Concurrent Verision System)을 개발했다.
67. CVS는 RCS와 비슷한 기능을 네트워크로 접근할 수 있게 해주면서 최초로 파일 잠금 대신 병합(merge)을 사용한 시스템이다.