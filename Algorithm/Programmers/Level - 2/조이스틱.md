# 조이스틱

# 문제 설명

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.

ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

```

▲ - 다음 알파벳

▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)

◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)

▶ - 커서를 오른쪽으로 이동

예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.

- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.

- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.

- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.

따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.

```

# 제한 사항

```

name은 알파벳 대문자로만 이루어져 있습니다.

name의 길이는 1 이상 20 이하입니다.

입출력 예

name	return

"JEROEN"	56

"JAN"	23

```

# 해결 방안

1. dfs로 해결 한 칸 움직일때마다 distance를 증가시킨다 ? or cnt 증가?

2. 왼 위 아래 오른쪽으로 이동 할 때 어떻게 카운트를 증가시켜야할지 생각해야 한다.

# 풀이

- 좋은 풀이

```

public int solution(String name) {
        int answer = 0;

        int sum = 0;
        int maxACount = 0;
        int maxAStart = -1;
        int curACount = 0;
        int curAStart = -1;        

        for(int i = 0; i < name.length(); i ++)
        {
            if(name.charAt(i) == 'A')
            {
                if(curAStart == -1)
                {
                    curAStart = i;
                }
                curACount++;
            }
            else
            {
                if(maxACount < curACount)
                {
                    maxACount = curACount;
                    maxAStart = curAStart;
                }

                curAStart = -1;
                curACount = 0;
            }

            sum += Math.min(name.charAt(i) - 'A', 'Z' - name.charAt(i) + 1);
        }

        int minMoveCount = name.length() - 1;
        if(maxACount > 0)
        {   
            int right = name.length() - (maxAStart + maxACount);
            int left = maxAStart - 1;
            int rollmoveCount = 0;
            if(right > left)
            {
                rollmoveCount = left * 2 + right;
            }
            else
            {
                rollmoveCount = right * 2 + left;
            }           

            minMoveCount = Math.min(rollmoveCount, minMoveCount);

        }

        answer = sum + minMoveCount;

        return answer;
    }


    public int solution(String name) {
        int answer = 0;

        int len = name.length();

        //최대로 가질 수 있는 min값은 끝까지 가는것
        int min_move = len-1;

        for(int i=0; i<len; i++) {
            int asc = name.charAt(i);
            answer += asc <= 78 ? asc - 65 : 91 - asc;

            int next = i+1;

            while(next<len && name.charAt(next) == 'A')
                next++;

            min_move = Math.min(min_move, i+len-next + i);
        }

        answer += min_move;

        return answer;
    }


    public int solution(String name) {
        int sum = 0;
        for(int i = 0; i < name.length(); i++)
            sum += Math.min(name.charAt(i) - 'A', 'Z' - name.charAt(i) + 1);

        Matcher m = Pattern.compile("[A]+").matcher(name);

        int min = name.length() - 1;
        while(m.find())
            min = Math.min(min, (m.start() == 0 ? 0 : (m.start() - 1) * 2) + (name.length() - m.end()));

        return sum + min;
    }

```

- 나의 풀이

- 알파벳 이동

- 인덱스 이동

```

(index - 1 + name.length()) % name.length();
(index + 1 + name.length()) % name.length();

(char)('A' + (name.charAt(index)+1-'A')%26));
(char)('A' + (name.charAt(index)-1-'A')%26));

```



```

dfs 사용? 왔던데는 또 갈 필요 없으니까.. 라고 생각해도 오른쪽으로 갓다가 왼쪽으로 세번갓다가 아래로 가야하는 경우 

ABAAAAAZA

이동 했는데 해당 위치가 원하는 알파벳이 아니면 위 아래로 이동해서 더 적게 이동한 횟수를 카운트 하고

다시 이동해야 한다.

그니까 왼쪽 이동 오른쪽 이동 하다가 더 적게 cnt 나오는 곳이 정답?



class Solution {
    public int solution(String name) {
        int answer = 0;
        
        String a ="";
        
        for (int i =0; i<name.length();i++) {
            a+="A";
        }
         

        
        int index = 0;
        int updown = 0;
        int count=0;
        
        
        while(!a.equals(name) && count < 5){
            
            System.out.println(name);
            System.out.println(a);
            
            if(name.charAt(index) != a.charAt(index)) {
                int temp = Math.abs(a.charAt(index)-name.charAt(index));
                answer += Math.min(26-temp, temp);
            } else {
                int i = 1;
                int min = i;
                while(true) {
                    
                    int ltemp = (index + i + name.length()) % name.length();
                    int rtemp = (index - i + name.length()) % name.length();
                    
                    if(a.charAt(ltemp) != name.charAt(ltemp)){
                        break;
                    } else if ( a.charAt(rtemp) != name.charAt(rtemp)) {
                        break;
                    }
                               
                    i++;
                }
                
                answer += i;
                
                
            }
            
            count++;
            
        }
        
        
        return answer;
    }
}

```
