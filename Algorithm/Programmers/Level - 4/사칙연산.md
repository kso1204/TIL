# 사칙연산

# 문제 설명

1. 사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다.

2. 예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다.

3. ((1 - 5) - 3) = -7

4. (1 - (5 - 3)) = -1

5. 위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다.

6. 또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다.

7. (((1 - 3) + 5) - 8) = -5

8. ((1 - (3 + 5)) - 8) = -15

9. (1 - ((3 + 5) - 8)) = 1

10. (1 - (3 + (5 - 8))) = 1

11. ((1 - 3) + (5 - 8)) = -5

12. 위와 같이 서로 다른 연산 순서의 계산 결과는 [-15, -5, -5, 1, 1]이 되며, 이중 최댓값은 1입니다.

13. 문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 arr가 매개변수로 주어질 때,

14. 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요.

# 제한 사항

```

arr는 두 연산자 "+", "-" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다.

arr의 길이는 항상 홀수입니다.

arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다.

숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : "456")

배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다.

입출력 예

arr	result

["1", "-", "3", "+", "5", "-", "8"]	1

["5", "-", "3", "+", "1", "+", "2", "-", "4"]	3

입출력 예시

입출력 예 #1

위의 예시와 같이 (1-(3+(5-8))) = 1 입니다.

입출력 예 #2

(5-(3+((1+2)-4))) = 3 입니다.

```

# 해결 방안

1. 해당 연산자에 대한 계산 우선 순위를 정해야 하는 문제

2. 기호가 -, +, -라고 한다면 해당 기호에 대해 어떤쪽부터 먼저 시작할지 정하기

3. dfs로 풀면 이게 시간이 되려나..?

4. 각 기호에 대한 인덱스의 번호 + 순서의 번호..

5. 숫자 리스트와 기호 리스트를 만든다음에

6. 기호 리스트에 인덱스 번호를 저장해두고, 해당 인덱스 번호를 계산하면서 그 인덱스번호보다 큰 값 들은 -1시켜준다..?

7. 이런 로직을 돌면서 시간내로 계산할 수 있을까? 200!..?

# 풀이

- 좋은 풀이

1. https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EC%82%AC%EC%B9%99%EC%97%B0%EC%82%B0

- 나의 풀이

```

import java.util.*;

class Solution {
    public int solution(String arr[]) {
        int answer = -1;
        
        int n = arr.length/2+1;
        
        int[][] maxDp = new int[n][n];
        int[][] minDp = new int[n][n];
        
        for (int i=0; i<n; i++) {
            Arrays.fill(maxDp[i], Integer.MIN_VALUE);
            Arrays.fill(minDp[i], Integer.MAX_VALUE);
        }
        
        
        for (int i=0; i<n; i++) {
            maxDp[i][i] = Integer.valueOf(arr[i*2]);
            minDp[i][i] = Integer.valueOf(arr[i*2]);
        }
        
        for (int cnt=1; cnt<n; cnt++) {
            
            for (int i=0; i<n-cnt; i++) {
                
                int j = i + cnt;
                
                for (int k=i; k<j; k++) {
                    
                    if (arr[k*2+1].equals("+")) {
                        maxDp[i][j] = Math.max(maxDp[i][j], maxDp[i][k] + maxDp[k+1][j]);
                        minDp[i][j] = Math.min(minDp[i][j], minDp[i][k] + minDp[k+1][j]);
                    } else {
                        maxDp[i][j] = Math.max(maxDp[i][j], maxDp[i][k] - minDp[k+1][j]);
                        minDp[i][j] = Math.min(minDp[i][j], minDp[i][k] - maxDp[k+1][j]);
                    }
                    
                }
                
            }
            
        }
        
        return maxDp[0][n-1];
    }
}



```