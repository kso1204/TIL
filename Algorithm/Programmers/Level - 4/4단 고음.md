# 4단 고음

# 문제 설명


1. U는 본인의 장기인 3단 고음으로 유명하다. 그러던 그녀가 어느 날 4단 고음을 성공했고 그녀의 고음은 학계에서 연구가 될 만큼 유명해졌다 [

2. 폭포 밑 득음 수련을 하던 어느 날, 그녀는 4단 고음이 끝이 아님을 깨달았다. 3단 고음 직후 3단 고음을 연이어하거나,

3. 3단 고음 중 다시 3단 고음을 해서 음높이를 올리는 방법이다.

4. 어떤 순서로 3단 고음을 했는지에 따라 최종 음높이가 달라지기 때문에, 연속 3단 고음을 연습할 때마다 그 결과를 기록으로 남기기로 했다.

5. 3단 고음은 다음과 같이 적용된다. 1단계에서는 음높이가 세 배가 되며,

6. 2단계와 3단계에서 음높이가 각각 1씩 증가한다.

7. 이를 기록으로 남길 때 * 와 + 기호를 사용하기로 했다. 즉, 3단 고음을 한 번 한 경우는 문자열로 나타내면 다음과 같다.

8. *++

9. 이때 3단 고음을 마치고 연달아 3단 고음을 한 경우는 *++*++ 와 같이 표현할 수 있다.

10. 3단 고음의 2단계를 마친 후 3단 고음을 새로 시작한 다음, 나머지 단계를 이어서 하는 경우는 *+*+++로 표현할 수 있다.

11. (강조된 부분이 2번째 3단 고음을 부른 부분이다.)

12. 이와 같이 * 와 + 로 구성된 문자열이 3단 고음의 규칙을 적용하여 만들 수 있는 문자열인 경우 '올바른 문자열'이라고 하자.

13. 다음의 문자열은 3단 고음의 규칙으로 만들 수 있는 문자열이 아니므로 올바른 문자열이 아니다.

14. +**+++

15. *+++*+

16. 올바른 문자열에 대해 음높이는 다음과 같이 계산할 수 있다.

17. 시작 음높이는 항상 1이며, 문자열의 처음부터 순서대로 * 기호의 경우 3을 곱하고 + 기호의 경우 1을 더한다.

18. *+*+++ 의 음높이를 계산하는 과정을 예로 들면 아래와 같다.

```
시작 음 높이: 1

*	+	*	+	+	+
*3	+1	*3	+1	+1	+1
최종 음높이: 15

그날 기분에 따라 최종 음높이를 정하는 IU는 최종 음높이를 결정했을 때 서로 다른 3단 고음 문자열이 몇 가지나 있는지 궁금하다. 여러분의 도움이 필요하다.

```

# 제한 사항

```

입력 형식

입력은 5 이상 2^31-1 이하의 정수 n으로 주어진다.

출력 형식

입력을 만족하는 서로 다른 문자열의 수를 리턴한다.

예제 입출력

n	answer

15	1

24	0

41	2

2147483647	1735

예제에 대한 설명

세 번째 예제의 두 가지 경우는 다음과 같다.

**++++*++
*+**+++++

```

# 해결 방안

1. 대충 이해한 것은.. * 하나에 ++가 두 개 붙을 수 있고

2. ++가 안 붙게 된다면 다음 *에 연달아 붙일 수 있다.

3. ***++++++

4. *++*++*++ 이런느낌..?

5. 별표가 세 개 일때 최소 값은 27 + 6에서

5. 최대 값은 ((3+2)*3)+2)*3+2 으로 53이다. 

6. 즉 33~81 만들 수 있음

7. 별표가 두 개 일때는?

8. **++++ 13에서

9. *++*++ 17까지

10. 

# 풀이

```

class Solution {
    
    int p = 41;
    public int solution(int n) {
        int answer = 0;
        
        //min = 27 + 6
        //max = (3+6)*3*3
        
        
        //dfs로 한다면 남은 별의 개수 *** 사용할 수 있는 +의 개수, 남은 +의 개수
        int sum = 0;
        
        dfs(3, 0, 0, sum);
        
        return answer;
    }
    
    void dfs(int star, int plus, int totalPlus, int sum)
    {
        if (sum == p) {
            answer++;
            return;
        } else if (sum>p) {
            return;
        }
        
        for (int i=0; i<)
    }
    
    
}

```