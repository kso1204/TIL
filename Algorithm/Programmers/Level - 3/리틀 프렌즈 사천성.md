# 리틀 프렌즈 사천성

# 문제 설명

1. 리틀 프렌즈 사천성은 프렌즈 사천성과 유사한 게임이다.

2. 게임은 2차원 배열에서 진행되는데, 여러 가지 무늬로 구성된 타일이 배치되어 있으며 같은 모양의 타일은 두 개씩 배치되어 있다.

3. 게임의 목적은 배치된 모든 타일을 제거하는 것으로, 같은 모양의 타일을 규칙에 따라 제거하면 된다.

4. 타일을 제거할 수 있는 경우는 다음과 같다.

5. 다음 조건을 만족하는 경로가 있을 때 두 타일을 제거할 수 있다.

```

경로의 양 끝은 제거하려는 두 타일이다.

경로는 두 개 이하의 수평/수직 선분으로 구성되어 있고, 이들은 모두 연결되어 있다. (즉, 경로를 한 번 이하로 꺾을 수 있다)

참고: 프렌즈 사천성은 경로가 세 개 이하의 선분으로 구성되어야 한다는 점이 다르다. (즉, 경로를 두 번 이하로 꺾을 수 있다)

경로 상에는 다른 타일 또는 장애물이 없어야 한다.

위의 배열에서 어피치 타일은 직선의 경로로 이을 수 있으므로 제거 가능하다. 

라이언 타일 역시 한 번 꺾인 경로로 연결되므로 제거 가능하다.

무지 타일의 경우 다른 타일을 지나지 않는 경로는 두 번 꺾여야 하므로 제거할 수 없는 타일이며, 튜브 타일 역시 직선의 경로 사이에 장애물이 있으므로 제거 가능하지 않다.

타일 배열이 주어졌을 때, 규칙에 따라 타일을 모두 제거할 수 있는지, 그 경우 어떤 순서로 타일을 제거하면 되는지 구하는 프로그램을 작성해보자.

```

# 제한 사항

```

입력은 게임판의 크기를 나타내는 m과 n, 그리고 배치된 타일의 정보를 담은 문자열 배열 board로 주어진다.

이 배열의 크기는 m이며, 각각의 원소는 n글자의 문자열로 구성되어 있다.

입력되는 값의 제한조건은 다음과 같다.

1 <= m, n <= 100

board의 원소는 아래 나열된 문자로 구성된 문자열이다.

각 문자의 의미는 다음과 같다.

.: 빈칸을 나타낸다.

*: 막힌 칸을 나타낸다.

알파벳 대문자(A-Z): 타일을 나타낸다.

이 문제에서, 같은 글자로 이루어진 타일은 한 테스트 케이스에 항상 두 개씩만 존재한다.

board에는 알파벳 대문자가 항상 존재한다. 즉, 타일이 없는 입력은 주어지지 않는다.

출력 형식

해가 존재하는 경우 타일을 제거하는 순서대로 한 글자씩 이루어진 문자열을, 그렇지 않은 경우 IMPOSSIBLE을 리턴한다.

해가 여러 가지인 경우, 알파벳 순으로 가장 먼저인 문자열을 리턴한다.

예제 입출력
m	n	board	answer
3	3	["DBA", "C*A", "CDB"]	"ABCD"
2	4	["NRYN", "ARYA"]	"RYAN"
4	4	[".ZI.", "M.**", "MZU.", ".IU."]	"MUZI"
2	2	["AB", "BA"]	"IMPOSSIBLE"

예제에 대한 설명

첫 번째 테스트 케이스에서 처음으로 제거 가능한 타일은 A와 C이다.

그리고 모든 가능한 경우를 나열하면 ABCD, ACBD, ACDB, CABD, CADB, CDAB이다.

이 중 알파벳 순으로 가장 먼저인 ABCD가 정답이다.

네 번째 테스트 케이스는 초기 상태에서 제거할 수 있는 타일이 없으므로 타일을 모두 제거하는 것이 불가능하다.

따라서 정답은 IMPOSSIBLE이다.

```

# 해결 방안

1. 어떤 타일부터 제거가 가능한지 찾기위한 dfs or 순열이 필요할지?

2. 현재 A라는 타일을 제거하려고 한다면 check(a)를 통해 짝을 지울 수 있는지 확인한다.

3. 타일에 있는 알파벳들을 다 모아서.. 해당 알파벳으로 문자열을 만들고, 이 문자열을 가지고 체크를 한다.

4. 해당 알파벳이 A, A일 경우 각 좌표를 구한다음에 1,3 3,1이라고 하면 1->1 가는 방향과 1,3 가는 방향, 3->3 가는 방향에서 1,3 가는 방향 두 가지의 방향을 체크한다음

5. 해당 A의 좌표들이 x 축도 다르고 y 축도 다를 경우와 x축은 같은데 y축이 다를 경우, x축은 다른데 y축이 같을 경우로 나눈다.

5. x, y 둘다 다를 경우 길목에 마주치는 * or 다른 알파벳이 있을 경우 false

6. 하나만 다를 경우는 사이에 1,1 -> 1,5로 가는 y증가 사이에 * or 다른 알파벳이 있을 경우 false



# 풀이

- 좋은 풀이

- https://dev-note-97.tistory.com/255

- https://gre-eny.tistory.com/170 **

- https://tosuccess.tistory.com/146

```

import java.util.*;

class Solution {
    char[][] board;
    int m, n;
    LinkedList<Character> list = new LinkedList<Character>();
    HashMap<Character, int[][]> map = new HashMap<>();
    public String solution(int m, int n, String[] board) {
        String answer = "";
        this.board = new char[m][n];
        this.m = m;
        this.n = n;
        
        //*:42, .:46
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                char c = board[i].charAt(j);
                this.board[i][j] = c;
                if(c != '.' && c != '*'){
                    if(!list.contains(c)){
                        list.add(c);
                        map.put(c, new int[2][2]);
                        map.get(c)[0][0] = i;
                        map.get(c)[0][1] = j;
                    }
                    else{
                        map.get(c)[1][0] = i;
                        map.get(c)[1][1] = j;
                    }
                }
            }
        }
        
        Collections.sort(list);
        
        int idx = 0;
        while(list.size() != 0){
            if(canDelete(list.get(idx))){
                char popped = list.remove(idx);
                answer += popped;
                deleteChar(popped);
                idx = 0;
            } 
            else{
                idx++;
                if(idx == list.size()){
                    return "IMPOSSIBLE";
                }       
            }
        }
        
        return answer;
    }
    
    void deleteChar(char a){
        board[map.get(a)[0][0]][map.get(a)[0][1]] = '.';
        board[map.get(a)[1][0]][map.get(a)[1][1]] = '.';
    }
    
    boolean canDelete(char a){
        int r1 = map.get(a)[0][0];
        int c1 = map.get(a)[0][1];
        int r2 = map.get(a)[1][0];
        int c2 = map.get(a)[1][1];
        
        if(c1 < c2){
            if(linearColumnCheck(c1, c2, r1, a) && linearRowCheck(r1, r2, c2, a)){
                return true;
            }
            if(linearRowCheck(r1, r2, c1, a) && linearColumnCheck(c1, c2, r2, a)){
                return true;
                }
        }else{
            if(linearRowCheck(r1, r2, c2, a) && linearColumnCheck(c2, c1, r1, a)){
                return true;
            }
            if(linearColumnCheck(c2, c1, r2, a) && linearRowCheck(r1, r2, c1, a)){
                return true;
            }
        }
        
        return false;
    }
    
    boolean linearRowCheck(int r1, int r2, int c, char a){
        for(int i = r1; i < r2+1; i++){
            if(board[i][c] != '.' && board[i][c] != a)
                return false;
        }
        return true;
    }
    
    boolean linearColumnCheck(int c1, int c2, int r, char a){
        for(int i = c1; i < c2+1; i++){
            if(board[r][i] != '.' && board[r][i] != a)
                return false;
        }
        return true;
    }
}


```

- 나의 풀이

```

import java.util.*;

class Solution {
    
        
    HashSet<String> alphaSet = new HashSet<>();
    boolean[] visited;
    String[] a;
    public String solution(int m, int n, String[] board) {
        
        String answer = "";
        
        HashSet<String> alpha = new HashSet<>();
        
        for (int i=0; i<board.length; i++) {
            
            for (String str : board[i].split("")) {
                
                if(str.equals("*") || str.equals(".")) continue;
                
                alpha.add(str);
                
            }
            
        }
        
        visited = new boolean[alpha.size()];
        a = new String[alpha.size()];
        
        
        Iterator it = alpha.iterator();
        
        int size = 0;
        
        while(it.hasNext()) {
            a[size++] = String.valueOf(it.next());
        }
        
        String[] copyBoard = new String[board.length];
        
        size = 0;
        
        for (String str : board) {
            copyBoard[size++] = str;
        }
        
        dfs(0, "", copyBoard);
        
        System.out.println(alphaSet);
        
        return answer;
    }
    
    public void dfs (int depth, String str, String[] board)
    {
        if(depth == a.length) {
            alphaSet.add(str);
            return;
        }
        
        
        for (int i=0; i<a.length; i++) {
            if(!visited[i] && check(a[i], board)) {
                visited[i] = true;
                dfs(depth+1, str+a[i], board);
                visited[i] = false;
            }
        }
    }
    
    boolean check(String a, String[] board)
    {
        if()
        
    }
}

```

```
import java.util.*;

class Solution {
    
        
    HashSet<String> alphaSet = new HashSet<>();
    boolean[] visited;
    String[] a;
    public String solution(int m, int n, String[] board) {
        
        String answer = "";
        
        HashSet<String> alpha = new HashSet<>();
        
        for (int i=0; i<board.length; i++) {
            
            for (String str : board[i].split("")) {
                
                if(str.equals("*") || str.equals(".")) continue;
                
                alpha.add(str);
                
            }
            
        }
        
        visited = new boolean[alpha.size()];
        a = new String[alpha.size()];
        
        Iterator it = alpha.iterator();
        
        int size = 0;
        
        while(it.hasNext()) {
            a[size++] = String.valueOf(it.next());
        }
        
        dfs(0, "");
        
        System.out.println(alphaSet);
        
        return answer;
    }
    
    public void dfs (int depth, String str)
    {
        if(depth == a.length) {
            alphaSet.add(str);
            return;
        }
        
        
        for (int i=0; i<a.length; i++) {
            if(!visited[i]) {
                visited[i] = true;
                dfs(depth+1, str+a[i]);
                visited[i] = false;
            }
        }
    }
}

```