# 스타 수열

# 문제 설명

1. 다음과 같은 것들을 정의합니다.

2. 어떤 수열 x의 부분 수열(Subsequence)이란,

3. x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.

```

예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.

다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다.

x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)

x의 길이를 2n이라 할 때, 다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다.

x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다.

예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.

1차원 정수 배열 a가 매개변수로 주어집니다.

a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요.

이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

```

# 제한 사항

```

a의 길이는 1 이상 500,000 이하입니다.

a의 모든 수는 0 이상 (a의 길이) 미만입니다.

a	result

[0]	0

[5,2,3,3,5,3]	4

[0,3,3,0,7,2,0,2,2,0]	8

입출력 예 설명

입출력 예 #1

a의 부분 수열 중에서 주어진 조건을 모두 만족하는 스타 수열이 없으므로, 0을 return 해야 합니다.

입출력 예 #2

[5,2,5,3], [5,3,3,5] 는 a의 부분 수열인 동시에 스타 수열입니다.

a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 4를 return 해야 합니다.

입출력 예 #3

[0,3,3,0,7,0,2,0] 는 a의 부분 수열인 동시에 스타 수열입니다.

a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 8을 return 해야 합니다.

```
# 해결 방안

1. 수열 내에서 새로운 수열을 만들어야 하기 때문에.. 개수를 셀 수 있는.. hashMap을 이용?

2. HashMap을 이용하고 각 키에 대한 카운트를 세더라도 스타수열을 만족하는지에 대한 확인이 어려운 것 같다.

# 풀이

- hashMap value정렬 entry 사용

- https://velog.io/@cgw0519/Java-HashMap-Value-%EA%B8%B0%EC%A4%80%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0

- 나의 풀이

```

중복이 발생하지 않으려면??

배열 b를 만들어서 해당 넘버를 삽입해 개수를 증가시킨다.

이 부분은 map으로도 만들 수 있는데 맵으로 하면 느려서 시간초과 난다고 한다.. 해볼까?


class Solution {
    public int solution(int[] a) {
        
        int answer = -1;
        
        int[] b = new int[a.length+1];
        
        for(int i=0;i<a.length;i++) {
            b[a[i]]++;
        }
        
        for(int i=0;i<b.length;i++) {
            
            int selectItem = i;
            
            if(b[i]*2<=answer) continue;
            
            int star=0;

            for(int j=0;j<a.length-1;j++) {
                if( (a[j] == selectItem || a[j+1] == selectItem) && (a[j] != a[j+1])) {
                    star+=2;
                    j++;
                } 
            }

            answer = Math.max(answer, star);
        }
        
        return answer;
    }
}



```

```

약 5배정도 느리다.

import java.util.*;

class Solution {
    public int solution(int[] a) {
        
        int answer = -1;
        
        HashMap<Integer, Integer> hashMap = new HashMap<>();

        for(int item : a) {
            hashMap.put(item, hashMap.getOrDefault(item,0)+1);
        }
        

        List<Map.Entry<Integer, Integer>> entryList = new LinkedList<>(hashMap.entrySet());
        
        entryList.sort((o1, o2) -> hashMap.get(o2.getKey()) - hashMap.get(o1.getKey()));

        for(Map.Entry<Integer, Integer> entry : entryList) {
            
            int item = entry.getValue();
            int key = entry.getKey();
            
            if(item * 2 <= answer) break;
            
            int star=0;

            for(int j=0;j<a.length-1;j++) {
                if( (a[j] == key || a[j+1] == key) && (a[j] != a[j+1])) {
                    star+=2;
                    j++;
                } 
            }

            answer = Math.max(answer, star);
            
        }
        
        
        return answer;
    }
}


```

```

속도는 비슷하나 28번 테스트케이스가 틀리다.

int answer = -1;
        
HashMap<Integer, Integer> hashMap = new HashMap<>();

for(int item : a) {
    hashMap.put(item, hashMap.getOrDefault(item,0)+1);
}


ArrayList<Integer> list = new ArrayList<>(hashMap.keySet());

Collections.sort(list, (o1, o2) -> (hashMap.get(o2) - hashMap.get(o1)));

for(int key : list) {
    
    int star = 0;
    
    if(hashMap.get(key) <= answer) break;
    
    for(int i=0;i<a.length-1;i++) {
        
        if( (a[i] == key || a[i+1] == key) && a[i] != a[i+1] ) {
            star+=2;
            i++;
        }
        
    }
    
    answer = Math.max(answer, star);
    
}



return answer;

```

```

시간초과 -> why? 중복이 발생하니까


class Solution {
    public int solution(int[] a) {
        
        int answer = -1;
        
        for(int i=0;i<a.length;i++) {

            int selectItem = a[i];

            int star=0;

            for(int j=0;j<a.length-1;j++) {
                if( (a[j] == selectItem || a[j+1] == selectItem) && (a[j] != a[j+1])) {
                    star+=2;
                    j++;
                } 
            }

            answer = Math.max(answer, star);
        }
        
        return answer;
    }
}

```

- 20210713

```
class Solution {
    public int solution(int[] a) {
        
        int answer = 0;
        
        int n = a.length;
        
        int[] b = new int [n];
        
        for (int i=0; i<n; i++) {
            b[a[i]]++;
        }
        
        for (int i=0; i<n; i++) {
            
            int num = i;
            
            if (b[i]*2<=answer) continue;
            
            int count = 0;
            
            for (int j=0; j<n-1; j++) {
                
                if ((a[j] == num || a[j+1] == num) && a[j] != a[j+1]) {
                    count+=2;
                    j++;
                }
                
            }
            
            answer = Math.max(answer, count);
        }
        
        
        return answer;
    }
}
```