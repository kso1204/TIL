# 키패드 누르기

# 문제 설명

1. 스마트폰 전화 키패드를 누르는 왼손과 오른손의 엄지 손가락

2. 엄지손가락은 상하좌우 4가지 방향 키패드 이동 한 칸은 거리 1

3. 왼쪽 열 3개의 숫자 1, 4, 7은 왼손 엄지

4. 오른쪽 열 3개의 숫자 3, 6, 9는 오른손 엄지

5. 가운데 4개의 숫자 2, 5, 8, 0은 두 엄지 손가락의 현재 키패드의 위치에서 더 가까운 엄지 손가락 **

6. 만약 두 엄지손가락의 길이가 같다면 오른손잡이는 오른손 엄지로, 왼손잡이는 왼손 엄지로 **

7. 순서대로 누를 번호 배열 numbers, 왼손 잡이 오른손 잡이 hand, 왼손으로 눌렀는지 오른손으로 눌렀는지 결과값 스트링 return 

# 제한 사항

1. numbers 배열 크기는 1 ~ 1,000

2. numbers 배열 원소의 값 0 ~ 9 이하 정수

3. hand는 "left" or "right"

4. 왼손 엄지는 L, 오른손 엄지는 R


```

[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]	"right"	 "LRLLLRLLRRL"

```

# 해결 방안

1. 각 엄지 손가락의 위치를 저장해야 한다.

2. 초기값 왼손 엄지 * 오른손 엄지 #

2. 각 엄지 손가락에서 다음 키패드를 누를 거리를 계산해야 한다. 2, 5, 8, 0일 경우에만

3. 각 넘버를 좌표로 생각해서 위치를 저장하고 거리를 구한다면? 각 넘버에 대한 좌표를 미리 저장한다?

4. 각 넘버에 대한 좌표를 저장하려면 어떤 자료구조를 사용해야 할까?

5. aa[1]=[1,1]; left_hands_current = 1; -> [1,1];

```

처음 생각 한 내용

1,1 2,1 3,1
1,2 2,2 3,2
1,3 2,3 3,3
1,4 2,4 3,4


for(int i=1;i<=3;i++) {
    for(int j=1;j<=3;j++) {
        current[i]=(i,j);
    }
}

current[0]=2,4;

length 구하기(current, destination) {
    return |current[x] - destination[x]| + |current[y] - destination[y]| 
}

초기 값 왼손엄지 1,4 오른손 엄지 3,4

left[current] = 1,4 

right[current] = 3,4

for(int i=0;i<=numbers.length; i++) {
    numbers[i]==1이면
    left = 1,1
}

1,4,7 은 left엄지

2,5,8,0 은 length 비교-> 같으면 -> 왼손 오른손 비교-> 해서 위치 저장

포인트 클래스 만들고, 해당 거리 구하는 부분 추가하고, 키패드 포인트, 왼손 포인트, 오른손 포인트 

해당 넘버를 받을 때 마다 넘버에 맞는 포인트를 설정해야 한다.

두 번째

1 2 3

4 5 6

7 8 9

10 0 11 이라고 생각해서

현재 위치에서 해당 거리를 계산하기..




```



# 풀이