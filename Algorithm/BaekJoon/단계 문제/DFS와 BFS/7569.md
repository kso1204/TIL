# 토마토

# 카테고리 

1. BFS

2. 심화

# 해결 방안

1. 3차원 BFS

2. 2차원 토마토와 다른점은 3차원 배열을 사용했다는 것, 그로 인해 조건이 하나 더 추가된 부분밖에 없다 2 -> 3에 어려움을 느꼈다면 BFS에 대한 이해가 조금 부족한 부분

# 풀이

```


import java.io.*;
import java.util.*;

public class Main {


    private static int[][][] map;
    private static int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    private static int[] dirH = {-1, 1};
    private static int N;
    private static int M;
    private static StringBuilder sb = new StringBuilder();
    private static int answer;
    private static boolean[][][] visited;
    private static Queue<Node> queue;
    private static int H;

    static class Node {
        int r;
        int c;
        int h;

        Node (int r, int c, int h) {
            this.r = r;
            this.c = c;
            this.h = h;
        }
    }

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        M = Integer.parseInt(st.nextToken());
        N = Integer.parseInt(st.nextToken());
        H = Integer.parseInt(st.nextToken());

        map = new int[N][M][H];
        visited = new boolean[N][M][H];
        int startR = 0;
        int startC = 0;

        boolean check = true;
        queue = new LinkedList<>();
        answer = 0;

        for (int k=0; k<H; k++) {
            for (int i=0; i<N; i++) {

                st = new StringTokenizer(br.readLine());

                for (int j=0; j<M; j++) {

                    map[i][j][k] = Integer.parseInt(st.nextToken());

                    if (map[i][j][k] == 1) {
                        queue.offer(new Node(i, j, k));
                    } else {

                        if (map[i][j][k] == 0) {
                            check = false;
                        }
                    }
                }
            }
        }



        if (check) {
            System.out.println(answer);
        } else {
            bfs();

            check = true;

            for (int k=0; k<H; k++) {
                for (int i=0; i<N; i++) {
                    for (int j=0; j<M; j++) {
                        if (map[i][j][k] == 0) {
                            check = false;
                            break;
                        }
                    }
                }
            }

            if (check) {
                System.out.println(answer - 1);
            } else {
                System.out.println(-1);
            }
        }



    }

    private static void bfs() {


        while (!queue.isEmpty()) {

            int size = queue.size();

            answer++;

            for (int i=0; i<size; i++) {

                Node cur = queue.poll();

                int r = cur.r;
                int c = cur.c;
                int h = cur.h;

                for (int d=0; d<4; d++) {

                    int dr = r + dir[d][0];
                    int dc = c + dir[d][1];

                    if (dr < 0 || dr >= N || dc < 0 || dc >= M) continue;

                    if (visited[dr][dc][h]) continue;

                    if (map[dr][dc][h] != -1) {
                        queue.offer(new Node(dr, dc, h));
                        map[dr][dc][h] = 1;
                        visited[dr][dc][h] = true;
                    }


                }

                for (int k = 0; k<2; k++) {

                    int dh = h + dirH[k];

                    if (dh >= H || dh < 0) continue;

                    if (visited[r][c][dh]) continue;

                    if (map[r][c][dh] != -1) {
                        queue.offer(new Node(r, c, dh));
                        map[r][c][dh] = 1;
                        visited[r][c][dh] = true;
                    }

                }
            }


        }


    }
}

```