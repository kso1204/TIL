1. 네트워크 유량

- 그래프에서 각 노드들 간의 용량이 정의되어 있을 시, 시작점에서 끝점까지 흐를 수 있는 최대 유량을 구하는 문제

- DFS로 구현하는 포드 폴커슨 알고리즘
- BFS로 구현하는 에드몬드 카프 알고리즘

- 일반적으로 많이 쓰이는 방안
- 소스 : 시작점
- 싱크 : 끝점
- 정점 : 유량이 모이는 위치
- 간선 : 유량이 흐르는 파이프 역할
- 용량 : 유량이 흐를 수 있는 크기 = c(u,v) u에서 v로 흐를 수 있는 용량
- 유량 : 간선에 흐르는 현재 유량의 크기 = f(u,v) u에서 v로 흐른 실제 유량
- 잔류 유량 : c(u,v) - f(u,v) = 현재 간선에 흐를 수 있는 유량이 얼마인지
- 용량 제한 속성 : f(u,v) <= c(u,v) 
- 유량의 대칭성 : f(u,v) = -f(v,u) u에서 v로 보낸 유량은 v에서 u의 역방향으로 보낸 유량과 의미상 같다 (잔류 유량?)
- 유량의 보존 : f(u, v) = 0 각 정점에 들어오는 유량과 나가는 유량의 양은 정확히 같아야 함

```

증가 경로를 통해 흘려보낼 수 있는 유량의 최대량은, 포함된 간선의 잔여 유량 중 가장 작은 값으로 결정된다.

1. c(u,v) - f(u,v) > 0 인 증가경로를 아무거나 찾는다.

2. c(u,v) - f(u,v) 값이 가장 작은 값

3. 찾은 증가 경로 상의 모든 간선에 그 만큼의 유량을 추가한다.

증가 경로가 더이상 존재하지 않을 때까지 증가 경로를 찾고, 보낼 수 있는 최대 유량을 해당 경로를 따라 보내는 작업을 반복한다.

```

2. 최소 신장(스패닝) 트리

- 통신망, 도로망, 유통망에서 길이, 구축 비용, 전송 시간 등을 최소로 구축하려는 경우
- 도로 건설 - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
- 전기 회로 - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제 

- 크루스칼 알고리즘 - 탐욕적인 방법을 이용하여 네트워크의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것

```

그래프의 간선들을 가중치의 오름차순으로 정렬한다.

정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.

가장 낮은 가중치를 선택, 사이클 형성하면 제외

해당 간선을 현재의 최소 비용 신장 트리의 집합에 추가한다.

```

- 프림 알고리즘 - 시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장해나가는 방법

```

시작 단계에서는 시작 정점만이 최소 비용 신장 트리 집합에 포함된다.

앞 단계에서 만들어진 최소 비용 신장 트리 집합에 인접한 정점들 중에서 갖아 낮은 가중치를 선택한다.

위의 과정을 트리가 (N-1)개의 간선을 가질 때까지 반복한다.

```

3. 최단 경로 알고리즘

- 최단 경로 문제는 정점 u와 정점 v를 연결하는 경로 중 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제다.
- 간선의 가중치는 경우에 따라 비용, 거리, 시간 등으로 해석될 수 있다.
- 다익스트라 알고리즘 - 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산한다.

```

다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작한다.

다익스트라 최단 경로 알고리즘은 그리디 알고리즘 - 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복한다.

출발 노드를 설정한다.

최단 거리 테이블을 초기화한다

방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다

해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.

위 과정에서 3, 4번을 반복한다.

알고리즘 동작 과정에서 최단 거리 테이블은 각 노드에 대한 현재까지의 최단 거리 정보를 가지고 있다.

처리 과정에서 더 짧은 경로를 찾으면 '이 경로가 앞으로 최단 거리야'라고 갱신한다.

한 번 처리된 노드의 최단 거리는 고정되어 더 이상 바뀌지 않는다.

```
- 플로워드 워셜 알고리즘 - 모든 노드에서 다른 노드까지의 최단 경로를 모두 계산한다

```

다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘을 수행한다.

다만 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다.

플로이드 워셜은 2차원 테이블에 최단 거리를 저장한다.

플로이드 워셜 알고리즘은 다이나믹 프로그래밍 유형에 속한다.

각 단계마다 특정한 노드 K를 거쳐 가는 경우를 확인한다.

a에서 b로 가는 최단거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사한다.

D(ab) = min(D(ab), D(ak) + D(kb))

```

4. 위상 정렬

- 위상 정렬은 '순서가 정해져있는 작업'을 차례로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘이다.
- 위상 정렬은 DAG(Directed Acyclic Graph)에만 가능한데, 사이클이 발생하지 않는 방향 그래프라는 의미이다.

```

진입 차수가 0인 노드를 큐에 삽입한다.

정렬이 완전히 수행되려면 정확히 n개의 노드를 방문해야 한다.

n개를 방문하기 전에 큐가 비어버리면 사이클이 발생했으므로 위상정렬 X

방문했을 때 차수를 하나씩 줄여 새롭게 진입 차수가 0이 된 정점을 큐에 삽입한다.

```

5. 강한연결요소

- 강한 연결 요소는 어떤 양방향 그래프 내에서 다음 조건을 만족하는 부분 집합이다.
- 임의의 강한 연결 요소 내부의 모든 정점끼리는 서로 이어진 경로가 존재한다.
- 임의의 강한 연결 요소 내부의 정점과 외부의 정점끼리는 서로 이어진 경로가 존재하지 않는다.

- 코사라주 알고리즘

```

코사라주 알고리즘은 DFS를 이용한 위상 정렬을 토대로 SCC를 찾는 알고리즘이다.

그래프와 역방향 그래프를 준비한다.

그래프에서 모든 미방문 정점에 대해 DFS를 수행한다.

DFS가 먼저 끝나는 순서대로 스택에 넣는다.

스택에서 정점을 뽑아 그 정점에서부터 역방향 그래프에 DFS를 수행한다.

순회한 정점들의 집합이 SCC이다.

```

- 타잔 알고리즘

```

타잔 알고리즘은 두 가지 지표를 이용해 SCC를 구한다.


int dfs(int x) {
	d[x] = ++id; // 노드마다 고유한 번호 할당
	s.push(x); // 스택에 자기 자신을 삽입합니다.
	
	int parent = d[x];
	for(int i = 0; i < a[x].size(); i++) {
		int y = a[x][i];
		// 방문하지 않은 이웃
		if(d[y] == 0)
			parent = min(parent, dfs(y));
		// 처리 중인 이웃
		else if(!finished[y])
			parent = min(parent, d[y]);
	}
	
	// 부모노드가 자기 자신인 경우
	if(parent == d[x]) {
		vector<int> scc;
		while(1) {
			int t = s.top();
			s.pop();
			scc.push_back(t);
			finished[t] = true;
			if(t == x) break;
		}
		SCC.push_back(scc);
	}
	
	// 자신의 부모 값을 반환한다.
	return parent;
}

```

6. 이분 매칭 

이분 매칭이란 A집단이 B집단이랑 매칭 할 때 가장 많이 연결되는 경우를 찾는 문제

```

A의 정점과 B의 정점 매칭

[코드 추가 설명] 위의 코드에서 if (matchBA[b] == -1 || dfs(matchBA[b]))의 의미에 대해 알아보자. a와 인접한 정점 b가 아무하고도 매칭이 안되어 있으면 a와 b를 매치시킨다. 하지만 만약 정점 b가 이미 다른 A의 정점 matchBA[b]와 매칭되어 있다면, matchBA[b]에서 b로 가지 않고 다른 정점과 매치될 수 있는지 찾는다. 만약 매칭에 성공하였다면 이제 b는 매칭이 안되어 있는 정점이 되었으므로 a와 b를 매치시킨다.
[출처] 네트워크 유량 (2): 이분 매칭|작성자 3587jjh

```
